<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>React Native v0.80 Master Course - Learn by Doing</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0066FF">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary: #0066FF;
      --primary-dark: #0052CC;
      --secondary: #61DAFB;
      --success: #10B981;
      --warning: #F59E0B;
      --danger: #EF4444;
      --dark: #1E293B;
      --light: #F8FAFC;
      --text: #334155;
      --border: #E2E8F0;
      --shadow: rgba(0, 0, 0, 0.1);
      --gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--light);
      color: var(--text);
      line-height: 1.6;
      overflow-x: hidden;
    }

    /* Loading Screen */
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--primary);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      transition: opacity 0.5s, visibility 0.5s;
    }

    .loading-screen.hidden {
      opacity: 0;
      visibility: hidden;
    }

    .loader {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Header */
    .header {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
      padding: 2rem 0;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 10px var(--shadow);
    }

    .header-content {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 1rem;
      font-size: 1.5rem;
      font-weight: bold;
    }

    .logo i {
      font-size: 2rem;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-10px);
      }
    }

    /* Progress Bar */
    .progress-container {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      padding: 0.5rem;
      min-width: 300px;
    }

    .progress-bar {
      background: var(--secondary);
      height: 8px;
      border-radius: 5px;
      transition: width 0.5s ease;
      position: relative;
      overflow: hidden;
    }

    .progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      transform: translateX(-100%);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      to {
        transform: translateX(100%);
      }
    }

    .progress-text {
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }

    /* Main Layout */
    .main-container {
      display: flex;
      max-width: 1400px;
      margin: 0 auto;
      gap: 2rem;
      padding: 2rem;
      position: relative;
    }

    /* Sidebar */
    .sidebar {
      width: 300px;
      background: white;
      border-radius: 15px;
      padding: 1.5rem;
      box-shadow: 0 5px 20px var(--shadow);
      position: sticky;
      top: 120px;
      height: fit-content;
      max-height: calc(100vh - 140px);
      overflow-y: auto;
      transition: transform 0.3s ease;
    }

    .sidebar::-webkit-scrollbar {
      width: 5px;
    }

    .sidebar::-webkit-scrollbar-track {
      background: var(--light);
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 5px;
    }

    .section-group {
      margin-bottom: 1.5rem;
    }

    .section-title {
      font-weight: bold;
      color: var(--dark);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 8px;
      transition: background 0.3s;
    }

    .section-title:hover {
      background: var(--light);
    }

    .section-title i {
      color: var(--primary);
      transition: transform 0.3s;
    }

    .section-title.collapsed i {
      transform: rotate(-90deg);
    }

    .topic-list {
      margin-left: 1.5rem;
      max-height: 500px;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .topic-list.collapsed {
      max-height: 0;
    }

    .topic-item {
      padding: 0.5rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .topic-item:hover {
      background: var(--light);
      transform: translateX(5px);
    }

    .topic-item.active {
      background: var(--primary);
      color: white;
    }

    .topic-item.completed {
      color: var(--success);
    }

    .topic-item.completed::before {
      content: '✓';
      color: var(--success);
      font-weight: bold;
    }

    /* Content Area */
    .content {
      flex: 1;
      background: white;
      border-radius: 15px;
      padding: 2rem;
      box-shadow: 0 5px 20px var(--shadow);
      animation: slideIn 0.5s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .content h1 {
      color: var(--dark);
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .content h2 {
      color: var(--primary);
      margin: 2rem 0 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .content h3 {
      color: var(--dark);
      margin: 1.5rem 0 0.5rem;
    }

    .content p {
      margin-bottom: 1rem;
      line-height: 1.8;
    }

    /* Code Blocks */
    .code-container {
      position: relative;
      margin: 1.5rem 0;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 3px 10px var(--shadow);
    }

    .code-header {
      background: var(--dark);
      color: white;
      padding: 0.5rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .code-language {
      font-size: 0.9rem;
      opacity: 0.8;
    }

    .code-actions {
      display: flex;
      gap: 0.5rem;
    }

    .code-btn {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.8rem;
      transition: all 0.3s;
    }

    .code-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: white;
    }

    .code-btn.copied {
      background: var(--success);
      border-color: var(--success);
    }

    pre {
      margin: 0 !important;
      border-radius: 0 !important;
    }

    code {
      font-family: 'Fira Code', 'Consolas', monospace;
      font-size: 0.9rem;
    }

    /* Interactive Code Playground */
    .playground {
      margin: 2rem 0;
      border: 2px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
    }

    .playground-header {
      background: var(--dark);
      color: white;
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .playground-tabs {
      display: flex;
      gap: 1rem;
    }

    .playground-tab {
      padding: 0.5rem 1rem;
      background: transparent;
      border: none;
      color: white;
      cursor: pointer;
      border-radius: 5px;
      transition: background 0.3s;
    }

    .playground-tab.active {
      background: var(--primary);
    }

    .playground-content {
      display: flex;
      height: 400px;
    }

    .playground-editor {
      flex: 1;
      position: relative;
    }

    .playground-preview {
      flex: 1;
      background: #f5f5f5;
      padding: 1rem;
      overflow: auto;
      border-left: 1px solid var(--border);
    }

    .editor-textarea {
      width: 100%;
      height: 100%;
      padding: 1rem;
      border: none;
      font-family: 'Fira Code', monospace;
      font-size: 0.9rem;
      resize: none;
      background: #1e1e1e;
      color: #d4d4d4;
      outline: none;
    }

    /* Quiz Section */
    .quiz-container {
      margin: 2rem 0;
      padding: 1.5rem;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      border-radius: 10px;
    }

    .quiz-question {
      font-size: 1.1rem;
      font-weight: 500;
      margin-bottom: 1rem;
      color: var(--dark);
    }

    .quiz-options {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .quiz-option {
      padding: 1rem;
      background: white;
      border: 2px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
    }

    .quiz-option:hover {
      border-color: var(--primary);
      transform: translateX(5px);
    }

    .quiz-option.selected {
      border-color: var(--primary);
      background: rgba(0, 102, 255, 0.1);
    }

    .quiz-option.correct {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.1);
    }

    .quiz-option.incorrect {
      border-color: var(--danger);
      background: rgba(239, 68, 68, 0.1);
    }

    .quiz-feedback {
      margin-top: 1rem;
      padding: 1rem;
      border-radius: 8px;
      display: none;
    }

    .quiz-feedback.show {
      display: block;
      animation: slideIn 0.3s ease;
    }

    .quiz-feedback.correct {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
      border: 1px solid var(--success);
    }

    .quiz-feedback.incorrect {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      border: 1px solid var(--danger);
    }

    /* Mini Projects */
    .project-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 2rem;
      border-radius: 15px;
      margin: 2rem 0;
      position: relative;
      overflow: hidden;
    }

    .project-card::before {
      content: '';
      position: absolute;
      top: -50%;
      right: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
      animation: rotate 20s linear infinite;
    }

    @keyframes rotate {
      to {
        transform: rotate(360deg);
      }
    }

    .project-title {
      font-size: 1.5rem;
      margin-bottom: 1rem;
      position: relative;
    }

    .project-description {
      margin-bottom: 1.5rem;
      position: relative;
    }

    .project-tasks {
      background: rgba(0, 0, 0, 0.2);
      padding: 1rem;
      border-radius: 10px;
      position: relative;
    }

    .project-task {
      padding: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .project-task input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    /* Tips and Best Practices */
    .tip-box {
      background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
      padding: 1.5rem;
      border-radius: 10px;
      margin: 1.5rem 0;
      position: relative;
      overflow: hidden;
    }

    .tip-box::before {
      content: '💡';
      position: absolute;
      top: -20px;
      right: -20px;
      font-size: 100px;
      opacity: 0.1;
    }

    .tip-box h4 {
      color: #2d3436;
      margin-bottom: 0.5rem;
    }

    .tip-box p {
      color: #2d3436;
      margin: 0;
    }

    /* Warning Box */
    .warning-box {
      background: linear-gradient(135deg, #ff7979 0%, #eb4d4b 100%);
      color: white;
      padding: 1.5rem;
      border-radius: 10px;
      margin: 1.5rem 0;
      position: relative;
      overflow: hidden;
    }

    .warning-box::before {
      content: '⚠️';
      position: absolute;
      top: -20px;
      right: -20px;
      font-size: 100px;
      opacity: 0.1;
    }

    /* AI Help Button */
    .ai-help-btn {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      width: 60px;
      height: 60px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 5px 20px var(--shadow);
      transition: all 0.3s;
      z-index: 50;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
    }

    .ai-help-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 30px var(--shadow);
    }

    /* AI Help Modal */
    .ai-help-modal {
      position: fixed;
      bottom: 100px;
      right: 2rem;
      width: 400px;
      max-width: calc(100vw - 4rem);
      background: white;
      border-radius: 15px;
      box-shadow: 0 10px 40px var(--shadow);
      display: none;
      z-index: 100;
      animation: slideUp 0.3s ease;
    }

    .ai-help-modal.show {
      display: block;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .ai-help-header {
      background: var(--primary);
      color: white;
      padding: 1rem;
      border-radius: 15px 15px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .ai-help-content {
      padding: 1.5rem;
      max-height: 400px;
      overflow-y: auto;
    }

    .ai-help-search {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 1rem;
      font-size: 1rem;
    }

    .ai-help-suggestions {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .ai-help-item {
      padding: 1rem;
      background: var(--light);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      border: 1px solid transparent;
    }

    .ai-help-item:hover {
      background: white;
      border-color: var(--primary);
      transform: translateX(5px);
    }

    /* Mobile Menu */
    .mobile-menu-btn {
      display: none;
      background: transparent;
      border: 2px solid white;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
    }

    /* Dark Mode */
    .dark-mode-toggle {
      position: fixed;
      top: 2rem;
      right: 2rem;
      background: var(--dark);
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 3px 10px var(--shadow);
      transition: all 0.3s;
      z-index: 200;
    }

    .dark-mode-toggle:hover {
      transform: scale(1.1);
    }

    body.dark-mode {
      --light: #0F172A;
      --dark: #F8FAFC;
      --text: #E2E8F0;
      --border: #334155;
      --shadow: rgba(0, 0, 0, 0.3);
      background: #0F172A;
    }

    body.dark-mode .content,
    body.dark-mode .sidebar {
      background: #1E293B;
      color: #E2E8F0;
    }

    body.dark-mode .section-title,
    body.dark-mode .content h1,
    body.dark-mode .content h3 {
      color: #F8FAFC;
    }

    body.dark-mode .topic-item:hover,
    body.dark-mode .section-title:hover {
      background: #334155;
    }

    body.dark-mode .ai-help-modal {
      background: #1E293B;
    }

    body.dark-mode .ai-help-item {
      background: #334155;
    }

    body.dark-mode .ai-help-item:hover {
      background: #475569;
    }

    /* Responsive Design */
    @media (max-width: 1024px) {
      .sidebar {
        position: fixed;
        left: -300px;
        top: 0;
        height: 100vh;
        z-index: 1000;
      }

      .sidebar.open {
        transform: translateX(300px);
      }

      .mobile-menu-btn {
        display: block;
      }

      .main-container {
        flex-direction: column;
        padding: 1rem;
      }

      .content {
        padding: 1.5rem;
      }

      .playground-content {
        flex-direction: column;
        height: auto;
      }

      .playground-preview {
        border-left: none;
        border-top: 1px solid var(--border);
        min-height: 200px;
      }

      .ai-help-modal {
        width: calc(100vw - 2rem);
        right: 1rem;
        bottom: 80px;
      }
    }

    @media (max-width: 640px) {
      .header-content {
        flex-direction: column;
        text-align: center;
      }

      .progress-container {
        min-width: 100%;
      }

      .code-container {
        margin: 1rem -1rem;
        border-radius: 0;
      }
    }

    /* Animations */
    .fade-in {
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    .slide-in-right {
      animation: slideInRight 0.5s ease;
    }

    @keyframes slideInRight {
      from {
        transform: translateX(50px);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* Offline Indicator */
    .offline-indicator {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--warning);
      color: white;
      text-align: center;
      padding: 0.5rem;
      transform: translateY(-100%);
      transition: transform 0.3s;
      z-index: 9999;
    }

    .offline-indicator.show {
      transform: translateY(0);
    }

    /* Celebration Animation */
    .celebration {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
      z-index: 9999;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background: var(--primary);
      animation: confetti 3s ease-in-out;
    }

    @keyframes confetti {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 1;
      }

      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }

    /* Print Styles */
    @media print {

      .sidebar,
      .ai-help-btn,
      .dark-mode-toggle,
      .mobile-menu-btn,
      .code-actions {
        display: none !important;
      }

      .main-container {
        display: block;
      }

      .content {
        box-shadow: none;
        padding: 0;
      }
    }
  </style>
</head>

<body>
  <!-- Loading Screen -->
  <div class="loading-screen" id="loadingScreen">
    <div class="loader"></div>
  </div>

  <!-- Offline Indicator -->
  <div class="offline-indicator" id="offlineIndicator">
    <i class="fas fa-wifi-slash"></i> You're offline - Content available from cache
  </div>

  <!-- Header -->
  <header class="header">
    <div class="header-content">
      <div class="logo">
        <i class="fab fa-react"></i>
        <span>React Native v0.80 Master Course</span>
      </div>
      <button class="mobile-menu-btn" onclick="toggleSidebar()">
        <i class="fas fa-bars"></i> Menu
      </button>
      <div class="progress-container">
        <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        <div class="progress-text" id="progressText">0% Complete</div>
      </div>
    </div>
  </header>

  <!-- Dark Mode Toggle -->
  <button class="dark-mode-toggle" onclick="toggleDarkMode()">
    <i class="fas fa-moon" id="darkModeIcon"></i>
  </button>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <!-- Course sections will be dynamically loaded here -->
    </aside>

    <!-- Content Area -->
    <main class="content" id="content">
      <!-- Content will be dynamically loaded here -->
    </main>
  </div>

  <!-- AI Help Button -->
  <button class="ai-help-btn" onclick="toggleAIHelp()">
    <i class="fas fa-robot"></i>
  </button>

  <!-- AI Help Modal -->
  <div class="ai-help-modal" id="aiHelpModal">
    <div class="ai-help-header">
      <h3><i class="fas fa-robot"></i> AI Assistant</h3>
      <button onclick="toggleAIHelp()" style="background: none; border: none; color: white; cursor: pointer;">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="ai-help-content">
      <input type="text" class="ai-help-search" placeholder="Search for help..." id="aiHelpSearch">
      <div class="ai-help-suggestions" id="aiHelpSuggestions">
        <!-- Help suggestions will be dynamically loaded -->
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
  <script>
    // Course Data Structure
    const courseData = {
      sections: [
        {
          id: 'getting-started',
          title: 'Getting Started',
          icon: 'fas fa-rocket',
          topics: [
            { id: 'intro', title: 'Introduction to React Native', completed: false },
            { id: 'setup', title: 'Environment Setup', completed: false },
            { id: 'first-app', title: 'Your First App', completed: false },
            { id: 'project-structure', title: 'Project Structure', completed: false },
            { id: 'dev-tools', title: 'Development Tools', completed: false }
          ]
        },
        {
          id: 'core-components',
          title: 'Core Components',
          icon: 'fas fa-cube',
          topics: [
            { id: 'view-text', title: 'View and Text', completed: false },
            { id: 'image-imagebackground', title: 'Image & ImageBackground', completed: false },
            { id: 'scrollview-flatlist', title: 'ScrollView & FlatList', completed: false },
            { id: 'textinput', title: 'TextInput & Forms', completed: false },
            { id: 'touchables', title: 'Touchable Components', completed: false },
            { id: 'modal-alert', title: 'Modal & Alerts', completed: false },
            { id: 'activityindicator', title: 'ActivityIndicator', completed: false },
            { id: 'statusbar', title: 'StatusBar', completed: false }
          ]
        },
        {
          id: 'styling',
          title: 'Styling & Layout',
          icon: 'fas fa-paint-brush',
          topics: [
            { id: 'stylesheet', title: 'StyleSheet API', completed: false },
            { id: 'flexbox', title: 'Flexbox Layout', completed: false },
            { id: 'responsive', title: 'Responsive Design', completed: false },
            { id: 'platform-specific', title: 'Platform-Specific Code', completed: false },
            { id: 'styled-components', title: 'Styled Components', completed: false },
            { id: 'themes', title: 'Theming', completed: false }
          ]
        },
        {
          id: 'state-management',
          title: 'State & Hooks',
          icon: 'fas fa-database',
          topics: [
            { id: 'usestate', title: 'useState Hook', completed: false },
            { id: 'useeffect', title: 'useEffect Hook', completed: false },
            { id: 'usecontext', title: 'Context API', completed: false },
            { id: 'usereducer', title: 'useReducer Hook', completed: false },
            { id: 'custom-hooks', title: 'Custom Hooks', completed: false },
            { id: 'redux', title: 'Redux Integration', completed: false },
            { id: 'zustand', title: 'Zustand', completed: false },
            { id: 'mobx', title: 'MobX', completed: false }
          ]
        },
        {
          id: 'navigation',
          title: 'Navigation',
          icon: 'fas fa-compass',
          topics: [
            { id: 'react-navigation', title: 'React Navigation Setup', completed: false },
            { id: 'stack-navigator', title: 'Stack Navigator', completed: false },
            { id: 'tab-navigator', title: 'Tab Navigator', completed: false },
            { id: 'drawer-navigator', title: 'Drawer Navigator', completed: false },
            { id: 'nested-navigation', title: 'Nested Navigation', completed: false },
            { id: 'deep-linking', title: 'Deep Linking', completed: false },
            { id: 'navigation-params', title: 'Navigation Parameters', completed: false }
          ]
        },
        {
          id: 'animations',
          title: 'Animations',
          icon: 'fas fa-magic',
          topics: [
            { id: 'animated-api', title: 'Animated API Basics', completed: false },
            { id: 'layout-animations', title: 'Layout Animations', completed: false },
            { id: 'gesture-handler', title: 'Gesture Handler', completed: false },
            { id: 'reanimated2', title: 'Reanimated 2', completed: false },
            { id: 'shared-element', title: 'Shared Element Transitions', completed: false },
            { id: 'lottie', title: 'Lottie Animations', completed: false },
                        { id: 'animation-practices', title: 'Animation Best Practices', completed: false }

          ]
        },
        {
          id: 'data-management',
          title: 'Data Management',
          icon: 'fas fa-server',
          topics: [
            { id: 'fetch-api', title: 'Fetch API & Axios', completed: false },
            { id: 'async-storage', title: 'AsyncStorage', completed: false },
            { id: 'database-solutions', title: 'Database Solutions', completed: false },
            { id: 'state-management-libraries', title: 'State Management Libraries', completed: false },
            { id: 'file-system-and-media', title: 'File System & Media', completed: false },
            { id: 'sqlite', title: 'SQLite Database', completed: false },
            { id: 'realm', title: 'Realm Database', completed: false },
            { id: 'firebase', title: 'Firebase Integration', completed: false },
            { id: 'graphql', title: 'GraphQL with Apollo', completed: false },
            { id: 'offline-sync', title: 'Offline Data Sync', completed: false }
          ]
        },
        {
          id: 'testing-debugging',
          title: 'Testing & Debugging',
          icon: 'fas fa-bug',
          topics: [
            { id: 'debugging-tools', title: 'Debugging Tools', completed: false },
            { id: 'flipper', title: 'Flipper', completed: false },
            { id: 'jest-setup', title: 'Jest Setup', completed: false },
            { id: 'testing-library', title: 'React Native Testing Library', completed: false },
            { id: 'detox', title: 'E2E Testing with Detox', completed: false },
            { id: 'performance', title: 'Performance Optimization', completed: false }
          ]
        },
        {
          id: 'publishing',
          title: 'Publishing',
          icon: 'fas fa-upload',
          topics: [
            { id: 'app-icons', title: 'App Icons & Splash Screens', completed: false },
            { id: 'signing', title: 'Code Signing', completed: false },
            { id: 'play-store', title: 'Google Play Store', completed: false },
            { id: 'app-store', title: 'Apple App Store', completed: false },
            { id: 'codepush', title: 'CodePush Updates', completed: false },
            { id: 'ci-cd', title: 'CI/CD Pipeline', completed: false }
          ]
        }
      ]
    };

    // Course Content
    const courseContent = {
      'intro': {
        title: 'Introduction to React Native',
        content: `
                    <h1><i class="fab fa-react"></i> Introduction to React Native</h1>
                    
                    <p>Welcome to the world of React Native! This powerful framework allows you to build native mobile applications using JavaScript and React. Let's explore what makes React Native special and why it's become the go-to choice for cross-platform mobile development.</p>

                    <h2><i class="fas fa-question-circle"></i> What is React Native?</h2>
                    <p>React Native is an open-source framework created by Facebook (now Meta) that enables developers to build mobile applications using JavaScript and React. Unlike traditional hybrid frameworks, React Native doesn't use WebViews. Instead, it renders using native platform components, providing a truly native user experience.</p>

                    <div class="tip-box">
                        <h4><i class="fas fa-lightbulb"></i> Key Insight</h4>
                        <p>React Native follows the "learn once, write anywhere" philosophy, not "write once, run anywhere". This means you'll use the same concepts across platforms but can customize for each platform when needed.</p>
                    </div>

                    <h2><i class="fas fa-star"></i> Key Features of React Native v0.80</h2>
                    <ul>
                        <li><strong>New Architecture:</strong> Fabric renderer and TurboModules for better performance</li>
                        <li><strong>Hermes Engine:</strong> Optimized JavaScript engine for React Native</li>
                        <li><strong>TypeScript Support:</strong> First-class TypeScript support out of the box</li>
                        <li><strong>Improved Developer Experience:</strong> Better error messages and debugging tools</li>
                        <li><strong>Performance Improvements:</strong> Faster app startup and runtime performance</li>
                    </ul>

                    <h2><i class="fas fa-chart-line"></i> Why Choose React Native?</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Benefits</span>
                        </div>
                        <pre><code class="language-javascript">// One Codebase, Multiple Platforms
const App = () => {
  return (
    <View>
      <Text>This runs on both iOS and Android!</Text>
    </View>
  );
};

// Native Performance
// React Native compiles to native code, not web views
// You get 60fps animations and native look & feel

// Hot Reloading
// See changes instantly without rebuilding
// Preserve app state while editing

// Large Ecosystem
// Access to thousands of npm packages
// Native modules for platform-specific features</code></pre>
                    </div>

                    <h2><i class="fas fa-cogs"></i> How React Native Works</h2>
                    
                    <div class="playground">
                        <div class="playground-header">
                            <h3><i class="fas fa-play-circle"></i> Interactive Example</h3>
                            <div class="playground-tabs">
                                <button class="playground-tab active" onclick="switchPlaygroundTab(this, 'code')">Code</button>
                                <button class="playground-tab" onclick="switchPlaygroundTab(this, 'preview')">Preview</button>
                            </div>
                        </div>
                        <div class="playground-content">
                            <div class="playground-editor" id="playground-code">
                                <textarea class="editor-textarea" id="playgroundEditor">
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const WelcomeScreen = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>
        Welcome to React Native!
      </Text>
      <Text style={styles.subtitle}>
        Build amazing mobile apps with JavaScript
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 10,
    color: '#333',
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
});

export default WelcomeScreen;</textarea>
                            </div>
                            <div class="playground-preview" id="playground-preview" style="display: none;">
                                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; background: #f0f0f0;">
                                    <h2 style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #333;">Welcome to React Native!</h2>
                                    <p style="font-size: 16px; color: #666;">Build amazing mobile apps with JavaScript</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <h2><i class="fas fa-project-diagram"></i> React Native Architecture</h2>
                    <p>React Native uses a bridge to communicate between JavaScript and native code:</p>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Architecture Overview</span>
                        </div>
                        <pre><code class="language-javascript">// JavaScript Thread
// - Your React components and business logic
// - Handles UI updates and state management

// Bridge
// - Serializes data between JS and Native
// - Asynchronous and batched for performance

// Native Thread
// - UI rendering using platform components
// - Access to device APIs

// Shadow Thread
// - Layout calculations
// - Determines component positions and sizes</code></pre>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Quick Quiz</h3>
                        <p class="quiz-question">What makes React Native different from other hybrid frameworks?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                It renders using native platform components instead of WebViews
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                It only works on iOS devices
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                It requires knowledge of Swift and Kotlin
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                It can only be used for simple applications
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="warning-box">
                        <h4><i class="fas fa-exclamation-triangle"></i> Important Note</h4>
                        <p>While React Native handles most cross-platform concerns, you'll still need platform-specific code for certain features. This is a strength, not a limitation – it gives you full control when needed.</p>
                    </div>

                    <h2><i class="fas fa-road"></i> Learning Path</h2>
                    <p>Throughout this course, you'll master:</p>
                    <ul>
                        <li>Building user interfaces with React Native components</li>
                        <li>Managing application state and data flow</li>
                        <li>Implementing smooth animations and gestures</li>
                        <li>Integrating with device features and APIs</li>
                        <li>Testing and debugging your applications</li>
                        <li>Publishing to app stores</li>
                    </ul>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-code"></i> Mini Project: Hello World</h3>
                        <p class="project-description">Let's create your first React Native component! Complete these tasks:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="task1">
                                <label for="task1">Create a new component called HelloWorld</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="task2">
                                <label for="task2">Add your name to the welcome message</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="task3">
                                <label for="task3">Style the text with custom colors</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="task4">
                                <label for="task4">Add an emoji to make it fun! 🎉</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'setup': {
        title: 'Environment Setup',
        content: `
                    <h1><i class="fas fa-laptop-code"></i> Environment Setup</h1>
                    
                    <p>Setting up your React Native development environment correctly is crucial for a smooth development experience. This guide will walk you through the complete setup process for both macOS and Windows.</p>

                    <h2><i class="fas fa-tools"></i> Prerequisites</h2>
                    
                    <div class="tip-box">
                        <h4><i class="fas fa-info-circle"></i> System Requirements</h4>
                        <p>• macOS 10.14 (Mojave) or newer for iOS development<br>
                        • Windows 10 or newer for Android development<br>
                        • 8GB RAM minimum (16GB recommended)<br>
                        • 10GB free disk space</p>
                    </div>

                    <h2><i class="fab fa-node-js"></i> Step 1: Install Node.js</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">bash</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-bash"># Install Node.js v18 or newer
# macOS (using Homebrew)
brew install node

# Windows (using Chocolatey)
choco install nodejs

# Verify installation
node --version  # Should show v18.x.x or higher
npm --version   # Should show 8.x.x or higher</code></pre>
                    </div>

                    <h2><i class="fab fa-apple"></i> macOS Setup (for iOS Development)</h2>
                    
                    <h3>Install Xcode</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">bash</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-bash"># Install Xcode from App Store (this takes a while!)
# Then install Xcode Command Line Tools
xcode-select --install

# Accept Xcode license
sudo xcodebuild -license accept</code></pre>
                    </div>

                    <h3>Install CocoaPods</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">bash</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-bash"># Install CocoaPods
sudo gem install cocoapods

# Or using Homebrew
brew install cocoapods</code></pre>
                    </div>

                    <h2><i class="fab fa-android"></i> Android Setup (for both macOS and Windows)</h2>
                    
                    <h3>Install Java Development Kit (JDK)</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">bash</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-bash"># macOS
brew install --cask zulu11

# Windows
choco install ojdkbuild

# Verify installation
java -version</code></pre>
                    </div>

                    <h3>Install Android Studio</h3>
                    <p>Download and install Android Studio from the official website. During installation:</p>
                    <ol>
                        <li>Choose "Custom" installation</li>
                        <li>Select these components:
                            <ul>
                                <li>Android SDK</li>
                                <li>Android SDK Platform</li>
                                <li>Android Virtual Device</li>
                            </ul>
                        </li>
                        <li>Install Android SDK Platform 33 (for React Native 0.80)</li>
                    </ol>

                    <h3>Configure Environment Variables</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">bash</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-bash"># macOS/Linux - Add to ~/.zshrc or ~/.bash_profile
export ANDROID_HOME=$HOME/Library/Android/sdk
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/platform-tools
export PATH=$PATH:$ANDROID_HOME/tools
export PATH=$PATH:$ANDROID_HOME/tools/bin

# Windows - Add to System Environment Variables
ANDROID_HOME = C:\Users\[username]\AppData\Local\Android\Sdk
# Add to PATH:
%ANDROID_HOME%\platform-tools
%ANDROID_HOME%\emulator
%ANDROID_HOME%\tools
%ANDROID_HOME%\tools\bin</code></pre>
                    </div>

                    <h2><i class="fas fa-terminal"></i> Install React Native CLI</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">bash</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-bash"># Install React Native CLI globally
npm install -g react-native-cli

# For React Native 0.80, also install the latest CLI tools
npx react-native@latest init --version 0.80.0</code></pre>
                    </div>

                    <h2><i class="fas fa-rocket"></i> Create Your First Project</h2>
                    
                    <div class="playground">
                        <div class="playground-header">
                            <h3><i class="fas fa-code"></i> Project Creation</h3>
                            <div class="playground-tabs">
                                <button class="playground-tab active" onclick="switchPlaygroundTab(this, 'typescript')">TypeScript</button>
                                <button class="playground-tab" onclick="switchPlaygroundTab(this, 'javascript')">JavaScript</button>
                            </div>
                        </div>
                        <div class="playground-content">
                            <div class="playground-editor" id="playground-typescript">
                                <textarea class="editor-textarea">
# Create a new React Native project with TypeScript
npx react-native@latest init MyAwesomeApp --template react-native-template-typescript

# Navigate to project
cd MyAwesomeApp

# Install iOS dependencies (macOS only)
cd ios && pod install && cd ..

# Run on iOS (macOS only)
npx react-native run-ios

# Run on Android
npx react-native run-android</textarea>
                            </div>
                            <div class="playground-editor" id="playground-javascript" style="display: none;">
                                <textarea class="editor-textarea">
# Create a new React Native project with JavaScript
npx react-native@latest init MyAwesomeApp

# Navigate to project
cd MyAwesomeApp

# Install iOS dependencies (macOS only)
cd ios && pod install && cd ..

# Run on iOS (macOS only)
npx react-native run-ios

# Run on Android
npx react-native run-android</textarea>
                            </div>
                        </div>
                    </div>

                    <h2><i class="fas fa-mobile-alt"></i> Setting Up Emulators</h2>
                    
                    <h3>iOS Simulator (macOS only)</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">bash</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-bash"># Open Xcode
open -a Xcode

# Go to Xcode > Preferences > Components
# Download iOS simulators you need

# List available simulators
xcrun simctl list devices

# Open a specific simulator
open -a Simulator --args -CurrentDeviceUDID [DEVICE_ID]</code></pre>
                    </div>

                    <h3>Android Emulator</h3>
                    <ol>
                        <li>Open Android Studio</li>
                        <li>Click "AVD Manager" (Android Virtual Device)</li>
                        <li>Create a new virtual device</li>
                        <li>Choose a device definition (e.g., Pixel 5)</li>
                        <li>Select a system image (API Level 33 for React Native 0.80)</li>
                        <li>Finish and launch the emulator</li>
                    </ol>

                    <div class="warning-box">
                        <h4><i class="fas fa-exclamation-triangle"></i> Common Issues & Solutions</h4>
                        <p><strong>Metro bundler issues:</strong> Clear cache with <code>npx react-native start --reset-cache</code><br>
                        <strong>Build failures:</strong> Clean and rebuild with <code>cd android && ./gradlew clean</code><br>
                        <strong>Pod install failures:</strong> Update CocoaPods with <code>sudo gem update cocoapods</code></p>
                    </div>

                    <h2><i class="fas fa-vial"></i> Verify Your Setup</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">bash</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-bash"># Run React Native doctor to check your setup
npx react-native doctor

# This will check:
# ✓ Node.js
# ✓ npm/yarn
# ✓ Android Studio
# ✓ Android SDK
# ✓ Xcode (macOS)
# ✓ CocoaPods (macOS)</code></pre>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Setup Check</h3>
                        <p class="quiz-question">Which command creates a new React Native project with TypeScript support?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                npm create react-native-app MyApp
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                npx react-native@latest init MyApp --template react-native-template-typescript
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                react-native new MyApp --typescript
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                npm init react-native MyApp
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <h2><i class="fas fa-wrench"></i> Recommended VS Code Extensions</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">json</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-json">{
  "recommendations": [
    "dsznajder.es7-react-js-snippets",
    "dbaeumer.vscode-eslint",
    "esbenp.prettier-vscode",
    "flowtype.flow-for-vscode",
    "msjsdiag.vscode-react-native",
    "ms-vscode.vscode-typescript-tslint-plugin",
    "styled-components.vscode-styled-components",
    "burkeholland.simple-react-snippets"
  ]
}</code></pre>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-tasks"></i> Setup Checklist</h3>
                        <p class="project-description">Complete your development environment setup:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="setup1">
                                <label for="setup1">Install Node.js v18 or higher</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="setup2">
                                <label for="setup2">Set up iOS development tools (Xcode, CocoaPods)</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="setup3">
                                <label for="setup3">Set up Android development tools (Android Studio, SDK)</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="setup4">
                                <label for="setup4">Create and run your first React Native project</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="setup5">
                                <label for="setup5">Install recommended VS Code extensions</label>
                            </div>
                        </div>
                    </div>

                    <div class="tip-box">
                        <h4><i class="fas fa-star"></i> Pro Tip</h4>
                        <p>Use <code>npx react-native start</code> in one terminal and <code>npx react-native run-ios/android</code> in another for better control over the Metro bundler.</p>
                    </div>
                `
      },
      'first-app': {
        title: 'Your First App',
        content: `
                    <h1><i class="fas fa-mobile-alt"></i> Your First React Native App</h1>
                    
                    <p>Let's build your first React Native app from scratch! We'll create a simple but complete app that demonstrates core concepts and best practices.</p>

                    <h2><i class="fas fa-folder-open"></i> Project Structure Overview</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Project Structure</span>
                        </div>
                        <pre><code class="language-bash">MyFirstApp/
├── android/          # Android-specific code
├── ios/              # iOS-specific code
├── src/              # Your app source code
│   ├── components/   # Reusable components
│   ├── screens/      # Screen components
│   └── utils/        # Helper functions
├── App.tsx           # Main app component
├── index.js          # Entry point
├── package.json      # Dependencies
└── tsconfig.json     # TypeScript config</code></pre>
                    </div>

                    <h2><i class="fas fa-code"></i> Building a Todo App</h2>
                    <p>We'll build a complete Todo app with the following features:</p>
                    <ul>
                        <li>Add new todos</li>
                        <li>Mark todos as complete</li>
                        <li>Delete todos</li>
                        <li>Filter by status</li>
                        <li>Persist data locally</li>
                    </ul>

                    <h3>Step 1: Main App Component</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">App.tsx</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                                <button class="code-btn" onclick="runInPlayground(this)">Try It</button>
                            </div>
                        </div>
                        <pre><code class="language-typescript">import React, { useState, useEffect } from 'react';
import {
  SafeAreaView,
  StyleSheet,
  Text,
  View,
  TextInput,
  TouchableOpacity,
  FlatList,
  KeyboardAvoidingView,
  Platform,
  Alert,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

interface Todo {
  id: string;
  text: string;
  completed: boolean;
  createdAt: Date;
}

const App = () => {
  const [todos, setTodos] = useState<Todo[]>([]);
  const [inputText, setInputText] = useState('');
  const [filter, setFilter] = useState<'all' | 'active' | 'completed'>('all');

  // Load todos from storage on app start
  useEffect(() => {
    loadTodos();
  }, []);

  // Save todos whenever they change
  useEffect(() => {
    saveTodos();
  }, [todos]);

  const loadTodos = async () => {
    try {
      const storedTodos = await AsyncStorage.getItem('todos');
      if (storedTodos) {
        setTodos(JSON.parse(storedTodos));
      }
    } catch (error) {
      console.error('Error loading todos:', error);
    }
  };

  const saveTodos = async () => {
    try {
      await AsyncStorage.setItem('todos', JSON.stringify(todos));
    } catch (error) {
      console.error('Error saving todos:', error);
    }
  };

  const addTodo = () => {
    if (inputText.trim()) {
      const newTodo: Todo = {
        id: Date.now().toString(),
        text: inputText.trim(),
        completed: false,
        createdAt: new Date(),
      };
      setTodos([newTodo, ...todos]);
      setInputText('');
    }
  };

  const toggleTodo = (id: string) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const deleteTodo = (id: string) => {
    Alert.alert(
      'Delete Todo',
      'Are you sure you want to delete this todo?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: () => setTodos(todos.filter(todo => todo.id !== id)),
        },
      ],
    );
  };

  const getFilteredTodos = () => {
    switch (filter) {
      case 'active':
        return todos.filter(todo => !todo.completed);
      case 'completed':
        return todos.filter(todo => todo.completed);
      default:
        return todos;
    }
  };

  const renderTodo = ({ item }: { item: Todo }) => (
    <TouchableOpacity
      style={styles.todoItem}
      onPress={() => toggleTodo(item.id)}
      onLongPress={() => deleteTodo(item.id)}
    >
      <View style={styles.todoContent}>
        <View style={[styles.checkbox, item.completed && styles.checkboxCompleted]}>
          {item.completed && <Text style={styles.checkmark}>✓</Text>}
        </View>
        <Text style={[styles.todoText, item.completed && styles.todoTextCompleted]}>
          {item.text}
        </Text>
      </View>
    </TouchableOpacity>
  );

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.container}
      >
        <View style={styles.header}>
          <Text style={styles.title}>My Todos</Text>
          <Text style={styles.subtitle}>
            {todos.filter(t => !t.completed).length} active tasks
          </Text>
        </View>

        <View style={styles.inputContainer}>
          <TextInput
            style={styles.input}
            placeholder="What needs to be done?"
            placeholderTextColor="#999"
            value={inputText}
            onChangeText={setInputText}
            onSubmitEditing={addTodo}
            returnKeyType="done"
          />
          <TouchableOpacity style={styles.addButton} onPress={addTodo}>
            <Text style={styles.addButtonText}>+</Text>
          </TouchableOpacity>
        </View>

        <View style={styles.filters}>
          {(['all', 'active', 'completed'] as const).map(filterType => (
            <TouchableOpacity
              key={filterType}
              style={[styles.filterButton, filter === filterType && styles.filterButtonActive]}
              onPress={() => setFilter(filterType)}
            >
              <Text style={[styles.filterText, filter === filterType && styles.filterTextActive]}>
                {filterType.charAt(0).toUpperCase() + filterType.slice(1)}
              </Text>
            </TouchableOpacity>
          ))}
        </View>

        <FlatList
          data={getFilteredTodos()}
          renderItem={renderTodo}
          keyExtractor={item => item.id}
          style={styles.list}
          contentContainerStyle={styles.listContent}
          showsVerticalScrollIndicator={false}
        />
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    paddingHorizontal: 20,
    paddingTop: 20,
    paddingBottom: 10,
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#333',
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginTop: 5,
  },
  inputContainer: {
    flexDirection: 'row',
    paddingHorizontal: 20,
    paddingVertical: 10,
  },
  input: {
    flex: 1,
    backgroundColor: 'white',
    paddingHorizontal: 15,
    paddingVertical: 12,
    borderRadius: 10,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  addButton: {
    backgroundColor: '#007AFF',
    width: 50,
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 10,
  },
  addButtonText: {
    color: 'white',
    fontSize: 24,
    fontWeight: 'bold',
  },
  filters: {
    flexDirection: 'row',
    paddingHorizontal: 20,
    paddingVertical: 10,
    gap: 10,
  },
  filterButton: {
    paddingHorizontal: 15,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: 'white',
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  filterButtonActive: {
    backgroundColor: '#007AFF',
    borderColor: '#007AFF',
  },
  filterText: {
    color: '#666',
    fontSize: 14,
  },
  filterTextActive: {
    color: 'white',
  },
  list: {
    flex: 1,
  },
  listContent: {
    paddingHorizontal: 20,
    paddingBottom: 20,
  },
  todoItem: {
    backgroundColor: 'white',
    borderRadius: 10,
    marginBottom: 10,
    padding: 15,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  todoContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  checkbox: {
    width: 24,
    height: 24,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: '#007AFF',
    marginRight: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkboxCompleted: {
    backgroundColor: '#007AFF',
  },
  checkmark: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  todoText: {
    fontSize: 16,
    color: '#333',
    flex: 1,
  },
  todoTextCompleted: {
    textDecorationLine: 'line-through',
    color: '#999',
  },
});

export default App;</code></pre>
                    </div>

                    <div class="playground">
                        <div class="playground-header">
                            <h3><i class="fas fa-play-circle"></i> Live Preview</h3>
                            <button class="code-btn" onclick="refreshPreview()">Refresh</button>
                        </div>
                        <div class="playground-content">
                            <div class="playground-preview" style="display: block; background: #f5f5f5; padding: 20px;">
                                <div style="background: white; border-radius: 10px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                                    <h2 style="font-size: 32px; font-weight: bold; color: #333; margin: 0;">My Todos</h2>
                                    <p style="font-size: 16px; color: #666; margin: 5px 0 20px;">2 active tasks</p>
                                    
                                    <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                                        <input type="text" placeholder="What needs to be done?" style="flex: 1; padding: 12px 15px; border: 1px solid #e0e0e0; border-radius: 10px; font-size: 16px;">
                                        <button style="background: #007AFF; color: white; width: 50px; height: 50px; border-radius: 25px; border: none; font-size: 24px; cursor: pointer;">+</button>
                                    </div>
                                    
                                    <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                                        <button style="padding: 8px 15px; background: #007AFF; color: white; border: none; border-radius: 20px; cursor: pointer;">All</button>
                                        <button style="padding: 8px 15px; background: white; color: #666; border: 1px solid #e0e0e0; border-radius: 20px; cursor: pointer;">Active</button>
                                        <button style="padding: 8px 15px; background: white; color: #666; border: 1px solid #e0e0e0; border-radius: 20px; cursor: pointer;">Completed</button>
                                    </div>
                                    
                                    <div style="display: flex; flex-direction: column; gap: 10px;">
                                        <div style="background: white; border: 1px solid #e0e0e0; border-radius: 10px; padding: 15px; display: flex; align-items: center;">
                                            <div style="width: 24px; height: 24px; border: 2px solid #007AFF; border-radius: 12px; margin-right: 12px;"></div>
                                            <span style="font-size: 16px; color: #333;">Learn React Native basics</span>
                                        </div>
                                        <div style="background: white; border: 1px solid #e0e0e0; border-radius: 10px; padding: 15px; display: flex; align-items: center;">
                                            <div style="width: 24px; height: 24px; background: #007AFF; border: 2px solid #007AFF; border-radius: 12px; margin-right: 12px; display: flex; align-items: center; justify-content: center;">
                                                <span style="color: white; font-weight: bold;">✓</span>
                                            </div>
                                            <span style="font-size: 16px; color: #999; text-decoration: line-through;">Set up development environment</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <h2><i class="fas fa-puzzle-piece"></i> Breaking Down the Code</h2>

                    <h3>1. State Management</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">typescript</span>
                        </div>
                        <pre><code class="language-typescript">// We use multiple state variables to manage our app
const [todos, setTodos] = useState<Todo[]>([]);        // Array of todos
const [inputText, setInputText] = useState('');        // Input field value
const [filter, setFilter] = useState<'all' | 'active' | 'completed'>('all'); // Current filter

// TypeScript interface defines the shape of our data
interface Todo {
  id: string;
  text: string;
  completed: boolean;
  createdAt: Date;
}</code></pre>
                    </div>

                    <h3>2. Data Persistence</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">typescript</span>
                        </div>
                        <pre><code class="language-typescript">// AsyncStorage provides persistent local storage
const saveTodos = async () => {
  try {
    await AsyncStorage.setItem('todos', JSON.stringify(todos));
  } catch (error) {
    console.error('Error saving todos:', error);
  }
};

// Load todos when app starts
useEffect(() => {
  loadTodos();
}, []); // Empty dependency array = run once on mount</code></pre>
                    </div>

                    <h3>3. User Interactions</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">typescript</span>
                        </div>
                        <pre><code class="language-typescript">// Handle different user actions
const addTodo = () => {
  if (inputText.trim()) {
    // Create new todo with unique ID
    const newTodo: Todo = {
      id: Date.now().toString(),
      text: inputText.trim(),
      completed: false,
      createdAt: new Date(),
    };
    // Add to beginning of array
    setTodos([newTodo, ...todos]);
    setInputText(''); // Clear input
  }
};

// Toggle completion status
const toggleTodo = (id: string) => {
  setTodos(todos.map(todo =>
    todo.id === id 
      ? { ...todo, completed: !todo.completed } 
      : todo
  ));
};</code></pre>
                    </div>

                    <h2><i class="fas fa-paint-brush"></i> Styling Best Practices</h2>
                    
                    <div class="tip-box">
                        <h4><i class="fas fa-lightbulb"></i> Style Tips</h4>
                        <p>• Use StyleSheet.create() for better performance<br>
                        • Keep styles close to components<br>
                        • Use consistent spacing and colors<br>
                        • Consider creating a theme file for reusable values</p>
                    </div>

                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">typescript</span>
                        </div>
                        <pre><code class="language-typescript">// Create a theme file for consistency
// theme.ts
export const theme = {
  colors: {
    primary: '#007AFF',
    background: '#f5f5f5',
    text: '#333',
    textSecondary: '#666',
    border: '#e0e0e0',
    white: '#ffffff',
  },
  spacing: {
    xs: 5,
    sm: 10,
    md: 15,
    lg: 20,
    xl: 30,
  },
  borderRadius: {
    sm: 5,
    md: 10,
    lg: 15,
    full: 9999,
  },
};</code></pre>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Understanding Check</h3>
                        <p class="quiz-question">What hook do we use to persist data when the todos array changes?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                useState
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                useEffect with todos dependency
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                useCallback
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                useMemo
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <h2><i class="fas fa-rocket"></i> Enhancements You Can Add</h2>
                    
                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-code"></i> Project: Enhance the Todo App</h3>
                        <p class="project-description">Take your todo app to the next level with these features:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="enhance1">
                                <label for="enhance1">Add due dates to todos</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="enhance2">
                                <label for="enhance2">Implement swipe to delete</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="enhance3">
                                <label for="enhance3">Add categories or tags</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="enhance4">
                                <label for="enhance4">Create a dark mode theme</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="enhance5">
                                <label for="enhance5">Add todo search functionality</label>
                            </div>
                        </div>
                    </div>

                    <h2><i class="fas fa-bug"></i> Common Mistakes to Avoid</h2>
                    
                    <div class="warning-box">
                        <h4><i class="fas fa-exclamation-triangle"></i> Pitfalls</h4>
                        <p>• Don't mutate state directly - always create new objects/arrays<br>
                        • Remember to handle keyboard on both iOS and Android<br>
                        • Test on real devices - simulators don't catch all issues<br>
                        • Don't forget to handle empty states and errors</p>
                    </div>

                    <h2><i class="fas fa-file-code"></i> Next Steps</h2>
                    
                    <p>Now that you've built your first app, you can:</p>
                    <ol>
                        <li>Add more features to make it production-ready</li>
                        <li>Extract components for reusability</li>
                        <li>Implement proper error handling</li>
                        <li>Add unit tests</li>
                        <li>Style it to match your brand</li>
                    </ol>

                    <div class="tip-box">
                        <h4><i class="fas fa-star"></i> Pro Tip</h4>
                        <p>Use React DevTools to debug your component hierarchy and state. Install the standalone version for React Native: <code>npm install -g react-devtools</code></p>
                    </div>
                `
      },
      'project-structure': {
        title: 'Project Structure',
        content: `
                    <h1><i class="fas fa-sitemap"></i> React Native Project Structure</h1>
                    
                    <p>Understanding the project structure is crucial for organizing your code effectively and maintaining a scalable React Native application. Let's explore the anatomy of a React Native project.</p>

                    <h2><i class="fas fa-folder-tree"></i> Standard Project Structure</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Project Directory</span>
                        </div>
                        <pre><code class="language-bash">MyReactNativeApp/
├── android/                 # Android native code
│   ├── app/                # Main Android app module
│   ├── gradle/            # Gradle wrapper files
│   └── build.gradle       # Android build configuration
├── ios/                    # iOS native code
│   ├── MyApp/             # Main iOS app folder
│   ├── MyApp.xcodeproj/   # Xcode project
│   └── Podfile            # CocoaPods dependencies
├── src/                    # Source code (recommended)
│   ├── components/        # Reusable components
│   ├── screens/          # Screen components
│   ├── navigation/       # Navigation configuration
│   ├── services/         # API and external services
│   ├── utils/            # Utility functions
│   ├── assets/           # Images, fonts, etc.
│   ├── store/            # State management
│   └── constants/        # App constants
├── __tests__/             # Test files
├── node_modules/          # Dependencies
├── .gitignore            # Git ignore file
├── .eslintrc.js          # ESLint configuration
├── .prettierrc           # Prettier configuration
├── App.tsx               # Root component
├── app.json              # App configuration
├── babel.config.js       # Babel configuration
├── index.js              # Entry point
├── metro.config.js       # Metro bundler config
├── package.json          # Dependencies and scripts
└── tsconfig.json         # TypeScript configuration</code></pre>
                    </div>

                    <h2><i class="fas fa-folder-open"></i> Key Directories Explained</h2>

                    <h3>1. Platform-Specific Folders</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Platform Folders</span>
                        </div>
                        <pre><code class="language-javascript">// android/ - Contains all Android-specific code
// - Gradle build files
// - Native Android modules
// - Android resources and assets

// ios/ - Contains all iOS-specific code
// - Xcode project files
// - Native iOS modules
// - Info.plist configuration</code></pre>
                    </div>

                    <h3>2. Source Code Organization</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">src/components/Button.tsx</span>
                        </div>
                        <pre><code class="language-typescript">// Reusable component example
import React from 'react';
import { TouchableOpacity, Text, StyleSheet, ViewStyle, TextStyle } from 'react-native';

interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary';
  style?: ViewStyle;
  textStyle?: TextStyle;
  disabled?: boolean;
}

export const Button: React.FC<ButtonProps> = ({
  title,
  onPress,
  variant = 'primary',
  style,
  textStyle,
  disabled = false,
}) => {
  return (
    <TouchableOpacity
      style={[
        styles.button,
        styles[variant],
        disabled && styles.disabled,
        style,
      ]}
      onPress={onPress}
      disabled={disabled}
      activeOpacity={0.7}
    >
      <Text style={[styles.text, styles[\`\${variant}Text\`], textStyle]}>
        {title}
      </Text>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  button: {
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  primary: {
    backgroundColor: '#007AFF',
  },
  secondary: {
    backgroundColor: 'transparent',
    borderWidth: 1,
    borderColor: '#007AFF',
  },
  disabled: {
    opacity: 0.5,
  },
  text: {
    fontSize: 16,
    fontWeight: '600',
  },
  primaryText: {
    color: 'white',
  },
  secondaryText: {
    color: '#007AFF',
  },
});</code></pre>
                    </div>

                    <h3>3. Screen Components</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">src/screens/HomeScreen.tsx</span>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import { View, Text, StyleSheet, FlatList } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { Button } from '../components/Button';

interface HomeScreenProps {
  // Props from navigation
}

export const HomeScreen: React.FC<HomeScreenProps> = () => {
  const navigation = useNavigation();

  const features = [
    { id: '1', title: 'Profile', screen: 'Profile' },
    { id: '2', title: 'Settings', screen: 'Settings' },
    { id: '3', title: 'About', screen: 'About' },
  ];

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Welcome to MyApp</Text>
      
      <FlatList
        data={features}
        keyExtractor={item => item.id}
        renderItem={({ item }) => (
          <Button
            title={item.title}
            onPress={() => navigation.navigate(item.screen)}
            style={styles.button}
          />
        )}
        contentContainerStyle={styles.list}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginVertical: 20,
  },
  list: {
    paddingHorizontal: 20,
  },
  button: {
    marginBottom: 10,
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-cog"></i> Configuration Files</h2>

                    <h3>app.json</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">json</span>
                        </div>
                        <pre><code class="language-json">{
  "name": "MyReactNativeApp",
  "displayName": "My React Native App",
  "expo": {
    "name": "MyReactNativeApp",
    "slug": "my-react-native-app",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    }
  }
}</code></pre>
                    </div>

                    <h3>metro.config.js</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">javascript</span>
                        </div>
                        <pre><code class="language-javascript">const { getDefaultConfig } = require('metro-config');

module.exports = (async () => {
  const {
    resolver: { sourceExts, assetExts }
  } = await getDefaultConfig();
  
  return {
    transformer: {
      babelTransformerPath: require.resolve('react-native-svg-transformer'),
      getTransformOptions: async () => ({
        transform: {
          experimentalImportSupport: false,
          inlineRequires: true,
        },
      }),
    },
    resolver: {
      assetExts: assetExts.filter(ext => ext !== 'svg'),
      sourceExts: [...sourceExts, 'svg'],
    },
  };
})();</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4><i class="fas fa-lightbulb"></i> Best Practices</h4>
                        <p>• Keep components small and focused<br>
                        • Use absolute imports with babel-plugin-module-resolver<br>
                        • Separate business logic from UI components<br>
                        • Group related files together<br>
                        • Use index.ts files for cleaner imports</p>
                    </div>

                    <h2><i class="fas fa-file-import"></i> Import Organization</h2>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">typescript</span>
                        </div>
                        <pre><code class="language-typescript">// babel.config.js - Configure absolute imports
module.exports = {
  presets: ['module:metro-react-native-babel-preset'],
  plugins: [
    [
      'module-resolver',
      {
        root: ['./src'],
        extensions: ['.ios.js', '.android.js', '.js', '.ts', '.tsx', '.json'],
        alias: {
          '@components': './src/components',
          '@screens': './src/screens',
          '@utils': './src/utils',
          '@assets': './src/assets',
          '@services': './src/services',
          '@navigation': './src/navigation',
          '@store': './src/store',
          '@constants': './src/constants',
        },
      },
    ],
  ],
};

// Now you can import like this:
import { Button } from '@components/Button';
import { HomeScreen } from '@screens/HomeScreen';
import { api } from '@services/api';</code></pre>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Quick Check</h3>
                        <p class="quiz-question">Which folder contains platform-specific code for iOS?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                src/ios
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                ios/
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                platforms/ios
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                native/ios
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-folder-plus"></i> Project: Organize Your App</h3>
                        <p class="project-description">Create a well-structured React Native project:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="struct1">
                                <label for="struct1">Create the src/ directory structure</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="struct2">
                                <label for="struct2">Set up absolute imports with babel-plugin-module-resolver</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="struct3">
                                <label for="struct3">Create a reusable Button component</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="struct4">
                                <label for="struct4">Organize screens into separate files</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="struct5">
                                <label for="struct5">Set up a constants file for app-wide values</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'dev-tools': {
        title: 'Development Tools',
        content: `
                    <h1><i class="fas fa-tools"></i> React Native Development Tools</h1>
                    
                    <p>Master the essential tools that will supercharge your React Native development workflow. From debugging to performance monitoring, these tools are indispensable for professional development.</p>

                    <h2><i class="fas fa-bug"></i> React Native Debugger</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">bash</span>
                        </div>
                        <pre><code class="language-bash"># Install React Native Debugger (standalone app)
# macOS
brew install --cask react-native-debugger

# Windows/Linux - Download from GitHub releases
# https://github.com/jhen0409/react-native-debugger/releases

# Launch the debugger
open "rndebugger://set-debugger-loc?host=localhost&port=8081"</code></pre>
                    </div>

                    <h3>Features of React Native Debugger</h3>
                    <ul>
                        <li>Chrome DevTools integration</li>
                        <li>React DevTools integration</li>
                        <li>Redux DevTools integration</li>
                        <li>Network request inspection</li>
                        <li>AsyncStorage management</li>
                    </ul>

                    <h2><i class="fas fa-mobile-alt"></i> Flipper</h2>
                    <p>Flipper is Facebook's powerful debugging platform for mobile apps.</p>

                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Setup Flipper</span>
                        </div>
                        <pre><code class="language-javascript">// No additional setup needed for React Native 0.62+
// Flipper is integrated by default!

// To use Flipper plugins in your code:
import { logger } from 'react-native-flipper';

// Log messages to Flipper
logger.log('Debug message');
logger.warn('Warning message');
logger.error('Error message');

// Track performance
logger.track('api-call', {
  duration: 1234,
  endpoint: '/users',
  status: 200
});</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4><i class="fas fa-rocket"></i> Flipper Plugins</h4>
                        <p>• <strong>Layout Inspector:</strong> Inspect and modify UI in real-time<br>
                        • <strong>Network Plugin:</strong> Monitor all network requests<br>
                        • <strong>Databases:</strong> Browse SQLite/Realm databases<br>
                        • <strong>React DevTools:</strong> Component tree inspection<br>
                        • <strong>Logs:</strong> View console logs with filtering</p>
                    </div>

                    <h2><i class="fas fa-terminal"></i> Metro Bundler</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">bash</span>
                        </div>
                        <pre><code class="language-bash"># Start Metro bundler
npx react-native start

# Start with cache reset
npx react-native start --reset-cache

# Change port
npx react-native start --port 8088

# Enable inspector
npx react-native start --inspector</code></pre>
                    </div>

                    <h3>Metro Configuration</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">metro.config.js</span>
                        </div>
                        <pre><code class="language-javascript">module.exports = {
  transformer: {
    minifierConfig: {
      keep_fnames: true,
      mangle: {
        keep_fnames: true,
      },
    },
  },
  resolver: {
    sourceExts: ['jsx', 'js', 'ts', 'tsx', 'cjs', 'mjs'],
    resolverMainFields: ['react-native', 'browser', 'main'],
  },
  server: {
    port: 8081,
    enhanceMiddleware: (middleware) => {
      return (req, res, next) => {
        // Custom middleware logic
        return middleware(req, res, next);
      };
    },
  },
};</code></pre>
                    </div>

                    <h2><i class="fas fa-code"></i> VS Code Extensions</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Essential Extensions</span>
                        </div>
                        <pre><code class="language-json">{
  "recommendations": [
    // React Native specific
    "msjsdiag.vscode-react-native",
    "dsznajder.es7-react-js-snippets",
    
    // Code quality
    "dbaeumer.vscode-eslint",
    "esbenp.prettier-vscode",
    "streetsidesoftware.code-spell-checker",
    
    // Productivity
    "eamodio.gitlens",
    "usernamehw.errorlens",
    "wix.vscode-import-cost",
    
    // Styling
    "styled-components.vscode-styled-components",
    "bradlc.vscode-tailwindcss",
    
    // Testing
    "orta.vscode-jest",
    "firsttris.vscode-jest-runner"
  ]
}</code></pre>
                    </div>

                    <h3>VS Code Settings</h3>
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">.vscode/settings.json</span>
                        </div>
                        <pre><code class="language-json">{
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "eslint.validate": [
    "javascript",
    "javascriptreact",
    "typescript",
    "typescriptreact"
  ],
  "typescript.tsdk": "node_modules/typescript/lib",
  "react-native-tools.showUserTips": false,
  "react-native-tools.projectRoot": "./",
  "react-native-tools.packager.port": 8081
}</code></pre>
                    </div>

                    <h2><i class="fas fa-chart-line"></i> Performance Monitoring</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Performance.tsx</span>
                        </div>
                        <pre><code class="language-typescript">import React, { useEffect } from 'react';
import { PerformanceObserver } from 'react-native-performance';

// Enable performance monitoring
export const PerformanceMonitor: React.FC = ({ children }) => {
  useEffect(() => {
    // Monitor JS frame rate
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry) => {
        console.log(\`\${entry.name}: \${entry.duration}ms\`);
      });
    });

    observer.observe({ entryTypes: ['measure'] });

    return () => observer.disconnect();
  }, []);

  return <>{children}</>;
};

// Measure component render time
export const measureRender = (componentName: string) => {
  return (WrappedComponent: React.ComponentType<any>) => {
    return (props: any) => {
      useEffect(() => {
        performance.mark(\`\${componentName}-mount\`);
        
        return () => {
          performance.mark(\`\${componentName}-unmount\`);
          performance.measure(
            componentName,
            \`\${componentName}-mount\`,
            \`\${componentName}-unmount\`
          );
        };
      }, []);

      return <WrappedComponent {...props} />;
    };
  };
};</code></pre>
                    </div>

                    <h2><i class="fas fa-network-wired"></i> Network Debugging</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">NetworkLogger.ts</span>
                        </div>
                        <pre><code class="language-typescript">// Custom network interceptor
export const setupNetworkLogging = () => {
  const originalFetch = global.fetch;
  
  global.fetch = async (...args) => {
    const [url, config] = args;
    const method = config?.method || 'GET';
    
    console.log(\`🌐 \${method} \${url}\`);
    const startTime = Date.now();
    
    try {
      const response = await originalFetch(...args);
      const duration = Date.now() - startTime;
      
      console.log(\`✅ \${method} \${url} - \${response.status} (\${duration}ms)\`);
      
      return response;
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(\`❌ \${method} \${url} - Failed (\${duration}ms)\`, error);
      throw error;
    }
  };
};

// Use in App.tsx
if (__DEV__) {
  setupNetworkLogging();
}</code></pre>
                    </div>

                    <h2><i class="fas fa-memory"></i> Memory Profiling</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">MemoryMonitor.tsx</span>
                        </div>
                        <pre><code class="language-typescript">import { useEffect, useRef } from 'react';
import { DeviceEventEmitter } from 'react-native';

export const useMemoryWarning = () => {
  const memoryWarningCount = useRef(0);

  useEffect(() => {
    const subscription = DeviceEventEmitter.addListener(
      'memoryWarning',
      () => {
        memoryWarningCount.current++;
        console.warn(\`Memory warning #\${memoryWarningCount.current}\`);
        
        // Take action to free memory
        // Clear caches, reduce image quality, etc.
      }
    );

    return () => subscription.remove();
  }, []);
};

// Track component memory usage
export const trackMemoryUsage = (componentName: string) => {
  if (__DEV__) {
    console.log(\`\${componentName} mounted - Memory: \${performance.memory?.usedJSHeapSize}\`);
  }
};</code></pre>
                    </div>

                    <div class="warning-box">
                        <h4><i class="fas fa-exclamation-triangle"></i> Debugging Tips</h4>
                        <p>• Always remove console.log statements before production<br>
                        • Use conditional debugging with __DEV__ flag<br>
                        • Be careful with breakpoints in async code<br>
                        • Test on real devices, not just simulators</p>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Tool Knowledge</h3>
                        <p class="quiz-question">Which tool provides the most comprehensive debugging experience for React Native?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Chrome DevTools
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                Flipper
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Console.log
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                VS Code Debugger
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-wrench"></i> Project: Set Up Dev Environment</h3>
                        <p class="project-description">Configure your ultimate React Native development setup:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="tools1">
                                <label for="tools1">Install and configure Flipper</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="tools2">
                                <label for="tools2">Set up VS Code with recommended extensions</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="tools3">
                                <label for="tools3">Implement network logging for debugging</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="tools4">
                                <label for="tools4">Create custom performance monitoring</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="tools5">
                                <label for="tools5">Configure React Native Debugger</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'view-text': {
        title: 'View and Text',
        content: `
                    <h1><i class="fas fa-square"></i> View and Text Components</h1>
                    
                    <p>View and Text are the most fundamental components in React Native. Every UI you build will use these as building blocks. Let's master them!</p>

                    <h2><i class="fas fa-layer-group"></i> The View Component</h2>
                    <p>View is like a div in web development - it's a container that supports layout with flexbox, style, touch handling, and accessibility controls.</p>

                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Basic View Usage</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import { View, StyleSheet } from 'react-native';

const ViewExample = () => {
  return (
    <View style={styles.container}>
      <View style={styles.box1} />
      <View style={styles.box2}>
        <View style={styles.innerBox} />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#f0f0f0',
  },
  box1: {
    width: 100,
    height: 100,
    backgroundColor: '#007AFF',
    marginBottom: 20,
    borderRadius: 10,
    // Shadow for iOS
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    // Shadow for Android
    elevation: 5,
  },
  box2: {
    flex: 1,
    backgroundColor: '#34C759',
    padding: 20,
    borderRadius: 10,
  },
  innerBox: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
  },
});</code></pre>
                    </div>

                    <h3>View Properties</h3>
                    <div class="tip-box">
                        <h4><i class="fas fa-info-circle"></i> Common View Props</h4>
                        <p>• <strong>style:</strong> Apply styles to the view<br>
                        • <strong>onLayout:</strong> Called when view layout changes<br>
                        • <strong>pointerEvents:</strong> Controls touch event handling<br>
                        • <strong>accessible:</strong> Marks view as accessible<br>
                        • <strong>testID:</strong> Used for testing</p>
                    </div>

                    <h2><i class="fas fa-font"></i> The Text Component</h2>
                    <p>Text displays, styles, and nests strings of text and even handles touch events.</p>

                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Text Examples</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const TextExample = () => {
  return (
    <View style={styles.container}>
      {/* Basic Text */}
      <Text style={styles.title}>Welcome to React Native!</Text>
      
      {/* Nested Text with different styles */}
      <Text style={styles.paragraph}>
        This is a <Text style={styles.bold}>bold</Text> word and 
        this is <Text style={styles.italic}>italic</Text>.
      </Text>
      
      {/* Multiline Text */}
      <Text style={styles.multiline} numberOfLines={3}>
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
        Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. 
        Ut enim ad minim veniam, quis nostrud exercitation ullamco.
      </Text>
      
      {/* Selectable Text */}
      <Text style={styles.selectable} selectable>
        This text can be selected and copied!
      </Text>
      
      {/* Clickable Text */}
      <Text 
        style={styles.link}
        onPress={() => console.log('Text pressed!')}
      >
        Click me!
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 10,
    color: '#333',
  },
  paragraph: {
    fontSize: 16,
    lineHeight: 24,
    marginBottom: 15,
    color: '#666',
  },
  bold: {
    fontWeight: 'bold',
    color: '#000',
  },
  italic: {
    fontStyle: 'italic',
  },
  multiline: {
    fontSize: 14,
    lineHeight: 20,
    marginBottom: 15,
    color: '#666',
  },
  selectable: {
    fontSize: 16,
    padding: 10,
    backgroundColor: '#f0f0f0',
    borderRadius: 5,
    marginBottom: 15,
  },
  link: {
    fontSize: 16,
    color: '#007AFF',
    textDecorationLine: 'underline',
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-text-height"></i> Text Styling Properties</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Advanced Text Styling</span>
                        </div>
                        <pre><code class="language-typescript">const styles = StyleSheet.create({
  customText: {
    // Font properties
    fontFamily: 'System',
    fontSize: 18,
    fontWeight: '600', // '100' to '900', 'bold', 'normal'
    fontStyle: 'normal', // 'normal', 'italic'
    
    // Text alignment
    textAlign: 'center', // 'left', 'right', 'center', 'justify'
    textAlignVertical: 'center', // Android only
    
    // Decoration
    textDecorationLine: 'underline', // 'none', 'underline', 'line-through', 'underline line-through'
    textDecorationStyle: 'solid', // 'solid', 'double', 'dotted', 'dashed'
    textDecorationColor: '#ff0000',
    
    // Transform
    textTransform: 'uppercase', // 'none', 'uppercase', 'lowercase', 'capitalize'
    
    // Spacing
    letterSpacing: 2,
    lineHeight: 24,
    
    // Shadow (iOS only)
    textShadowColor: '#000',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 3,
  },
});</code></pre>
                    </div>

                    <div class="playground">
                        <div class="playground-header">
                            <h3><i class="fas fa-play-circle"></i> Interactive Example</h3>
                            <div class="playground-tabs">
                                <button class="playground-tab active" onclick="switchPlaygroundTab(this, 'code')">Code</button>
                                <button class="playground-tab" onclick="switchPlaygroundTab(this, 'preview')">Preview</button>
                            </div>
                        </div>
                        <div class="playground-content">
                            <div class="playground-editor" id="playground-code">
                                <textarea class="editor-textarea">
import React, { useState } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';

const InteractiveViewText = () => {
  const [count, setCount] = useState(0);
  const [bgColor, setBgColor] = useState('#007AFF');

  const colors = ['#007AFF', '#34C759', '#FF3B30', '#FF9500', '#AF52DE'];

  return (
    <View style={[styles.container, { backgroundColor: bgColor + '20' }]}>
      <Text style={styles.title}>
        Interactive View & Text Demo
      </Text>
      
      <View style={[styles.counterBox, { backgroundColor: bgColor }]}>
        <Text style={styles.counterText}>{count}</Text>
      </View>
      
      <TouchableOpacity 
        style={styles.button}
        onPress={() => setCount(count + 1)}
      >
        <Text style={styles.buttonText}>Increment Counter</Text>
      </TouchableOpacity>
      
      <View style={styles.colorContainer}>
        {colors.map((color) => (
          <TouchableOpacity
            key={color}
            style={[styles.colorBox, { backgroundColor: color }]}
            onPress={() => setBgColor(color)}
          />
        ))}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  counterBox: {
    width: 100,
    height: 100,
    borderRadius: 50,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
  },
  counterText: {
    fontSize: 36,
    fontWeight: 'bold',
    color: 'white',
  },
  button: {
    backgroundColor: '#333',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 5,
    marginBottom: 20,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
  },
  colorContainer: {
    flexDirection: 'row',
    gap: 10,
  },
  colorBox: {
    width: 40,
    height: 40,
    borderRadius: 20,
  },
});</textarea>
                            </div>
                            <div class="playground-preview" id="playground-preview" style="display: none;">
                                <div style="flex: 1; padding: 20px; background: rgba(0, 122, 255, 0.1); display: flex; flex-direction: column; align-items: center; justify-content: center;">
                                    <h2 style="font-size: 20px; font-weight: bold; margin-bottom: 20px;">Interactive View & Text Demo</h2>
                                    <div style="width: 100px; height: 100px; background: #007AFF; border-radius: 50px; display: flex; align-items: center; justify-content: center; margin-bottom: 20px;">
                                        <span style="font-size: 36px; font-weight: bold; color: white;">0</span>
                                    </div>
                                    <button style="background: #333; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin-bottom: 20px; cursor: pointer;">Increment Counter</button>
                                    <div style="display: flex; gap: 10px;">
                                        <div style="width: 40px; height: 40px; background: #007AFF; border-radius: 20px; cursor: pointer;"></div>
                                        <div style="width: 40px; height: 40px; background: #34C759; border-radius: 20px; cursor: pointer;"></div>
                                        <div style="width: 40px; height: 40px; background: #FF3B30; border-radius: 20px; cursor: pointer;"></div>
                                        <div style="width: 40px; height: 40px; background: #FF9500; border-radius: 20px; cursor: pointer;"></div>
                                        <div style="width: 40px; height: 40px; background: #AF52DE; border-radius: 20px; cursor: pointer;"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <h2><i class="fas fa-universal-access"></i> Accessibility</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Accessible Components</span>
                        </div>
                        <pre><code class="language-typescript">const AccessibleExample = () => {
  return (
    <View accessible={true} accessibilityRole="button">
      <Text 
        accessible={true}
        accessibilityLabel="Welcome message"
        accessibilityHint="This is the main title of the app"
        accessibilityRole="header"
      >
        Welcome to Our App
      </Text>
      
      <TouchableOpacity
        accessible={true}
        accessibilityLabel="Submit button"
        accessibilityHint="Double tap to submit the form"
        accessibilityRole="button"
        accessibilityState={{ disabled: false }}
      >
        <Text>Submit</Text>
      </TouchableOpacity>
    </View>
  );
};</code></pre>
                    </div>

                    <div class="warning-box">
                        <h4><i class="fas fa-exclamation-triangle"></i> Common Pitfalls</h4>
                        <p>• Text must be wrapped in a Text component - you can't put raw text in View<br>
                        • View doesn't support text-specific styles like fontSize<br>
                        • On Android, Text doesn't inherit styles from parent Text components<br>
                        • Be careful with text shadows on Android - they're not supported</p>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Quick Check</h3>
                        <p class="quiz-question">Which style property is iOS-only for Text components?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                fontSize
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                textShadowColor
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                fontWeight
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                textAlign
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-code"></i> Mini Project: Business Card</h3>
                        <p class="project-description">Create a digital business card using View and Text components:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="vt1">
                                <label for="vt1">Create a card container with shadow/elevation</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="vt2">
                                <label for="vt2">Add name with large, bold text</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="vt3">
                                <label for="vt3">Add job title with different color</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="vt4">
                                <label for="vt4">Create contact info section with icons</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="vt5">
                                <label for="vt5">Make email/phone clickable</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'image-imagebackground': {
        title: 'Image & ImageBackground',
        content: `
                    <h1><i class="fas fa-image"></i> Image & ImageBackground Components</h1>
                    
                    <p>Images are essential for creating engaging mobile apps. React Native provides powerful Image and ImageBackground components for displaying local and remote images with various styling options.</p>

                    <h2><i class="fas fa-photo-video"></i> The Image Component</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Basic Image Usage</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import { View, Image, StyleSheet, Text } from 'react-native';

const ImageExample = () => {
  return (
    <View style={styles.container}>
      {/* Local Image */}
      <Image 
        source={require('./assets/logo.png')}
        style={styles.localImage}
      />
      
      {/* Remote Image */}
      <Image 
        source={{
          uri: 'https://picsum.photos/200/200',
          headers: {
            Authorization: 'Bearer token'
          }
        }}
        style={styles.remoteImage}
        onLoad={() => console.log('Image loaded')}
        onError={(error) => console.log('Error loading image:', error)}
      />
      
      {/* Image with Loading Indicator */}
      <Image 
        source={{ uri: 'https://picsum.photos/300/200' }}
        style={styles.loadingImage}
        defaultSource={require('./assets/placeholder.png')}
        loadingIndicatorSource={require('./assets/loading.gif')}
      />
      
      {/* Resized Image with Different Modes */}
      <Image 
        source={{ uri: 'https://picsum.photos/400/300' }}
        style={styles.resizedImage}
        resizeMode="cover" // 'cover', 'contain', 'stretch', 'repeat', 'center'
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#f0f0f0',
  },
  localImage: {
    width: 100,
    height: 100,
    marginBottom: 20,
  },
  remoteImage: {
    width: 200,
    height: 200,
    marginBottom: 20,
    borderRadius: 10,
  },
  loadingImage: {
    width: 300,
    height: 200,
    marginBottom: 20,
  },
  resizedImage: {
    width: '100%',
    height: 200,
    backgroundColor: '#ccc',
  },
});</code></pre>
                    </div>

                    <h3>Image Resize Modes</h3>
                    <div class="tip-box">
                        <h4><i class="fas fa-expand-arrows-alt"></i> Resize Mode Options</h4>
                        <p>• <strong>cover:</strong> Scale image to cover the frame (may crop)<br>
                        • <strong>contain:</strong> Scale image to fit inside frame<br>
                        • <strong>stretch:</strong> Scale width and height independently<br>
                        • <strong>repeat:</strong> Repeat image to cover frame<br>
                        • <strong>center:</strong> Center image without scaling</p>
                    </div>

                    <h2><i class="fas fa-layer-group"></i> ImageBackground Component</h2>
                    <p>ImageBackground allows you to use an image as a background with children components on top.</p>

                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">ImageBackground Example</span>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import { ImageBackground, Text, View, StyleSheet } from 'react-native';

const ImageBackgroundExample = () => {
  return (
    <ImageBackground
      source={{ uri: 'https://picsum.photos/400/600' }}
      style={styles.backgroundImage}
      resizeMode="cover"
      imageStyle={styles.imageStyle} // Additional image styling
    >
      <View style={styles.overlay}>
        <Text style={styles.title}>Welcome</Text>
        <Text style={styles.subtitle}>Beautiful Background</Text>
      </View>
      
      <View style={styles.content}>
        <Text style={styles.description}>
          ImageBackground allows you to place content
          over an image with full control over styling.
        </Text>
      </View>
    </ImageBackground>
  );
};

const styles = StyleSheet.create({
  backgroundImage: {
    flex: 1,
    justifyContent: 'space-between',
  },
  imageStyle: {
    opacity: 0.8, // Make image slightly transparent
  },
  overlay: {
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    padding: 20,
    alignItems: 'center',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    color: 'white',
    textShadowColor: 'rgba(0, 0, 0, 0.75)',
    textShadowOffset: { width: -1, height: 1 },
    textShadowRadius: 10,
  },
  subtitle: {
    fontSize: 18,
    color: 'white',
    marginTop: 10,
  },
  content: {
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    padding: 20,
    margin: 20,
    borderRadius: 10,
  },
  description: {
    fontSize: 16,
    color: '#333',
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-cog"></i> Advanced Image Handling</h2>

                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Image Optimization & Caching</span>
                        </div>
                        <pre><code class="language-typescript">import React, { useState } from 'react';
import { View, Image, ActivityIndicator, Text } from 'react-native';

const OptimizedImage = ({ source, style }) => {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(false);

  return (
    <View style={style}>
      <Image
        source={source}
        style={[style, { position: 'absolute' }]}
        onLoadStart={() => setLoading(true)}
        onLoadEnd={() => setLoading(false)}
        onError={() => {
          setError(true);
          setLoading(false);
        }}
        // Performance optimizations
        fadeDuration={300} // Android only
        progressiveRenderingEnabled={true} // Android only
        cache="force-cache" // iOS only
      />
      
      {loading && (
        <View style={[style, styles.centered]}>
          <ActivityIndicator size="large" color="#007AFF" />
        </View>
      )}
      
      {error && (
        <View style={[style, styles.centered, styles.errorContainer]}>
          <Text style={styles.errorText}>Failed to load image</Text>
        </View>
      )}
    </View>
  );
};

// Preload images for better performance
const preloadImages = async (imageSources) => {
  const promises = imageSources.map((source) => 
    Image.prefetch(source)
  );
  
  try {
    await Promise.all(promises);
    console.log('All images preloaded');
  } catch (error) {
    console.error('Error preloading images:', error);
  }
};

// Get image size
const getImageDimensions = async (uri) => {
  return new Promise((resolve, reject) => {
    Image.getSize(
      uri,
      (width, height) => resolve({ width, height }),
      (error) => reject(error)
    );
  });
};</code></pre>
                    </div>

                    <h2><i class="fas fa-images"></i> Working with Different Image Formats</h2>

                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Image Format Examples</span>
                        </div>
                        <pre><code class="language-typescript">const ImageFormats = () => {
  return (
    <View>
      {/* Static Images - Automatically sized */}
      <Image source={require('./assets/icon.png')} />
      
      {/* Network Images - Must specify dimensions */}
      <Image 
        source={{ uri: 'https://example.com/image.jpg' }}
        style={{ width: 200, height: 200 }}
      />
      
      {/* Base64 Images */}
      <Image 
        source={{ 
          uri: 'data:image/png;base64,iVBORw0KGgoAAAANS...' 
        }}
        style={{ width: 50, height: 50 }}
      />
      
      {/* Platform-specific images */}
      <Image 
        source={{
          ios: require('./assets/image.ios.png'),
          android: require('./assets/image.android.png'),
        }}
        style={{ width: 100, height: 100 }}
      />
      
      {/* Resolution-specific images (image@2x.png, image@3x.png) */}
      <Image source={require('./assets/image.png')} />
    </View>
  );
};</code></pre>
                    </div>

                    <div class="playground">
                        <div class="playground-header">
                            <h3><i class="fas fa-play-circle"></i> Image Gallery Demo</h3>
                            <div class="playground-tabs">
                                <button class="playground-tab active" onclick="switchPlaygroundTab(this, 'code')">Code</button>
                                <button class="playground-tab" onclick="switchPlaygroundTab(this, 'preview')">Preview</button>
                            </div>
                        </div>
                        <div class="playground-content">
                            <div class="playground-editor" id="playground-code">
                                <textarea class="editor-textarea">
import React, { useState } from 'react';
import { 
  View, 
  Image, 
  TouchableOpacity, 
  ScrollView, 
  Modal,
  StyleSheet 
} from 'react-native';

const ImageGallery = () => {
  const [selectedImage, setSelectedImage] = useState(null);
  
  const images = [
    'https://picsum.photos/200/200?random=1',
    'https://picsum.photos/200/200?random=2',
    'https://picsum.photos/200/200?random=3',
    'https://picsum.photos/200/200?random=4',
    'https://picsum.photos/200/200?random=5',
    'https://picsum.photos/200/200?random=6',
  ];

  return (
    <View style={styles.container}>
      <ScrollView>
        <View style={styles.gallery}>
          {images.map((uri, index) => (
            <TouchableOpacity
              key={index}
              onPress={() => setSelectedImage(uri)}
              style={styles.thumbnail}
            >
              <Image 
                source={{ uri }}
                style={styles.thumbnailImage}
                resizeMode="cover"
              />
            </TouchableOpacity>
          ))}
        </View>
      </ScrollView>

      <Modal
        visible={!!selectedImage}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setSelectedImage(null)}
      >
        <TouchableOpacity 
          style={styles.modalContainer}
          onPress={() => setSelectedImage(null)}
        >
          <Image 
            source={{ uri: selectedImage }}
            style={styles.fullImage}
            resizeMode="contain"
          />
        </TouchableOpacity>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  gallery: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    padding: 10,
  },
  thumbnail: {
    width: '31%',
    aspectRatio: 1,
    margin: '1.5%',
  },
  thumbnailImage: {
    width: '100%',
    height: '100%',
    borderRadius: 10,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.9)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  fullImage: {
    width: '90%',
    height: '70%',
  },
});</textarea>
                            </div>
                            <div class="playground-preview" id="playground-preview" style="display: none;">
                                <div style="flex: 1; background: white;">
                                    <div style="display: flex; flex-wrap: wrap; padding: 10px;">
                                        <div style="width: 31%; margin: 1.5%; aspect-ratio: 1;">
                                            <img src="https://picsum.photos/200/200?random=1" style="width: 100%; height: 100%; border-radius: 10px; object-fit: cover;" />
                                        </div>
                                        <div style="width: 31%; margin: 1.5%; aspect-ratio: 1;">
                                            <img src="https://picsum.photos/200/200?random=2" style="width: 100%; height: 100%; border-radius: 10px; object-fit: cover;" />
                                        </div>
                                        <div style="width: 31%; margin: 1.5%; aspect-ratio: 1;">
                                            <img src="https://picsum.photos/200/200?random=3" style="width: 100%; height: 100%; border-radius: 10px; object-fit: cover;" />
                                        </div>
                                        <div style="width: 31%; margin: 1.5%; aspect-ratio: 1;">
                                            <img src="https://picsum.photos/200/200?random=4" style="width: 100%; height: 100%; border-radius: 10px; object-fit: cover;" />
                                        </div>
                                        <div style="width: 31%; margin: 1.5%; aspect-ratio: 1;">
                                            <img src="https://picsum.photos/200/200?random=5" style="width: 100%; height: 100%; border-radius: 10px; object-fit: cover;" />
                                        </div>
                                        <div style="width: 31%; margin: 1.5%; aspect-ratio: 1;">
                                            <img src="https://picsum.photos/200/200?random=6" style="width: 100%; height: 100%; border-radius: 10px; object-fit: cover;" />
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="warning-box">
                        <h4><i class="fas fa-exclamation-triangle"></i> Performance Tips</h4>
                        <p>• Use appropriate image sizes - don't load 4K images for thumbnails<br>
                        • Enable image caching for network images<br>
                        • Use progressive loading for large images<br>
                        • Consider using FastImage library for better performance<br>
                        • Always specify dimensions for network images</p>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Image Knowledge Check</h3>
                        <p class="quiz-question">Which prop must be specified for network images but not for local images?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                source
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                resizeMode
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                style with width and height
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                onLoad
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-camera"></i> Project: Photo Card Component</h3>
                        <p class="project-description">Build a reusable photo card with overlay information:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="img1">
                                <label for="img1">Create ImageBackground with gradient overlay</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="img2">
                                <label for="img2">Add loading state with placeholder</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="img3">
                                <label for="img3">Implement error handling with fallback image</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="img4">
                                <label for="img4">Add title and description overlay</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="img5">
                                <label for="img5">Make it responsive with proper aspect ratio</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'scrollview-flatlist': {
        title: 'ScrollView & FlatList',
        content: `
                    <h1><i class="fas fa-scroll"></i> ScrollView & FlatList Components</h1>
                    
                    <p>Scrollable content is essential in mobile apps. React Native provides ScrollView for smaller lists and FlatList for efficient rendering of large data sets.</p>

                    <h2><i class="fas fa-arrows-alt-v"></i> ScrollView Component</h2>
                    <p>ScrollView renders all its children at once, making it suitable for small amounts of content.</p>

                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">ScrollView Basics</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import { ScrollView, View, Text, StyleSheet, RefreshControl } from 'react-native';

const ScrollViewExample = () => {
  const [refreshing, setRefreshing] = React.useState(false);

  const onRefresh = React.useCallback(() => {
    setRefreshing(true);
    // Simulate API call
    setTimeout(() => {
      setRefreshing(false);
    }, 2000);
  }, []);

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
      // Scroll properties
      horizontal={false}
      showsVerticalScrollIndicator={true}
      showsHorizontalScrollIndicator={false}
      
      // Behavior properties
      bounces={true}
      scrollEnabled={true}
      pagingEnabled={false}
      
      // Keyboard handling
      keyboardDismissMode="on-drag" // 'none', 'on-drag', 'interactive'
      keyboardShouldPersistTaps="handled" // 'always', 'never', 'handled'
      
      // Pull to refresh
      refreshControl={
        <RefreshControl
          refreshing={refreshing}
          onRefresh={onRefresh}
          colors={['#007AFF']} // Android
          tintColor="#007AFF" // iOS
        />
      }
      
      // Scroll events
      onScroll={(event) => {
        const { contentOffset, contentSize, layoutMeasurement } = event.nativeEvent;
        console.log('Scroll position:', contentOffset.y);
      }}
      scrollEventThrottle={16} // For smooth 60fps
    >
      {[...Array(20)].map((_, index) => (
        <View key={index} style={styles.item}>
          <Text style={styles.itemText}>Item {index + 1}</Text>
        </View>
      ))}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f0f0f0',
  },
  contentContainer: {
    paddingVertical: 20,
  },
  item: {
    backgroundColor: 'white',
    padding: 20,
    marginHorizontal: 20,
    marginVertical: 10,
    borderRadius: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  itemText: {
    fontSize: 16,
    color: '#333',
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-list"></i> FlatList Component</h2>
                    <p>FlatList is optimized for long lists by only rendering items that are currently visible on screen.</p>

                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">FlatList Implementation</span>
                        </div>
                        <pre><code class="language-typescript">import React, { useState, useCallback } from 'react';
import {
  FlatList,
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  Image,
} from 'react-native';

interface User {
  id: string;
  name: string;
  email: string;
  avatar: string;
}

const FlatListExample = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);

  // Load initial data
  React.useEffect(() => {
    loadUsers();
  }, []);

  const loadUsers = async () => {
    if (loading) return;
    
    setLoading(true);
    // Simulate API call
    setTimeout(() => {
      const newUsers = Array.from({ length: 10 }, (_, i) => ({
        id: \`\${page}-\${i}\`,
        name: \`User \${(page - 1) * 10 + i + 1}\`,
        email: \`user\${(page - 1) * 10 + i + 1}@example.com\`,
        avatar: \`https://i.pravatar.cc/150?img=\${(page - 1) * 10 + i + 1}\`,
      }));
      
      setUsers(prev => [...prev, ...newUsers]);
      setPage(prev => prev + 1);
      setHasMore(page < 5); // Limit to 5 pages
      setLoading(false);
    }, 1000);
  };

  const onRefresh = useCallback(() => {
    setRefreshing(true);
    setUsers([]);
    setPage(1);
    setHasMore(true);
    
    // Reload data
    setTimeout(() => {
      loadUsers();
      setRefreshing(false);
    }, 1500);
  }, []);

  const renderItem = ({ item }: { item: User }) => (
    <TouchableOpacity style={styles.userItem} activeOpacity={0.7}>
      <Image source={{ uri: item.avatar }} style={styles.avatar} />
      <View style={styles.userInfo}>
        <Text style={styles.userName}>{item.name}</Text>
        <Text style={styles.userEmail}>{item.email}</Text>
      </View>
      <Text style={styles.chevron}>›</Text>
    </TouchableOpacity>
  );

  const renderFooter = () => {
    if (!loading) return null;
    return (
      <View style={styles.footer}>
        <ActivityIndicator size="small" color="#007AFF" />
      </View>
    );
  };

  const renderEmpty = () => (
    <View style={styles.empty}>
      <Text style={styles.emptyText}>No users found</Text>
    </View>
  );

  const renderHeader = () => (
    <View style={styles.header}>
      <Text style={styles.headerText}>User Directory</Text>
    </View>
  );

  return (
    <FlatList
      data={users}
      renderItem={renderItem}
      keyExtractor={(item) => item.id}
      
      // Performance optimizations
      removeClippedSubviews={true}
      maxToRenderPerBatch={10}
      updateCellsBatchingPeriod={50}
      initialNumToRender={10}
      windowSize={10}
      
      // Header and Footer
      ListHeaderComponent={renderHeader}
      ListFooterComponent={renderFooter}
      ListEmptyComponent={renderEmpty}
      
      // Separators
      ItemSeparatorComponent={() => <View style={styles.separator} />}
      
      // Pull to refresh
      refreshing={refreshing}
      onRefresh={onRefresh}
      
      // Infinite scroll
      onEndReached={() => {
        if (hasMore && !loading) {
          loadUsers();
        }
      }}
      onEndReachedThreshold={0.5}
      
      // Styling
      contentContainerStyle={styles.contentContainer}
      showsVerticalScrollIndicator={false}
    />
  );
};

const styles = StyleSheet.create({
  contentContainer: {
    paddingBottom: 20,
  },
  header: {
    padding: 20,
    backgroundColor: '#007AFF',
  },
  headerText: {
    fontSize: 24,
    fontWeight: 'bold',
    color: 'white',
  },
  userItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
    backgroundColor: 'white',
  },
  avatar: {
    width: 50,
    height: 50,
    borderRadius: 25,
    marginRight: 15,
  },
  userInfo: {
    flex: 1,
  },
  userName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  userEmail: {
    fontSize: 14,
    color: '#666',
  },
  chevron: {
    fontSize: 24,
    color: '#999',
  },
  separator: {
    height: 1,
    backgroundColor: '#e0e0e0',
    marginLeft: 80,
  },
  footer: {
    paddingVertical: 20,
    alignItems: 'center',
  },
  empty: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 50,
  },
  emptyText: {
    fontSize: 16,
    color: '#999',
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-exchange-alt"></i> ScrollView vs FlatList</h2>
                    
                    <div class="tip-box">
                        <h4><i class="fas fa-balance-scale"></i> When to Use Each</h4>
                        <p><strong>Use ScrollView when:</strong><br>
                        • You have a small amount of content<br>
                        • Content is heterogeneous (different types)<br>
                        • You need precise scroll position control<br><br>
                        <strong>Use FlatList when:</strong><br>
                        • You have a large list of similar items<br>
                        • Performance is critical<br>
                        • You need lazy loading or infinite scroll<br>
                        • Memory efficiency is important</p>
                    </div>

                    <h2><i class="fas fa-th"></i> Advanced List Patterns</h2>

                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Horizontal FlatList with Snap</span>
                        </div>
                        <pre><code class="language-typescript">const HorizontalList = () => {
  const data = [
    { id: '1', title: 'Card 1', color: '#FF6B6B' },
    { id: '2', title: 'Card 2', color: '#4ECDC4' },
    { id: '3', title: 'Card 3', color: '#45B7D1' },
    { id: '4', title: 'Card 4', color: '#96CEB4' },
  ];

  return (
    <FlatList
      data={data}
      horizontal
      pagingEnabled
      snapToInterval={CARD_WIDTH + 20} // Card width + margin
      snapToAlignment="center"
      decelerationRate="fast"
      showsHorizontalScrollIndicator={false}
      renderItem={({ item }) => (
        <View style={[
          styles.card,
          { backgroundColor: item.color }
        ]}>
          <Text style={styles.cardTitle}>{item.title}</Text>
        </View>
      )}
      keyExtractor={(item) => item.id}
      contentContainerStyle={styles.horizontalList}
    />
  );
};</code></pre>
                    </div>

                    <div class="playground">
                        <div class="playground-header">
                            <h3><i class="fas fa-play-circle"></i> Interactive List Demo</h3>
                            <div class="playground-tabs">
                                <button class="playground-tab active" onclick="switchPlaygroundTab(this, 'code')">Code</button>
                                <button class="playground-tab" onclick="switchPlaygroundTab(this, 'preview')">Preview</button>
                            </div>
                        </div>
                        <div class="playground-content">
                            <div class="playground-editor" id="playground-code">
                                <textarea class="editor-textarea">
import React, { useState } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  StyleSheet,
  Switch,
} from 'react-native';

const InteractiveList = () => {
  const [selectedIds, setSelectedIds] = useState(new Set());
  const [multiSelect, setMultiSelect] = useState(false);

  const data = Array.from({ length: 20 }, (_, i) => ({
    id: i.toString(),
    title: \`Item \${i + 1}\`,
    description: \`Description for item \${i + 1}\`,
  }));

  const toggleSelection = (id: string) => {
    const newSelected = new Set(selectedIds);
    if (newSelected.has(id)) {
      newSelected.delete(id);
    } else {
      if (!multiSelect) {
        newSelected.clear();
      }
      newSelected.add(id);
    }
    setSelectedIds(newSelected);
  };

  const renderItem = ({ item }) => {
    const isSelected = selectedIds.has(item.id);
    
    return (
      <TouchableOpacity
        style={[
          styles.item,
          isSelected && styles.selectedItem
        ]}
        onPress={() => toggleSelection(item.id)}
        activeOpacity={0.7}
      >
        <View style={styles.itemContent}>
          <Text style={[
            styles.itemTitle,
            isSelected && styles.selectedText
          ]}>
            {item.title}
          </Text>
          <Text style={[
            styles.itemDescription,
            isSelected && styles.selectedText
          ]}>
            {item.description}
          </Text>
        </View>
        {isSelected && (
          <Text style={styles.checkmark}>✓</Text>
        )}
      </TouchableOpacity>
    );
  };

  return (
    <View style={styles.container}>
      <View style={styles.controls}>
        <Text style={styles.label}>Multi-select</Text>
        <Switch
          value={multiSelect}
          onValueChange={setMultiSelect}
          trackColor={{ false: '#767577', true: '#81b0ff' }}
          thumbColor={multiSelect ? '#007AFF' : '#f4f3f4'}
        />
      </View>
      
      <Text style={styles.selection}>
        Selected: {selectedIds.size} items
      </Text>
      
      <FlatList
        data={data}
        renderItem={renderItem}
        keyExtractor={(item) => item.id}
        extraData={selectedIds}
        showsVerticalScrollIndicator={false}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  controls: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 15,
    backgroundColor: 'white',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
  },
  selection: {
    padding: 10,
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
  },
  item: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'white',
    padding: 15,
    marginHorizontal: 10,
    marginVertical: 5,
    borderRadius: 8,
    borderWidth: 2,
    borderColor: 'transparent',
  },
  selectedItem: {
    borderColor: '#007AFF',
    backgroundColor: '#f0f8ff',
  },
  itemContent: {
    flex: 1,
  },
  itemTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  itemDescription: {
    fontSize: 14,
    color: '#666',
  },
  selectedText: {
    color: '#007AFF',
  },
  checkmark: {
    fontSize: 20,
    color: '#007AFF',
    fontWeight: 'bold',
  },
});</textarea>
                            </div>
                            <div class="playground-preview" id="playground-preview" style="display: none;">
                                <div style="flex: 1; background: #f5f5f5;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; background: white; border-bottom: 1px solid #e0e0e0;">
                                        <span style="font-size: 16px; font-weight: 600;">Multi-select</span>
                                        <input type="checkbox" style="width: 20px; height: 20px;" />
                                    </div>
                                    <p style="padding: 10px; text-align: center; color: #666;">Selected: 0 items</p>
                                    <div style="padding: 0 10px;">
                                        <div style="background: white; padding: 15px; margin: 5px 0; border-radius: 8px; border: 2px solid transparent;">
                                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px;">Item 1</div>
                                            <div style="font-size: 14px; color: #666;">Description for item 1</div>
                                        </div>
                                        <div style="background: #f0f8ff; padding: 15px; margin: 5px 0; border-radius: 8px; border: 2px solid #007AFF; display: flex; justify-content: space-between; align-items: center;">
                                            <div>
                                                <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px; color: #007AFF;">Item 2</div>
                                                <div style="font-size: 14px; color: #007AFF;">Description for item 2</div>
                                            </div>
                                            <span style="font-size: 20px; color: #007AFF; font-weight: bold;">✓</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="warning-box">
                        <h4><i class="fas fa-exclamation-triangle"></i> Performance Best Practices</h4>
                        <p>• Use getItemLayout when items have fixed height<br>
                        • Implement shouldComponentUpdate or React.memo for list items<br>
                        • Avoid anonymous functions in renderItem<br>
                        • Use keyExtractor for stable keys<br>
                        • Set appropriate windowSize and maxToRenderPerBatch</p>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> List Knowledge Check</h3>
                        <p class="quiz-question">Which prop improves FlatList performance by removing off-screen items?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                initialNumToRender
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                removeClippedSubviews
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                onEndReachedThreshold
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                windowSize
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-tasks"></i> Project: Social Feed</h3>
                        <p class="project-description">Build a social media feed with FlatList:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="list1">
                                <label for="list1">Create post card component with image</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="list2">
                                <label for="list2">Implement pull-to-refresh</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="list3">
                                <label for="list3">Add infinite scroll with loading indicator</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="list4">
                                <label for="list4">Optimize with React.memo</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="list5">
                                <label for="list5">Add like/comment interactions</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'textinput': {
        title: 'TextInput & Forms',
        content: `
                    <h1><i class="fas fa-keyboard"></i> TextInput & Forms</h1>
                    
                    <p>TextInput is the fundamental component for entering text in React Native apps. Let's explore how to create robust forms with validation, keyboard handling, and great UX.</p>

                    <h2><i class="fas fa-edit"></i> Basic TextInput</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">TextInput Examples</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-typescript">import React, { useState } from 'react';
import {
  View,
  TextInput,
  Text,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  TouchableOpacity,
  Keyboard,
  ScrollView,
} from 'react-native';

const TextInputExample = () => {
  const [text, setText] = useState('');
  const [password, setPassword] = useState('');
  const [multiline, setMultiline] = useState('');
  const [phone, setPhone] = useState('');
  const [email, setEmail] = useState('');

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      style={styles.container}
    >
      <ScrollView showsVerticalScrollIndicator={false}>
        {/* Basic Text Input */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>Basic Input</Text>
          <TextInput
            style={styles.input}
            value={text}
            onChangeText={setText}
            placeholder="Enter text..."
            placeholderTextColor="#999"
          />
        </View>

        {/* Password Input */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>Password</Text>
          <TextInput
            style={styles.input}
            value={password}
            onChangeText={setPassword}
            placeholder="Enter password..."
            placeholderTextColor="#999"
            secureTextEntry
            autoCapitalize="none"
            autoCorrect={false}
          />
        </View>

        {/* Email Input */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>Email</Text>
          <TextInput
            style={styles.input}
            value={email}
            onChangeText={setEmail}
            placeholder="email@example.com"
            placeholderTextColor="#999"
            keyboardType="email-address"
            autoCapitalize="none"
            autoCorrect={false}
            autoCompleteType="email"
            textContentType="emailAddress"
          />
        </View>

        {/* Phone Input */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>Phone Number</Text>
          <TextInput
            style={styles.input}
            value={phone}
            onChangeText={setPhone}
            placeholder="(123) 456-7890"
            placeholderTextColor="#999"
            keyboardType="phone-pad"
            maxLength={14}
            textContentType="telephoneNumber"
          />
        </View>

        {/* Multiline Input */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>Comments</Text>
          <TextInput
            style={[styles.input, styles.multilineInput]}
            value={multiline}
            onChangeText={setMultiline}
            placeholder="Enter your comments..."
            placeholderTextColor="#999"
            multiline
            numberOfLines={4}
            textAlignVertical="top"
            maxLength={500}
          />
          <Text style={styles.charCount}>
            {multiline.length}/500
          </Text>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    padding: 20,
  },
  inputGroup: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  input: {
    backgroundColor: 'white',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 15,
    paddingVertical: 12,
    fontSize: 16,
    color: '#333',
  },
  multilineInput: {
    height: 100,
    paddingTop: 12,
  },
  charCount: {
    textAlign: 'right',
    color: '#666',
    fontSize: 12,
    marginTop: 5,
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-check-circle"></i> Form with Validation</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Complete Form Example</span>
                        </div>
                        <pre><code class="language-typescript">import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Alert,
} from 'react-native';

interface FormData {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  confirmPassword: string;
}

interface FormErrors {
  [key: string]: string;
}

const SignUpForm = () => {
  const [formData, setFormData] = useState<FormData>({
    firstName: '',
    lastName: '',
    email: '',
    password: '',
    confirmPassword: '',
  });

  const [errors, setErrors] = useState<FormErrors>({});
  const [touched, setTouched] = useState<Set<string>>(new Set());
  const [showPassword, setShowPassword] = useState(false);

  const validateField = (field: string, value: string): string => {
    switch (field) {
      case 'firstName':
      case 'lastName':
        return value.length < 2 ? 'Must be at least 2 characters' : '';
      
      case 'email':
        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
        return !emailRegex.test(value) ? 'Invalid email address' : '';
      
      case 'password':
        if (value.length < 8) return 'Must be at least 8 characters';
        if (!/[A-Z]/.test(value)) return 'Must contain uppercase letter';
        if (!/[0-9]/.test(value)) return 'Must contain number';
        return '';
      
      case 'confirmPassword':
        return value !== formData.password ? 'Passwords do not match' : '';
      
      default:
        return '';
    }
  };

  const handleChange = (field: keyof FormData, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    if (touched.has(field)) {
      const error = validateField(field, value);
      setErrors(prev => ({ ...prev, [field]: error }));
    }
  };

  const handleBlur = (field: string) => {
    setTouched(prev => new Set(prev).add(field));
    const error = validateField(field, formData[field as keyof FormData]);
    setErrors(prev => ({ ...prev, [field]: error }));
  };

  const handleSubmit = () => {
    // Validate all fields
    const newErrors: FormErrors = {};
    let hasErrors = false;

    Object.keys(formData).forEach(field => {
      const error = validateField(field, formData[field as keyof FormData]);
      if (error) {
        newErrors[field] = error;
        hasErrors = true;
      }
    });

    setErrors(newErrors);
    setTouched(new Set(Object.keys(formData)));

    if (!hasErrors) {
      Alert.alert('Success', 'Form submitted successfully!');
    }
  };

  const renderInput = (
    field: keyof FormData,
    label: string,
    props: any = {}
  ) => (
    <View style={styles.inputGroup}>
      <Text style={styles.label}>{label}</Text>
      <View style={styles.inputContainer}>
        <TextInput
          style={[
            styles.input,
            errors[field] && touched.has(field) && styles.inputError
          ]}
          value={formData[field]}
          onChangeText={(value) => handleChange(field, value)}
          onBlur={() => handleBlur(field)}
          placeholderTextColor="#999"
          {...props}
        />
        {field === 'password' && (
          <TouchableOpacity
            style={styles.eyeIcon}
            onPress={() => setShowPassword(!showPassword)}
          >
            <Text>{showPassword ? '👁' : '👁‍🗨'}</Text>
          </TouchableOpacity>
        )}
      </View>
      {errors[field] && touched.has(field) && (
        <Text style={styles.errorText}>{errors[field]}</Text>
      )}
    </View>
  );

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      style={styles.container}
    >
      <ScrollView showsVerticalScrollIndicator={false}>
        <Text style={styles.title}>Create Account</Text>

        {renderInput('firstName', 'First Name', {
          placeholder: 'John',
          autoCapitalize: 'words',
        })}

        {renderInput('lastName', 'Last Name', {
          placeholder: 'Doe',
          autoCapitalize: 'words',
        })}

        {renderInput('email', 'Email', {
          placeholder: 'john.doe@example.com',
          keyboardType: 'email-address',
          autoCapitalize: 'none',
          autoCorrect: false,
        })}

        {renderInput('password', 'Password', {
          placeholder: 'Min 8 characters',
          secureTextEntry: !showPassword,
          autoCapitalize: 'none',
        })}

        {renderInput('confirmPassword', 'Confirm Password', {
          placeholder: 'Re-enter password',
          secureTextEntry: true,
          autoCapitalize: 'none',
        })}

        <TouchableOpacity
          style={styles.submitButton}
          onPress={handleSubmit}
        >
          <Text style={styles.submitButtonText}>Sign Up</Text>
        </TouchableOpacity>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    padding: 20,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 30,
    textAlign: 'center',
  },
  inputGroup: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  inputContainer: {
    position: 'relative',
  },
  input: {
    backgroundColor: 'white',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 15,
    paddingVertical: 12,
    fontSize: 16,
    color: '#333',
  },
  inputError: {
    borderColor: '#ff3b30',
  },
  eyeIcon: {
    position: 'absolute',
    right: 15,
    top: 12,
  },
  errorText: {
    color: '#ff3b30',
    fontSize: 12,
    marginTop: 5,
  },
  submitButton: {
    backgroundColor: '#007AFF',
    paddingVertical: 15,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 20,
  },
  submitButtonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: '600',
  },
});</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4><i class="fas fa-lightbulb"></i> TextInput Props</h4>
                        <p>• <strong>keyboardType:</strong> default, numeric, email-address, phone-pad<br>
                        • <strong>autoCapitalize:</strong> none, sentences, words, characters<br>
                        • <strong>autoCorrect:</strong> Enable/disable autocorrection<br>
                        • <strong>secureTextEntry:</strong> Hide password input<br>
                        • <strong>returnKeyType:</strong> done, go, next, search, send</p>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Form Knowledge Check</h3>
                        <p class="quiz-question">Which prop should you use to hide password input?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                hideText
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                secureTextEntry
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                passwordMode
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                textHidden
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-clipboard-list"></i> Project: Login Form</h3>
                        <p class="project-description">Build a complete login form with remember me:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="form1">
                                <label for="form1">Create email and password inputs</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="form2">
                                <label for="form2">Add form validation</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="form3">
                                <label for="form3">Implement remember me checkbox</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="form4">
                                <label for="form4">Add loading state for submission</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="form5">
                                <label for="form5">Handle keyboard dismiss on submit</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'touchables': {
        title: 'Touchable Components',
        content: `
                    <h1><i class="fas fa-hand-pointer"></i> Touchable Components</h1>
                    
                    <p>Touchable components are the primary way to capture taps and provide feedback in React Native. Let's explore all the touchable options and when to use each.</p>

                    <h2><i class="fas fa-square"></i> TouchableOpacity</h2>
                    <p>Reduces opacity when pressed - the most common touchable component.</p>

                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">TouchableOpacity Example</span>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
} from 'react-native';

const TouchableOpacityExample = () => {
  return (
    <View style={styles.container}>
      {/* Basic Button */}
      <TouchableOpacity
        style={styles.button}
        onPress={() => console.log('Button pressed')}
        activeOpacity={0.7} // Controls opacity when pressed (0-1)
      >
        <Text style={styles.buttonText}>Press Me</Text>
      </TouchableOpacity>

      {/* Icon Button */}
      <TouchableOpacity
        style={styles.iconButton}
        onPress={() => console.log('Icon pressed')}
        onLongPress={() => console.log('Long pressed!')}
        delayLongPress={500} // Milliseconds
      >
        <Text style={styles.icon}>❤️</Text>
      </TouchableOpacity>

      {/* Disabled Button */}
      <TouchableOpacity
        style={[styles.button, styles.disabledButton]}
        onPress={() => console.log('This won\\'t fire')}
        disabled={true}
      >
        <Text style={[styles.buttonText, styles.disabledText]}>
          Disabled
        </Text>
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    justifyContent: 'center',
  },
  button: {
    backgroundColor: '#007AFF',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: 'center',
    marginBottom: 20,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  iconButton: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: '#FF3B30',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
    alignSelf: 'center',
  },
  icon: {
    fontSize: 24,
  },
  disabledButton: {
    backgroundColor: '#ccc',
  },
  disabledText: {
    color: '#666',
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-hand-rock"></i> Other Touchable Components</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">All Touchable Types</span>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import {
  View,
  Text,
  TouchableHighlight,
  TouchableWithoutFeedback,
  TouchableNativeFeedback,
  Platform,
  StyleSheet,
} from 'react-native';

const TouchableExamples = () => {
  return (
    <View style={styles.container}>
      {/* TouchableHighlight - Shows underlay color */}
      <TouchableHighlight
        style={styles.highlight}
        onPress={() => console.log('Highlight pressed')}
        underlayColor="#0051CC" // Color shown when pressed
        onShowUnderlay={() => console.log('Underlay shown')}
        onHideUnderlay={() => console.log('Underlay hidden')}
      >
        <Text style={styles.text}>TouchableHighlight</Text>
      </TouchableHighlight>

      {/* TouchableWithoutFeedback - No visual feedback */}
      <TouchableWithoutFeedback
        onPress={() => console.log('No feedback press')}
      >
        <View style={styles.withoutFeedback}>
          <Text style={styles.text}>TouchableWithoutFeedback</Text>
          <Text style={styles.subtitle}>No visual feedback</Text>
        </View>
      </TouchableWithoutFeedback>

      {/* TouchableNativeFeedback - Android only ripple */}
      {Platform.OS === 'android' && (
        <TouchableNativeFeedback
          onPress={() => console.log('Native feedback')}
          background={TouchableNativeFeedback.Ripple('#fff', false)}
        >
          <View style={styles.nativeFeedback}>
            <Text style={styles.text}>TouchableNativeFeedback</Text>
            <Text style={styles.subtitle}>Android ripple effect</Text>
          </View>
        </TouchableNativeFeedback>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    justifyContent: 'center',
  },
  highlight: {
    backgroundColor: '#007AFF',
    padding: 15,
    borderRadius: 8,
    marginBottom: 20,
  },
  withoutFeedback: {
    backgroundColor: '#34C759',
    padding: 15,
    borderRadius: 8,
    marginBottom: 20,
  },
  nativeFeedback: {
    backgroundColor: '#FF9500',
    padding: 15,
    borderRadius: 8,
    marginBottom: 20,
    elevation: 4,
  },
  text: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
    textAlign: 'center',
  },
  subtitle: {
    color: 'rgba(255, 255, 255, 0.8)',
    fontSize: 12,
    textAlign: 'center',
    marginTop: 4,
  },
});</code></pre>
                    </div>

                    <div class="warning-box">
                        <h4><i class="fas fa-exclamation-triangle"></i> Platform Considerations</h4>
                        <p>• TouchableNativeFeedback is Android-only<br>
                        • Always provide fallback for iOS when using native feedback<br>
                        • Test touch areas on real devices<br>
                        • Minimum touch target should be 44x44 points</p>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-gamepad"></i> Project: Button Component</h3>
                        <p class="project-description">Create a reusable button component:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="touch1">
                                <label for="touch1">Support different variants (primary, secondary, danger)</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="touch2">
                                <label for="touch2">Add loading state with ActivityIndicator</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="touch3">
                                <label for="touch3">Implement icon support</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="touch4">
                                <label for="touch4">Add haptic feedback</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="touch5">
                                <label for="touch5">Create pressed state animations</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'modal-alert': {
        title: 'Modal & Alerts',
        content: `
                    <h1><i class="fas fa-window-restore"></i> Modal & Alerts</h1>
                    
                    <p>Modals and alerts are essential for displaying important information and gathering user input. Let's explore how to use them effectively.</p>

                    <h2><i class="fas fa-layer-group"></i> Modal Component</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Modal Examples</span>
                        </div>
                        <pre><code class="language-typescript">import React, { useState } from 'react';
import {
  View,
  Text,
  Modal,
  TouchableOpacity,
  StyleSheet,
  TouchableWithoutFeedback,
} from 'react-native';

const ModalExample = () => {
  const [modalVisible, setModalVisible] = useState(false);
  const [fullScreenModal, setFullScreenModal] = useState(false);

  return (
    <View style={styles.container}>
      {/* Bottom Sheet Modal */}
      <Modal
        animationType="slide"
        transparent={true}
        visible={modalVisible}
        onRequestClose={() => setModalVisible(false)}
      >
        <TouchableWithoutFeedback onPress={() => setModalVisible(false)}>
          <View style={styles.modalOverlay}>
            <TouchableWithoutFeedback>
              <View style={styles.bottomSheet}>
                <View style={styles.handle} />
                <Text style={styles.modalTitle}>Bottom Sheet</Text>
                <Text style={styles.modalText}>
                  This is a bottom sheet modal that slides up from the bottom.
                </Text>
                <TouchableOpacity
                  style={styles.modalButton}
                  onPress={() => setModalVisible(false)}
                >
                  <Text style={styles.modalButtonText}>Close</Text>
                </TouchableOpacity>
              </View>
            </TouchableWithoutFeedback>
          </View>
        </TouchableWithoutFeedback>
      </Modal>

      {/* Full Screen Modal */}
      <Modal
        animationType="fade"
        transparent={false}
        visible={fullScreenModal}
        onRequestClose={() => setFullScreenModal(false)}
        statusBarTranslucent={true}
      >
        <View style={styles.fullScreenModal}>
          <TouchableOpacity
            style={styles.closeButton}
            onPress={() => setFullScreenModal(false)}
          >
            <Text style={styles.closeButtonText}>✕</Text>
          </TouchableOpacity>
          <Text style={styles.fullScreenTitle}>Full Screen Modal</Text>
          <Text style={styles.fullScreenText}>
            This modal takes up the entire screen.
          </Text>
        </View>
      </Modal>

      {/* Trigger Buttons */}
      <TouchableOpacity
        style={styles.button}
        onPress={() => setModalVisible(true)}
      >
        <Text style={styles.buttonText}>Show Bottom Sheet</Text>
      </TouchableOpacity>

      <TouchableOpacity
        style={[styles.button, styles.secondaryButton]}
        onPress={() => setFullScreenModal(true)}
      >
        <Text style={styles.buttonText}>Show Full Screen</Text>
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 15,
    borderRadius: 8,
    marginBottom: 15,
    alignItems: 'center',
  },
  secondaryButton: {
    backgroundColor: '#34C759',
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  bottomSheet: {
    backgroundColor: 'white',
    paddingTop: 12,
    paddingHorizontal: 20,
    paddingBottom: 30,
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
  },
  handle: {
    width: 40,
    height: 4,
    backgroundColor: '#ccc',
    borderRadius: 2,
    alignSelf: 'center',
    marginBottom: 20,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  modalText: {
    fontSize: 16,
    color: '#666',
    marginBottom: 20,
  },
  modalButton: {
    backgroundColor: '#007AFF',
    padding: 15,
    borderRadius: 8,
    alignItems: 'center',
  },
  modalButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  fullScreenModal: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  closeButton: {
    position: 'absolute',
    top: 50,
    right: 20,
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0, 0, 0, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  closeButtonText: {
    fontSize: 24,
    color: '#333',
  },
  fullScreenTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  fullScreenText: {
    fontSize: 16,
    color: '#666',
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-exclamation-triangle"></i> Alert API</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Alert Examples</span>
                        </div>
                        <pre><code class="language-typescript">import { Alert, Platform } from 'react-native';

// Simple Alert
const showSimpleAlert = () => {
  Alert.alert('Alert Title', 'This is a simple alert message.');
};

// Alert with Buttons
const showConfirmAlert = () => {
  Alert.alert(
    'Delete Item',
    'Are you sure you want to delete this item?',
    [
      {
        text: 'Cancel',
        onPress: () => console.log('Cancel pressed'),
        style: 'cancel',
      },
      {
        text: 'Delete',
        onPress: () => console.log('Delete pressed'),
        style: 'destructive', // iOS only - makes text red
      },
    ],
    { cancelable: false } // Android - prevents dismissing by tapping outside
  );
};

// iOS-only Prompt
const showPrompt = () => {
  if (Platform.OS === 'ios') {
    Alert.prompt(
      'Enter Name',
      'What is your name?',
      [
        {
          text: 'Cancel',
          onPress: () => console.log('Cancel pressed'),
          style: 'cancel',
        },
        {
          text: 'OK',
          onPress: (text) => console.log('Name:', text),
        },
      ],
      'plain-text', // 'plain-text', 'secure-text', 'login-password'
      'John Doe', // Default value
      'default' // Keyboard type
    );
  } else {
    // For Android, you'd need to use a Modal with TextInput
    console.log('Prompt is iOS only');
  }
};</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4><i class="fas fa-lightbulb"></i> Modal Best Practices</h4>
                        <p>• Always handle onRequestClose for Android back button<br>
                        • Use transparent modals for overlays<br>
                        • Consider accessibility with proper labels<br>
                        • Test modal behavior on both platforms<br>
                        • Avoid nested modals</p>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Modal Knowledge Check</h3>
                        <p class="quiz-question">Which prop is required for Android back button handling in Modal?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                onClose
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                onRequestClose
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                onBackPress
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                onDismiss
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-window-maximize"></i> Project: Custom Alert System</h3>
                        <p class="project-description">Build a custom alert component:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="modal1">
                                <label for="modal1">Create custom alert modal component</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="modal2">
                                <label for="modal2">Support success, warning, error styles</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="modal3">
                                <label for="modal3">Add animation for show/hide</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="modal4">
                                <label for="modal4">Implement auto-dismiss option</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="modal5">
                                <label for="modal5">Create queue for multiple alerts</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'activityindicator': {
        title: 'ActivityIndicator',
        content: `
                    <h1><i class="fas fa-spinner"></i> ActivityIndicator Component</h1>
                    
                    <p>ActivityIndicator displays a circular loading indicator, essential for showing loading states in your app.</p>

                    <h2><i class="fas fa-circle-notch"></i> Basic Usage</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">ActivityIndicator Examples</span>
                        </div>
                        <pre><code class="language-typescript">import React, { useState } from 'react';
import {
  View,
  Text,
  ActivityIndicator,
  StyleSheet,
  TouchableOpacity,
  FlatList,
} from 'react-native';

const ActivityIndicatorExample = () => {
  const [loading, setLoading] = useState(false);
  const [data, setData] = useState([]);

  const loadData = async () => {
    setLoading(true);
    // Simulate API call
    setTimeout(() => {
      setData(['Item 1', 'Item 2', 'Item 3']);
      setLoading(false);
    }, 2000);
  };

  return (
    <View style={styles.container}>
      {/* Basic Indicators */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Sizes & Colors</Text>
        <View style={styles.row}>
          <ActivityIndicator size="small" color="#007AFF" />
          <ActivityIndicator size="large" color="#007AFF" />
          <ActivityIndicator size="large" color="#FF3B30" />
          <ActivityIndicator size="large" color="#34C759" />
        </View>
      </View>

      {/* Loading State Example */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Loading State</Text>
        {loading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#007AFF" />
            <Text style={styles.loadingText}>Loading data...</Text>
          </View>
        ) : data.length > 0 ? (
          <FlatList
            data={data}
            keyExtractor={(item, index) => index.toString()}
            renderItem={({ item }) => (
              <View style={styles.listItem}>
                <Text>{item}</Text>
              </View>
            )}
          />
        ) : (
          <TouchableOpacity style={styles.button} onPress={loadData}>
            <Text style={styles.buttonText}>Load Data</Text>
          </TouchableOpacity>
        )}
      </View>

      {/* Full Screen Loading */}
      {loading && (
        <View style={styles.fullScreenLoading}>
          <View style={styles.loadingBox}>
            <ActivityIndicator size="large" color="white" />
            <Text style={styles.fullScreenLoadingText}>
              Please wait...
            </Text>
          </View>
        </View>
      )}
    </View>
  );
};

// Custom Loading Component
const LoadingOverlay = ({ visible, text = 'Loading...' }) => {
  if (!visible) return null;

  return (
    <View style={styles.overlay}>
      <View style={styles.overlayContent}>
        <ActivityIndicator size="large" color="#007AFF" />
        <Text style={styles.overlayText}>{text}</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#f5f5f5',
  },
  section: {
    marginBottom: 30,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 15,
    color: '#333',
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    padding: 20,
    backgroundColor: 'white',
    borderRadius: 10,
  },
  loadingContainer: {
    padding: 40,
    alignItems: 'center',
    backgroundColor: 'white',
    borderRadius: 10,
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#666',
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 15,
    borderRadius: 8,
    alignItems: 'center',
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  listItem: {
    padding: 15,
    backgroundColor: 'white',
    marginBottom: 10,
    borderRadius: 8,
  },
  fullScreenLoading: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingBox: {
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    padding: 30,
    borderRadius: 10,
    alignItems: 'center',
  },
  fullScreenLoadingText: {
    color: 'white',
    marginTop: 10,
    fontSize: 16,
  },
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  overlayContent: {
    alignItems: 'center',
  },
  overlayText: {
    marginTop: 10,
    fontSize: 16,
    color: '#333',
  },
});</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4><i class="fas fa-lightbulb"></i> Loading Best Practices</h4>
                        <p>• Always show loading state for async operations<br>
                        • Provide meaningful loading messages<br>
                        • Consider skeleton screens for better UX<br>
                        • Avoid blocking the entire screen unless necessary<br>
                        • Set minimum loading time to prevent flashing</p>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-hourglass-half"></i> Project: Loading Component</h3>
                        <p class="project-description">Create a reusable loading component:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="activity1">
                                <label for="activity1">Build skeleton screen loader</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="activity2">
                                <label for="activity2">Add progress percentage support</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="activity3">
                                <label for="activity3">Create custom animated spinner</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="activity4">
                                <label for="activity4">Implement loading queue system</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="activity5">
                                <label for="activity5">Add timeout handling</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'statusbar': {
        title: 'StatusBar',
        content: `
                    <h1><i class="fas fa-mobile-alt"></i> StatusBar Component</h1>
                    
                    <p>The StatusBar component allows you to control the app status bar appearance. It's crucial for creating immersive experiences.</p>

                    <h2><i class="fas fa-adjust"></i> StatusBar Control</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">StatusBar Examples</span>
                        </div>
                        <pre><code class="language-typescript">import React, { useState } from 'react';
import {
  View,
  Text,
  StatusBar,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  Platform,
} from 'react-native';

const StatusBarExample = () => {
  const [hidden, setHidden] = useState(false);
  const [style, setStyle] = useState('default');
  const [backgroundColor, setBackgroundColor] = useState('#007AFF');

  return (
    <>
      <StatusBar
        barStyle={style} // 'default', 'light-content', 'dark-content'
        backgroundColor={backgroundColor} // Android only
        hidden={hidden}
        animated={true}
        showHideTransition="fade" // iOS only: 'fade', 'slide'
        networkActivityIndicatorVisible={false} // iOS only
        translucent={false} // Android only
      />
      
      <SafeAreaView style={[styles.container, { backgroundColor }]}>
        <View style={styles.content}>
          <Text style={styles.title}>StatusBar Control</Text>
          
          {/* Toggle Visibility */}
          <TouchableOpacity
            style={styles.button}
            onPress={() => setHidden(!hidden)}
          >
            <Text style={styles.buttonText}>
              {hidden ? 'Show' : 'Hide'} StatusBar
            </Text>
          </TouchableOpacity>
          
          {/* Change Style */}
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Bar Style</Text>
            <View style={styles.row}>
              <TouchableOpacity
                style={[styles.chip, style === 'default' && styles.activeChip]}
                onPress={() => setStyle('default')}
              >
                <Text style={styles.chipText}>Default</Text>
              </TouchableOpacity>
              
              <TouchableOpacity
                style={[styles.chip, style === 'light-content' && styles.activeChip]}
                onPress={() => setStyle('light-content')}
              >
                <Text style={styles.chipText}>Light</Text>
              </TouchableOpacity>
              
              <TouchableOpacity
                style={[styles.chip, style === 'dark-content' && styles.activeChip]}
                onPress={() => setStyle('dark-content')}
              >
                <Text style={styles.chipText}>Dark</Text>
              </TouchableOpacity>
            </View>
          </View>
          
          {/* Change Background Color (Android) */}
          {Platform.OS === 'android' && (
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Background Color</Text>
              <View style={styles.row}>
                {['#007AFF', '#FF3B30', '#34C759', '#000000'].map(color => (
                  <TouchableOpacity
                    key={color}
                    style={[styles.colorBox, { backgroundColor: color }]}
                    onPress={() => setBackgroundColor(color)}
                  />
                ))}
              </View>
            </View>
          )}
        </View>
      </SafeAreaView>
    </>
  );
};

// Screen-specific StatusBar
const ScreenWithCustomStatusBar = () => {
  return (
    <View style={styles.screen}>
      <StatusBar
        barStyle="light-content"
        backgroundColor="#FF3B30"
      />
      <View style={[styles.header, { backgroundColor: '#FF3B30' }]}>
        <Text style={styles.headerText}>Custom StatusBar Screen</Text>
      </View>
      <View style={styles.screenContent}>
        <Text>This screen has its own StatusBar configuration</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    padding: 20,
    backgroundColor: 'white',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    marginTop: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  button: {
    backgroundColor: '#333',
    padding: 15,
    borderRadius: 8,
    alignItems: 'center',
    marginBottom: 20,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  section: {
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 10,
  },
  row: {
    flexDirection: 'row',
    gap: 10,
  },
  chip: {
    paddingHorizontal: 15,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: '#f0f0f0',
  },
  activeChip: {
    backgroundColor: '#007AFF',
  },
  chipText: {
    fontSize: 14,
    color: '#333',
  },
  colorBox: {
    width: 40,
    height: 40,
    borderRadius: 20,
    borderWidth: 2,
    borderColor: 'white',
  },
  screen: {
    flex: 1,
  },
  header: {
    paddingTop: 50,
    paddingBottom: 20,
    paddingHorizontal: 20,
  },
  headerText: {
    color: 'white',
    fontSize: 20,
    fontWeight: 'bold',
  },
  screenContent: {
    flex: 1,
    padding: 20,
    backgroundColor: '#f5f5f5',
  },
});</code></pre>
                    </div>

                    <div class="warning-box">
                        <h4><i class="fas fa-exclamation-triangle"></i> Platform Differences</h4>
                        <p>• backgroundColor only works on Android<br>
                        • iOS uses the background color of the view behind StatusBar<br>
                        • translucent property is Android-only<br>
                        • Always test on both platforms<br>
                        • Consider using SafeAreaView with StatusBar</p>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> StatusBar Quiz</h3>
                        <p class="quiz-question">Which prop controls text color in the status bar?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                textColor
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                barStyle
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                style
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                color
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-bars"></i> Project: Dynamic StatusBar</h3>
                        <p class="project-description">Create a dynamic status bar system:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="status1">
                                <label for="status1">Create StatusBar manager hook</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="status2">
                                <label for="status2">Implement per-screen configuration</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="status3">
                                <label for="status3">Add theme-based styling</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="status4">
                                <label for="status4">Handle orientation changes</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="status5">
                                <label for="status5">Create immersive mode toggle</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'stylesheet': {
        title: 'StyleSheet API',
        content: `
                    <h1><i class="fas fa-palette"></i> StyleSheet API</h1>
                    
                    <p>The StyleSheet API is the foundation of styling in React Native. It provides an abstraction similar to CSS stylesheets and optimizes your styles for better performance.</p>

                    <h2><i class="fas fa-paint-brush"></i> Creating Styles</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Basic StyleSheet</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import { View, Text, StyleSheet, ScrollView } from 'react-native';

const StyleSheetExample = () => {
  return (
    <ScrollView style={styles.container}>
      {/* Basic Styling */}
      <View style={styles.card}>
        <Text style={styles.title}>StyleSheet Basics</Text>
        <Text style={styles.description}>
          StyleSheet.create optimizes your styles by creating style IDs
        </Text>
      </View>

      {/* Combining Styles */}
      <View style={[styles.card, styles.primaryCard]}>
        <Text style={[styles.title, styles.whiteText]}>
          Combined Styles
        </Text>
        <Text style={[styles.description, styles.whiteText]}>
          You can combine multiple styles using arrays
        </Text>
      </View>

      {/* Conditional Styling */}
      <View style={[
        styles.card,
        false && styles.disabledCard
      ]}>
        <Text style={styles.title}>Conditional Styles</Text>
        <Text style={styles.description}>
          Apply styles conditionally based on state
        </Text>
      </View>

      {/* Dynamic Styling */}
      {[1, 2, 3].map((item) => (
        <View
          key={item}
          style={[
            styles.dynamicBox,
            { backgroundColor: \`hsl(\${item * 60}, 70%, 50%)\` }
          ]}
        >
          <Text style={styles.boxText}>Dynamic Box {item}</Text>
        </View>
      ))}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  card: {
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 20,
    marginHorizontal: 16,
    marginVertical: 8,
    // Shadows for iOS
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    // Shadow for Android
    elevation: 5,
  },
  primaryCard: {
    backgroundColor: '#007AFF',
  },
  disabledCard: {
    opacity: 0.5,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#333',
  },
  description: {
    fontSize: 16,
    lineHeight: 24,
    color: '#666',
  },
  whiteText: {
    color: 'white',
  },
  dynamicBox: {
    height: 80,
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  boxText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-code"></i> Advanced StyleSheet Features</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Advanced Techniques</span>
                        </div>
                        <pre><code class="language-typescript">import { StyleSheet, Platform, Dimensions } from 'react-native';

const { width, height } = Dimensions.get('window');

// StyleSheet composition
const baseStyles = StyleSheet.create({
  text: {
    fontSize: 16,
    lineHeight: 24,
  },
  container: {
    padding: 16,
  },
});

const themeStyles = StyleSheet.create({
  primaryText: {
    ...baseStyles.text,
    color: '#007AFF',
    fontWeight: '600',
  },
  secondaryText: {
    ...baseStyles.text,
    color: '#666',
  },
  card: {
    ...baseStyles.container,
    backgroundColor: 'white',
    borderRadius: 8,
  },
});

// Platform-specific styles
const platformStyles = StyleSheet.create({
  button: {
    padding: 12,
    borderRadius: Platform.select({
      ios: 8,
      android: 4,
    }),
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 4,
      },
    }),
  },
});

// Responsive styles
const responsiveStyles = StyleSheet.create({
  container: {
    width: width > 768 ? '80%' : '100%',
    alignSelf: 'center',
  },
  grid: {
    flexDirection: width > 768 ? 'row' : 'column',
    flexWrap: 'wrap',
  },
  gridItem: {
    width: width > 768 ? '48%' : '100%',
    marginBottom: 16,
  },
});

// StyleSheet utilities
const spacing = {
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32,
};

const colors = {
  primary: '#007AFF',
  secondary: '#5856D6',
  success: '#34C759',
  warning: '#FF9500',
  danger: '#FF3B30',
  text: '#333',
  textSecondary: '#666',
  border: '#E5E5E5',
  background: '#F5F5F5',
};

// Utility function for consistent spacing
const createSpacingStyles = () => {
  const spacingStyles = {};
  
  Object.entries(spacing).forEach(([key, value]) => {
    spacingStyles[\`p\${key}\`] = { padding: value };
    spacingStyles[\`pt\${key}\`] = { paddingTop: value };
    spacingStyles[\`pb\${key}\`] = { paddingBottom: value };
    spacingStyles[\`pl\${key}\`] = { paddingLeft: value };
    spacingStyles[\`pr\${key}\`] = { paddingRight: value };
    spacingStyles[\`px\${key}\`] = { paddingHorizontal: value };
    spacingStyles[\`py\${key}\`] = { paddingVertical: value };
    
    spacingStyles[\`m\${key}\`] = { margin: value };
    spacingStyles[\`mt\${key}\`] = { marginTop: value };
    spacingStyles[\`mb\${key}\`] = { marginBottom: value };
    spacingStyles[\`ml\${key}\`] = { marginLeft: value };
    spacingStyles[\`mr\${key}\`] = { marginRight: value };
    spacingStyles[\`mx\${key}\`] = { marginHorizontal: value };
    spacingStyles[\`my\${key}\`] = { marginVertical: value };
  });
  
  return StyleSheet.create(spacingStyles);
};

const utilityStyles = createSpacingStyles();</code></pre>
                    </div>

                    <h2><i class="fas fa-layer-group"></i> StyleSheet Methods</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">StyleSheet API Methods</span>
                        </div>
                        <pre><code class="language-typescript">// StyleSheet.create()
// Creates an optimized stylesheet object
const styles = StyleSheet.create({
  container: { flex: 1 }
});

// StyleSheet.flatten()
// Flattens an array of styles into a single style object
const flatStyle = StyleSheet.flatten([
  styles.container,
  { backgroundColor: 'blue' },
  condition && { opacity: 0.5 }
]);

// StyleSheet.absoluteFillObject
// Predefined style for absolute positioning that fills parent
const overlayStyle = {
  ...StyleSheet.absoluteFillObject,
  backgroundColor: 'rgba(0,0,0,0.5)',
};

// StyleSheet.absoluteFill
// Same as absoluteFillObject but as a registered style
const styles2 = StyleSheet.create({
  overlay: StyleSheet.absoluteFill,
});

// StyleSheet.hairlineWidth
// The width of a thin line on the platform
const styles3 = StyleSheet.create({
  separator: {
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: '#E5E5E5',
  }
});

// StyleSheet.compose()
// Combines two styles, with the latter taking precedence
const composedStyle = StyleSheet.compose(
  styles.baseText,
  styles.boldText
);</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4><i class="fas fa-lightbulb"></i> StyleSheet Best Practices</h4>
                        <p>• Always use StyleSheet.create() for better performance<br>
                        • Keep styles close to components that use them<br>
                        • Create reusable style utilities for consistency<br>
                        • Use style composition to avoid duplication<br>
                        • Prefer named styles over inline styles</p>
                    </div>

                    <h2><i class="fas fa-magic"></i> Dynamic Theming</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Theme System</span>
                        </div>
                        <pre><code class="language-typescript">import React, { createContext, useContext, useState } from 'react';
import { StyleSheet } from 'react-native';

// Theme definitions
const lightTheme = {
  colors: {
    primary: '#007AFF',
    background: '#FFFFFF',
    surface: '#F5F5F5',
    text: '#000000',
    textSecondary: '#666666',
    border: '#E5E5E5',
  },
};

const darkTheme = {
  colors: {
    primary: '#0A84FF',
    background: '#000000',
    surface: '#1C1C1E',
    text: '#FFFFFF',
    textSecondary: '#999999',
    border: '#38383A',
  },
};

// Theme context
const ThemeContext = createContext(lightTheme);

// Custom hook to use theme
export const useTheme = () => useContext(ThemeContext);

// Themed StyleSheet creator
export const createThemedStyles = (themeStyles) => {
  return (theme) => StyleSheet.create(
    typeof themeStyles === 'function' 
      ? themeStyles(theme) 
      : themeStyles
  );
};

// Usage example
const useStyles = createThemedStyles((theme) => ({
  container: {
    flex: 1,
    backgroundColor: theme.colors.background,
  },
  text: {
    color: theme.colors.text,
    fontSize: 16,
  },
  card: {
    backgroundColor: theme.colors.surface,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 8,
    padding: 16,
  },
}));

// Component using themed styles
const ThemedComponent = () => {
  const theme = useTheme();
  const styles = useStyles(theme);
  
  return (
    <View style={styles.container}>
      <View style={styles.card}>
        <Text style={styles.text}>Themed Component</Text>
      </View>
    </View>
  );
};</code></pre>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> StyleSheet Knowledge Check</h3>
                        <p class="quiz-question">What is the main benefit of using StyleSheet.create()?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                It makes styles look better
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                It optimizes styles by creating IDs instead of objects
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                It's required for styles to work
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                It adds CSS support
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-paint-roller"></i> Project: Style System</h3>
                        <p class="project-description">Build a comprehensive style system:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="style1">
                                <label for="style1">Create typography scale system</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="style2">
                                <label for="style2">Build color palette with semantic naming</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="style3">
                                <label for="style3">Implement spacing utilities</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="style4">
                                <label for="style4">Create shadow presets for elevation</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="style5">
                                <label for="style5">Build responsive breakpoint system</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'flexbox': {
        title: 'Flexbox Layout',
        content: `
                    <h1><i class="fas fa-th"></i> Flexbox Layout in React Native</h1>
                    
                    <p>Flexbox is the primary layout system in React Native. Understanding flexbox is crucial for building responsive layouts that work across different screen sizes.</p>

                    <h2><i class="fas fa-arrows-alt"></i> Flex Container Properties</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Flex Direction & Wrap</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import { View, Text, ScrollView, StyleSheet } from 'react-native';

const FlexboxExample = () => {
  return (
    <ScrollView style={styles.container}>
      {/* Flex Direction */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>flexDirection</Text>
        
        {/* Row (default in web, but column is default in RN) */}
        <View style={[styles.flexContainer, { flexDirection: 'row' }]}>
          <View style={[styles.box, styles.box1]}><Text>1</Text></View>
          <View style={[styles.box, styles.box2]}><Text>2</Text></View>
          <View style={[styles.box, styles.box3]}><Text>3</Text></View>
        </View>
        
        {/* Column (default in React Native) */}
        <View style={[styles.flexContainer, { flexDirection: 'column' }]}>
          <View style={[styles.box, styles.box1]}><Text>1</Text></View>
          <View style={[styles.box, styles.box2]}><Text>2</Text></View>
          <View style={[styles.box, styles.box3]}><Text>3</Text></View>
        </View>
      </View>

      {/* Justify Content */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>justifyContent</Text>
        
        {['flex-start', 'center', 'flex-end', 'space-between', 'space-around', 'space-evenly'].map(value => (
          <View key={value}>
            <Text style={styles.label}>{value}</Text>
            <View style={[styles.flexContainer, { 
              flexDirection: 'row',
              justifyContent: value 
            }]}>
              <View style={[styles.smallBox, styles.box1]} />
              <View style={[styles.smallBox, styles.box2]} />
              <View style={[styles.smallBox, styles.box3]} />
            </View>
          </View>
        ))}
      </View>

      {/* Align Items */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>alignItems</Text>
        
        {['flex-start', 'center', 'flex-end', 'stretch', 'baseline'].map(value => (
          <View key={value}>
            <Text style={styles.label}>{value}</Text>
            <View style={[styles.flexContainer, styles.tallContainer, { 
              flexDirection: 'row',
              alignItems: value 
            }]}>
              <View style={[styles.variableBox, styles.box1, { height: 40 }]} />
              <View style={[styles.variableBox, styles.box2, { height: 60 }]} />
              <View style={[styles.variableBox, styles.box3, { height: 30 }]} />
            </View>
          </View>
        ))}
      </View>

      {/* Flex Wrap */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>flexWrap</Text>
        
        <Text style={styles.label}>nowrap (default)</Text>
        <View style={[styles.flexContainer, { 
          flexDirection: 'row',
          flexWrap: 'nowrap' 
        }]}>
          {[1,2,3,4,5,6,7,8].map(i => (
            <View key={i} style={[styles.wrapBox, { backgroundColor: \`hsl(\${i * 45}, 70%, 60%)\` }]}>
              <Text>{i}</Text>
            </View>
          ))}
        </View>
        
        <Text style={styles.label}>wrap</Text>
        <View style={[styles.flexContainer, { 
          flexDirection: 'row',
          flexWrap: 'wrap' 
        }]}>
          {[1,2,3,4,5,6,7,8].map(i => (
            <View key={i} style={[styles.wrapBox, { backgroundColor: \`hsl(\${i * 45}, 70%, 60%)\` }]}>
              <Text>{i}</Text>
            </View>
          ))}
        </View>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  section: {
    padding: 16,
    marginBottom: 16,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 16,
    color: '#333',
  },
  label: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
    marginTop: 8,
  },
  flexContainer: {
    backgroundColor: 'white',
    padding: 8,
    marginBottom: 8,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  tallContainer: {
    height: 100,
  },
  box: {
    width: 50,
    height: 50,
    justifyContent: 'center',
    alignItems: 'center',
  },
  smallBox: {
    width: 40,
    height: 40,
  },
  variableBox: {
    width: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  wrapBox: {
    width: 60,
    height: 60,
    margin: 4,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 4,
  },
  box1: { backgroundColor: '#FF6B6B' },
  box2: { backgroundColor: '#4ECDC4' },
  box3: { backgroundColor: '#45B7D1' },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-expand-arrows-alt"></i> Flex Item Properties</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Flex, Grow, Shrink, Basis</span>
                        </div>
                        <pre><code class="language-typescript">const FlexItemProperties = () => {
  return (
    <ScrollView style={styles.container}>
      {/* Flex Property */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>flex</Text>
        <View style={styles.flexContainer}>
          <View style={[styles.flexItem, { flex: 1, backgroundColor: '#FF6B6B' }]}>
            <Text>flex: 1</Text>
          </View>
          <View style={[styles.flexItem, { flex: 2, backgroundColor: '#4ECDC4' }]}>
            <Text>flex: 2</Text>
          </View>
          <View style={[styles.flexItem, { flex: 1, backgroundColor: '#45B7D1' }]}>
            <Text>flex: 1</Text>
          </View>
        </View>
      </View>

      {/* Align Self */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>alignSelf</Text>
        <View style={[styles.flexContainer, { height: 150, alignItems: 'center' }]}>
          <View style={[styles.alignBox, { alignSelf: 'flex-start', backgroundColor: '#FF6B6B' }]}>
            <Text>flex-start</Text>
          </View>
          <View style={[styles.alignBox, { alignSelf: 'center', backgroundColor: '#4ECDC4' }]}>
            <Text>center</Text>
          </View>
          <View style={[styles.alignBox, { alignSelf: 'flex-end', backgroundColor: '#45B7D1' }]}>
            <Text>flex-end</Text>
          </View>
          <View style={[styles.alignBox, { alignSelf: 'stretch', backgroundColor: '#96CEB4' }]}>
            <Text>stretch</Text>
          </View>
        </View>
      </View>

      {/* Position */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>position</Text>
        <View style={[styles.flexContainer, { height: 200 }]}>
          <View style={[styles.posBox, { backgroundColor: '#FF6B6B' }]}>
            <Text>relative</Text>
          </View>
          <View style={[styles.posBox, { 
            backgroundColor: '#4ECDC4',
            position: 'absolute',
            top: 20,
            right: 20,
          }]}>
            <Text>absolute</Text>
          </View>
          <View style={[styles.posBox, { 
            backgroundColor: '#45B7D1',
            position: 'absolute',
            bottom: 20,
            left: 20,
          }]}>
            <Text>absolute</Text>
          </View>
        </View>
      </View>

      {/* Flex Grow & Shrink */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>flexGrow & flexShrink</Text>
        <View style={[styles.flexContainer, { flexDirection: 'row' }]}>
          <View style={[styles.growBox, { 
            flexGrow: 1,
            backgroundColor: '#FF6B6B' 
          }]}>
            <Text>grow: 1</Text>
          </View>
          <View style={[styles.growBox, { 
            flexGrow: 0,
            backgroundColor: '#4ECDC4' 
          }]}>
            <Text>grow: 0</Text>
          </View>
          <View style={[styles.growBox, { 
            flexShrink: 1,
            backgroundColor: '#45B7D1' 
          }]}>
            <Text>shrink: 1</Text>
          </View>
        </View>
      </View>
    </ScrollView>
  );
};

const additionalStyles = StyleSheet.create({
  flexItem: {
    padding: 16,
    justifyContent: 'center',
    alignItems: 'center',
  },
  alignBox: {
    padding: 10,
    margin: 5,
    borderRadius: 4,
  },
  posBox: {
    width: 80,
    height: 80,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 4,
  },
  growBox: {
    padding: 10,
    minWidth: 80,
    justifyContent: 'center',
    alignItems: 'center',
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-ruler-combined"></i> Common Layout Patterns</h2>
                    
                    <div class="playground">
                        <div class="playground-header">
                            <h3><i class="fas fa-play-circle"></i> Interactive Flexbox Playground</h3>
                            <div class="playground-tabs">
                                <button class="playground-tab active" onclick="switchPlaygroundTab(this, 'code')">Code</button>
                                <button class="playground-tab" onclick="switchPlaygroundTab(this, 'preview')">Preview</button>
                            </div>
                        </div>
                        <div class="playground-content">
                            <div class="playground-editor" id="playground-code">
                                <textarea class="editor-textarea">
import React, { useState } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';

const FlexboxPlayground = () => {
  const [flexDirection, setFlexDirection] = useState('row');
  const [justifyContent, setJustifyContent] = useState('flex-start');
  const [alignItems, setAlignItems] = useState('flex-start');

  return (
    <View style={styles.container}>
      <View style={styles.controls}>
        <Text style={styles.controlTitle}>Flex Direction:</Text>
        <View style={styles.buttonGroup}>
          {['row', 'column'].map(dir => (
            <TouchableOpacity
              key={dir}
              style={[styles.button, flexDirection === dir && styles.activeButton]}
              onPress={() => setFlexDirection(dir)}
            >
              <Text style={styles.buttonText}>{dir}</Text>
            </TouchableOpacity>
          ))}
        </View>

        <Text style={styles.controlTitle}>Justify Content:</Text>
        <View style={styles.buttonGroup}>
          {['flex-start', 'center', 'flex-end', 'space-between'].map(val => (
            <TouchableOpacity
              key={val}
              style={[styles.button, justifyContent === val && styles.activeButton]}
              onPress={() => setJustifyContent(val)}
            >
              <Text style={styles.buttonText}>{val}</Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      <View style={[
        styles.playground,
        {
          flexDirection,
          justifyContent,
          alignItems,
        }
      ]}>
        <View style={[styles.item, { backgroundColor: '#FF6B6B' }]}>
          <Text style={styles.itemText}>1</Text>
        </View>
        <View style={[styles.item, { backgroundColor: '#4ECDC4' }]}>
          <Text style={styles.itemText}>2</Text>
        </View>
        <View style={[styles.item, { backgroundColor: '#45B7D1' }]}>
          <Text style={styles.itemText}>3</Text>
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  controls: {
    marginBottom: 20,
  },
  controlTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginTop: 10,
    marginBottom: 5,
  },
  buttonGroup: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 5,
  },
  button: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    backgroundColor: '#e0e0e0',
    borderRadius: 4,
    marginRight: 5,
    marginBottom: 5,
  },
  activeButton: {
    backgroundColor: '#007AFF',
  },
  buttonText: {
    fontSize: 12,
  },
  playground: {
    flex: 1,
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    padding: 10,
    borderWidth: 2,
    borderColor: '#007AFF',
  },
  item: {
    width: 60,
    height: 60,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 4,
    margin: 5,
  },
  itemText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
  },
});</textarea>
                            </div>
                            <div class="playground-preview" id="playground-preview" style="display: none;">
                                <div style="flex: 1; padding: 16px;">
                                    <div style="margin-bottom: 20px;">
                                        <div style="font-size: 16px; font-weight: 600; margin-bottom: 5px;">Flex Direction:</div>
                                        <div style="display: flex; gap: 5px;">
                                            <button style="padding: 6px 12px; background: #007AFF; color: white; border: none; border-radius: 4px;">row</button>
                                            <button style="padding: 6px 12px; background: #e0e0e0; border: none; border-radius: 4px;">column</button>
                                        </div>
                                    </div>
                                    <div style="flex: 1; background: #f0f0f0; border-radius: 8px; padding: 10px; border: 2px solid #007AFF; display: flex; flex-direction: row;">
                                        <div style="width: 60px; height: 60px; background: #FF6B6B; display: flex; align-items: center; justify-content: center; border-radius: 4px; margin: 5px;">
                                            <span style="color: white; font-size: 18px; font-weight: bold;">1</span>
                                        </div>
                                        <div style="width: 60px; height: 60px; background: #4ECDC4; display: flex; align-items: center; justify-content: center; border-radius: 4px; margin: 5px;">
                                            <span style="color: white; font-size: 18px; font-weight: bold;">2</span>
                                        </div>
                                        <div style="width: 60px; height: 60px; background: #45B7D1; display: flex; align-items: center; justify-content: center; border-radius: 4px; margin: 5px;">
                                            <span style="color: white; font-size: 18px; font-weight: bold;">3</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="tip-box">
                        <h4><i class="fas fa-lightbulb"></i> Flexbox Tips</h4>
                        <p>• Default flexDirection in React Native is 'column' (not 'row' like web)<br>
                        • Use flex: 1 to make a component expand to fill available space<br>
                        • alignItems affects cross-axis, justifyContent affects main axis<br>
                        • position: 'absolute' removes item from flex flow<br>
                        • Test layouts on different screen sizes</p>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Flexbox Quiz</h3>
                        <p class="quiz-question">What is the default flex direction in React Native?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                row
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                column
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                row-reverse
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                column-reverse
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-layer-group"></i> Project: Layout Components</h3>
                        <p class="project-description">Build common layout components:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="flex1">
                                <label for="flex1">Create a responsive grid component</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="flex2">
                                <label for="flex2">Build a sticky header with scrolling content</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="flex3">
                                <label for="flex3">Implement a tab bar layout</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="flex4">
                                <label for="flex4">Create a card layout with equal heights</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="flex5">
                                <label for="flex5">Build a masonry layout</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'responsive': {
        title: 'Responsive Design',
        content: `
                    <h1><i class="fas fa-mobile-alt"></i> Responsive Design in React Native</h1>
                    
                    <p>Creating responsive layouts that work across different devices and orientations is essential for a great user experience. Let's explore the tools and techniques for responsive design.</p>

                    <h2><i class="fas fa-ruler"></i> Dimensions API</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Using Dimensions</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-typescript">import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  Dimensions,
  StyleSheet,
  ScrollView,
} from 'react-native';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

const ResponsiveExample = () => {
  const [dimensions, setDimensions] = useState({
    window: Dimensions.get('window'),
    screen: Dimensions.get('screen'),
  });

  useEffect(() => {
    const subscription = Dimensions.addEventListener('change', ({ window, screen }) => {
      setDimensions({ window, screen });
    });
    return () => subscription?.remove();
  }, []);

  const { window } = dimensions;
  const isTablet = window.width >= 768;
  const orientation = window.width > window.height ? 'landscape' : 'portrait';

  return (
    <ScrollView style={styles.container}>
      <View style={styles.info}>
        <Text style={styles.infoText}>
          Device: {isTablet ? 'Tablet' : 'Phone'}
        </Text>
        <Text style={styles.infoText}>
          Orientation: {orientation}
        </Text>
        <Text style={styles.infoText}>
          Window: {window.width} x {window.height}
        </Text>
      </View>

      {/* Responsive Grid */}
      <View style={[
        styles.grid,
        isTablet && styles.tabletGrid
      ]}>
        {[1, 2, 3, 4, 5, 6].map(item => (
          <View
            key={item}
            style={[
              styles.gridItem,
              { width: isTablet ? '31%' : '48%' }
            ]}
          >
            <Text style={styles.gridText}>Item {item}</Text>
          </View>
        ))}
      </View>

      {/* Responsive Layout */}
      <View style={[
        styles.layout,
        orientation === 'landscape' && styles.landscapeLayout
      ]}>
        <View style={[
          styles.sidebar,
          orientation === 'landscape' ? { width: '30%' } : { width: '100%' }
        ]}>
          <Text style={styles.sectionTitle}>Sidebar</Text>
        </View>
        <View style={[
          styles.content,
          orientation === 'landscape' ? { width: '70%' } : { width: '100%' }
        ]}>
          <Text style={styles.sectionTitle}>Content</Text>
        </View>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  info: {
    backgroundColor: 'white',
    padding: 16,
    margin: 16,
    borderRadius: 8,
  },
  infoText: {
    fontSize: 16,
    marginBottom: 4,
    color: '#333',
  },
  grid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    padding: 16,
    justifyContent: 'space-between',
  },
  tabletGrid: {
    paddingHorizontal: 32,
  },
  gridItem: {
    backgroundColor: '#007AFF',
    padding: 20,
    marginBottom: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  gridText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  layout: {
    padding: 16,
  },
  landscapeLayout: {
    flexDirection: 'row',
  },
  sidebar: {
    backgroundColor: '#FF6B6B',
    padding: 20,
    marginBottom: 16,
    borderRadius: 8,
    minHeight: 100,
  },
  content: {
    backgroundColor: '#4ECDC4',
    padding: 20,
    borderRadius: 8,
    minHeight: 200,
  },
  sectionTitle: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-percentage"></i> Percentage-Based Layouts</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Responsive Units</span>
                        </div>
                        <pre><code class="language-typescript">import { Dimensions, PixelRatio } from 'react-native';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

// Responsive font sizes
const scale = SCREEN_WIDTH / 375; // Based on iPhone 6/7/8 width

export const normalize = (size: number) => {
  const newSize = size * scale;
  return Math.round(PixelRatio.roundToNearestPixel(newSize));
};

// Responsive dimensions
export const wp = (percentage: number) => {
  return (percentage * SCREEN_WIDTH) / 100;
};

export const hp = (percentage: number) => {
  return (percentage * SCREEN_HEIGHT) / 100;
};

// Usage example
const ResponsiveComponent = () => {
  return (
    <View style={styles.container}>
      {/* Width: 90% of screen */}
      <View style={[styles.card, { width: wp(90) }]}>
        <Text style={[styles.title, { fontSize: normalize(18) }]}>
          Responsive Card
        </Text>
      </View>

      {/* Height: 25% of screen */}
      <View style={[styles.banner, { height: hp(25) }]}>
        <Text style={styles.bannerText}>25% Height Banner</Text>
      </View>

      {/* Responsive spacing */}
      <View style={styles.row}>
        <View style={[styles.column, { marginRight: wp(2) }]} />
        <View style={styles.column} />
      </View>
    </View>
  );
};

// Responsive styles with breakpoints
const createResponsiveStyles = () => {
  const isSmall = SCREEN_WIDTH < 375;
  const isMedium = SCREEN_WIDTH >= 375 && SCREEN_WIDTH < 768;
  const isLarge = SCREEN_WIDTH >= 768;

  return StyleSheet.create({
    container: {
      padding: isLarge ? 32 : isMedium ? 20 : 16,
    },
    text: {
      fontSize: isLarge ? 18 : isMedium ? 16 : 14,
      lineHeight: isLarge ? 28 : isMedium ? 24 : 20,
    },
    button: {
      paddingVertical: isLarge ? 16 : 12,
      paddingHorizontal: isLarge ? 32 : 24,
    },
  });
};</code></pre>
                    </div>

                    <h2><i class="fas fa-sync-alt"></i> Orientation Handling</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Orientation Changes</span>
                        </div>
                        <pre><code class="language-typescript">import React, { useState, useEffect } from 'react';
import { View, Text, Dimensions, StyleSheet } from 'react-native';

// Custom hook for orientation
export const useOrientation = () => {
  const [orientation, setOrientation] = useState(
    Dimensions.get('window').width > Dimensions.get('window').height
      ? 'landscape'
      : 'portrait'
  );

  useEffect(() => {
    const updateOrientation = ({ window }) => {
      setOrientation(window.width > window.height ? 'landscape' : 'portrait');
    };

    const subscription = Dimensions.addEventListener('change', updateOrientation);
    return () => subscription?.remove();
  }, []);

  return orientation;
};

// Orientation-aware component
const OrientationAwareLayout = () => {
  const orientation = useOrientation();

  return (
    <View style={[
      styles.container,
      orientation === 'landscape' && styles.landscapeContainer
    ]}>
      {orientation === 'portrait' ? (
        // Portrait layout
        <View style={styles.portraitLayout}>
          <View style={styles.header}>
            <Text style={styles.headerText}>Header</Text>
          </View>
          <View style={styles.portraitContent}>
            <Text>Portrait Content</Text>
          </View>
          <View style={styles.footer}>
            <Text style={styles.footerText}>Footer</Text>
          </View>
        </View>
      ) : (
        // Landscape layout
        <View style={styles.landscapeLayout}>
          <View style={styles.landscapeSidebar}>
            <Text style={styles.sidebarText}>Sidebar</Text>
          </View>
          <View style={styles.landscapeMain}>
            <View style={styles.landscapeHeader}>
              <Text style={styles.headerText}>Header</Text>
            </View>
            <View style={styles.landscapeContent}>
              <Text>Landscape Content</Text>
            </View>
          </View>
        </View>
      )}
    </View>
  );
};

const orientationStyles = StyleSheet.create({
  container: {
    flex: 1,
  },
  landscapeContainer: {
    flexDirection: 'row',
  },
  portraitLayout: {
    flex: 1,
  },
  landscapeLayout: {
    flex: 1,
    flexDirection: 'row',
  },
  header: {
    height: 60,
    backgroundColor: '#007AFF',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
  },
  portraitContent: {
    flex: 1,
    padding: 20,
    backgroundColor: '#f5f5f5',
  },
  footer: {
    height: 50,
    backgroundColor: '#333',
    justifyContent: 'center',
    alignItems: 'center',
  },
  footerText: {
    color: 'white',
    fontSize: 14,
  },
  landscapeSidebar: {
    width: 200,
    backgroundColor: '#2c3e50',
    padding: 20,
  },
  sidebarText: {
    color: 'white',
    fontSize: 16,
  },
  landscapeMain: {
    flex: 1,
  },
  landscapeHeader: {
    height: 50,
    backgroundColor: '#007AFF',
    justifyContent: 'center',
    paddingHorizontal: 20,
  },
  landscapeContent: {
    flex: 1,
    padding: 20,
    backgroundColor: '#f5f5f5',
  },
});</code></pre>
                    </div>

                    <div class="warning-box">
                        <h4><i class="fas fa-exclamation-triangle"></i> Responsive Design Pitfalls</h4>
                        <p>• Don't hardcode dimensions - use percentages or flex<br>
                        • Test on actual devices, not just simulators<br>
                        • Consider safe areas on modern devices<br>
                        • Handle keyboard appearance in forms<br>
                        • Test with different font sizes (accessibility)</p>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Responsive Design Quiz</h3>
                        <p class="quiz-question">What's the best way to create responsive font sizes?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Always use fixed pixel values
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                Scale based on device dimensions
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Use the same size for all devices
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Only use percentage values
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-th-large"></i> Project: Responsive Dashboard</h3>
                        <p class="project-description">Build a fully responsive dashboard:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="resp1">
                                <label for="resp1">Create adaptive grid layout</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="resp2">
                                <label for="resp2">Implement orientation-specific layouts</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="resp3">
                                <label for="resp3">Add responsive typography system</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="resp4">
                                <label for="resp4">Handle safe areas properly</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="resp5">
                                <label for="resp5">Create breakpoint-based components</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'platform-specific': {
        title: 'Platform-Specific Code',
        content: `
                    <h1><i class="fas fa-code-branch"></i> Platform-Specific Code</h1>
                    
                    <p>React Native allows you to write platform-specific code when you need to customize functionality or appearance for iOS and Android separately.</p>

                    <h2><i class="fas fa-mobile"></i> Platform Module</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Using Platform API</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import {
  Platform,
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  StatusBar,
} from 'react-native';

const PlatformExample = () => {
  return (
    <SafeAreaView style={styles.container}>
      <StatusBar
        barStyle={Platform.OS === 'ios' ? 'dark-content' : 'light-content'}
        backgroundColor={Platform.OS === 'android' ? '#6200EE' : undefined}
      />
      
      <View style={styles.header}>
        <Text style={styles.headerText}>
          Platform: {Platform.OS}
        </Text>
        <Text style={styles.subText}>
          Version: {Platform.Version}
        </Text>
        {Platform.OS === 'ios' && (
          <Text style={styles.subText}>
            iOS Specific Feature
          </Text>
        )}
      </View>

      {/* Platform.select() method */}
      <View style={styles.card}>
        <Text style={styles.cardTitle}>
          {Platform.select({
            ios: 'iOS Card Design',
            android: 'Material Design Card',
            default: 'Default Card',
          })}
        </Text>
        
        <View style={platformStyles.button}>
          <Text style={platformStyles.buttonText}>
            Platform Button
          </Text>
        </View>
      </View>

      {/* Conditional rendering */}
      {Platform.OS === 'android' ? (
        <View style={styles.androidSpecific}>
          <Text>Android-only component</Text>
        </View>
      ) : (
        <View style={styles.iosSpecific}>
          <Text>iOS-only component</Text>
        </View>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Platform.select({
      ios: '#f0f0f0',
      android: '#fafafa',
    }),
  },
  header: {
    padding: 20,
    backgroundColor: Platform.select({
      ios: '#007AFF',
      android: '#6200EE',
    }),
  },
  headerText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: 'white',
  },
  subText: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.8)',
    marginTop: 4,
  },
  card: {
    margin: 16,
    padding: 16,
    backgroundColor: 'white',
    borderRadius: Platform.OS === 'ios' ? 12 : 4,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 4,
      },
    }),
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: Platform.select({
      ios: '600',
      android: 'bold',
    }),
    marginBottom: 12,
  },
  androidSpecific: {
    margin: 16,
    padding: 16,
    backgroundColor: '#4CAF50',
    borderRadius: 4,
  },
  iosSpecific: {
    margin: 16,
    padding: 16,
    backgroundColor: '#007AFF',
    borderRadius: 12,
  },
});

// Platform-specific styles
const platformStyles = StyleSheet.create({
  button: Platform.select({
    ios: {
      backgroundColor: '#007AFF',
      paddingVertical: 12,
      paddingHorizontal: 24,
      borderRadius: 8,
      alignItems: 'center',
    },
    android: {
      backgroundColor: '#6200EE',
      paddingVertical: 8,
      paddingHorizontal: 16,
      borderRadius: 4,
      alignItems: 'center',
      elevation: 2,
    },
  }),
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: Platform.OS === 'ios' ? '600' : 'normal',
    textTransform: Platform.OS === 'android' ? 'uppercase' : 'none',
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-file-code"></i> Platform-Specific Files</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Button.ios.tsx</span>
                        </div>
                        <pre><code class="language-typescript">// Button.ios.tsx
import React from 'react';
import { TouchableOpacity, Text, StyleSheet } from 'react-native';

interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary';
}

export const Button: React.FC<ButtonProps> = ({ 
  title, 
  onPress, 
  variant = 'primary' 
}) => {
  return (
    <TouchableOpacity
      style={[styles.button, styles[variant]]}
      onPress={onPress}
      activeOpacity={0.7}
    >
      <Text style={[styles.text, styles[\`\${variant}Text\`]]}>
        {title}
      </Text>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  button: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  primary: {
    backgroundColor: '#007AFF',
  },
  secondary: {
    backgroundColor: 'transparent',
    borderWidth: 1,
    borderColor: '#007AFF',
  },
  text: {
    fontSize: 17,
    fontWeight: '600',
  },
  primaryText: {
    color: 'white',
  },
  secondaryText: {
    color: '#007AFF',
  },
});</code></pre>
                    </div>

                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Button.android.tsx</span>
                        </div>
                        <pre><code class="language-typescript">// Button.android.tsx
import React from 'react';
import { TouchableNativeFeedback, View, Text, StyleSheet } from 'react-native';

interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary';
}

export const Button: React.FC<ButtonProps> = ({ 
  title, 
  onPress, 
  variant = 'primary' 
}) => {
  return (
    <TouchableNativeFeedback
      onPress={onPress}
      background={TouchableNativeFeedback.Ripple(
        variant === 'primary' ? 'rgba(255, 255, 255, 0.3)' : 'rgba(98, 0, 238, 0.3)',
        false
      )}
    >
      <View style={[styles.button, styles[variant]]}>
        <Text style={[styles.text, styles[\`\${variant}Text\`]]}>
          {title.toUpperCase()}
        </Text>
      </View>
    </TouchableNativeFeedback>
  );
};

const styles = StyleSheet.create({
  button: {
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 4,
    alignItems: 'center',
    justifyContent: 'center',
    elevation: 2,
    minHeight: 36,
  },
  primary: {
    backgroundColor: '#6200EE',
  },
  secondary: {
    backgroundColor: 'white',
    borderWidth: 1,
    borderColor: '#6200EE',
    elevation: 0,
  },
  text: {
    fontSize: 14,
    fontWeight: '500',
    letterSpacing: 1.25,
  },
  primaryText: {
    color: 'white',
  },
  secondaryText: {
    color: '#6200EE',
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-cogs"></i> Platform-Specific Features</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Native Features</span>
                        </div>
                        <pre><code class="language-typescript">import {
  Platform,
  PermissionsAndroid,
  Alert,
  ActionSheetIOS,
  ToastAndroid,
} from 'react-native';

// Platform-specific permissions
const requestCameraPermission = async () => {
  if (Platform.OS === 'android') {
    try {
      const granted = await PermissionsAndroid.request(
        PermissionsAndroid.PERMISSIONS.CAMERA,
        {
          title: 'Camera Permission',
          message: 'App needs camera access',
          buttonNeutral: 'Ask Me Later',
          buttonNegative: 'Cancel',
          buttonPositive: 'OK',
        }
      );
      return granted === PermissionsAndroid.RESULTS.GRANTED;
    } catch (err) {
      console.warn(err);
      return false;
    }
  }
  // iOS permissions are handled differently
  return true;
};

// Platform-specific UI
const showActionSheet = () => {
  if (Platform.OS === 'ios') {
    ActionSheetIOS.showActionSheetWithOptions(
      {
        options: ['Cancel', 'Save', 'Delete'],
        destructiveButtonIndex: 2,
        cancelButtonIndex: 0,
      },
      (buttonIndex) => {
        if (buttonIndex === 1) {
          console.log('Save pressed');
        } else if (buttonIndex === 2) {
          console.log('Delete pressed');
        }
      }
    );
  } else {
    // Android: Use Alert or custom modal
    Alert.alert(
      'Choose Action',
      '',
      [
        { text: 'Cancel', style: 'cancel' },
        { text: 'Save', onPress: () => console.log('Save pressed') },
        { 
          text: 'Delete', 
          onPress: () => console.log('Delete pressed'),
          style: 'destructive'
        },
      ],
      { cancelable: true }
    );
  }
};

// Platform-specific feedback
const showMessage = (message: string) => {
  if (Platform.OS === 'android') {
    ToastAndroid.show(message, ToastAndroid.SHORT);
  } else {
    Alert.alert('', message);
  }
};

// Platform constants
const deviceInfo = {
  isIOS: Platform.OS === 'ios',
  isAndroid: Platform.OS === 'android',
  isTablet: Platform.isPad || (Platform.OS === 'android' && /* tablet detection */),
  version: Platform.Version,
  isIPhoneX: Platform.OS === 'ios' && /* iPhone X detection logic */,
};</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4><i class="fas fa-lightbulb"></i> Platform Tips</h4>
                        <p>• Use .ios.js and .android.js extensions for complex components<br>
                        • Platform.select() is great for small style differences<br>
                        • Test platform-specific code on actual devices<br>
                        • Consider using libraries that handle platform differences<br>
                        • Keep platform-specific code to a minimum</p>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Platform Quiz</h3>
                        <p class="quiz-question">How do you create platform-specific file implementations?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Use if statements everywhere
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                Create .ios.js and .android.js files
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Write separate apps
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Use different folders
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-mobile-alt"></i> Project: Platform-Adaptive App</h3>
                        <p class="project-description">Build platform-specific features:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="plat1">
                                <label for="plat1">Create platform-specific navigation</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="plat2">
                                <label for="plat2">Implement native action sheets</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="plat3">
                                <label for="plat3">Add platform-specific animations</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="plat4">
                                <label for="plat4">Handle permissions differently</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="plat5">
                                <label for="plat5">Create adaptive UI components</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'styled-components': {
        title: 'Styled Components',
        content: `
                    <h1><i class="fas fa-brush"></i> Styled Components in React Native</h1>
                    
                    <p>Styled Components brings the power of CSS-in-JS to React Native, allowing you to write actual CSS code to style your components with dynamic styling capabilities.</p>

                    <h2><i class="fas fa-magic"></i> Getting Started</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Installation & Basic Usage</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-typescript">// Install: npm install styled-components
// Install types: npm install @types/styled-components-react-native

import styled from 'styled-components/native';
import React from 'react';

// Basic styled components
const Container = styled.View\`
  flex: 1;
  background-color: #f5f5f5;
  padding: 20px;
  align-items: center;
  justify-content: center;
\`;

const Title = styled.Text\`
  font-size: 24px;
  font-weight: bold;
  color: #333;
  margin-bottom: 20px;
\`;

const Button = styled.TouchableOpacity\`
  background-color: #007aff;
  padding: 12px 24px;
  border-radius: 8px;
  align-items: center;
\`;

const ButtonText = styled.Text\`
  color: white;
  font-size: 16px;
  font-weight: 600;
\`;

// Using styled components
const StyledExample = () => {
  return (
    <Container>
      <Title>Styled Components</Title>
      <Button onPress={() => console.log('Pressed!')}>
        <ButtonText>Press Me</ButtonText>
      </Button>
    </Container>
  );
};</code></pre>
                    </div>

                    <h2><i class="fas fa-code"></i> Props & Dynamic Styling</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Dynamic Styles with Props</span>
                        </div>
                        <pre><code class="language-typescript">import styled from 'styled-components/native';

// Props interface
interface CardProps {
  variant?: 'primary' | 'secondary' | 'success' | 'danger';
  elevated?: boolean;
}

interface ButtonProps {
  size?: 'small' | 'medium' | 'large';
  variant?: 'solid' | 'outline' | 'ghost';
  disabled?: boolean;
}

// Dynamic styled components
const Card = styled.View<CardProps>\`
  background-color: \${props => {
    switch (props.variant) {
      case 'primary': return '#007AFF';
      case 'secondary': return '#5856D6';
      case 'success': return '#34C759';
      case 'danger': return '#FF3B30';
      default: return 'white';
    }
  }};
  padding: 16px;
  border-radius: 12px;
  margin: 8px;
  
  \${props => props.elevated && \`
    shadow-color: #000;
    shadow-offset: 0px 2px;
    shadow-opacity: 0.1;
    shadow-radius: 4px;
    elevation: 4;
  \`}
\`;

const StyledButton = styled.TouchableOpacity<ButtonProps>\`
  padding: \${props => {
    switch (props.size) {
      case 'small': return '8px 16px';
      case 'large': return '16px 32px';
      default: return '12px 24px';
    }
  }};
  
  background-color: \${props => {
    if (props.disabled) return '#cccccc';
    if (props.variant === 'outline' || props.variant === 'ghost') return 'transparent';
    return '#007AFF';
  }};
  
  border-width: \${props => props.variant === 'outline' ? '2px' : '0px'};
  border-color: #007AFF;
  border-radius: 8px;
  
  opacity: \${props => props.disabled ? 0.5 : 1};
\`;

const StyledButtonText = styled.Text<ButtonProps>\`
  color: \${props => {
    if (props.variant === 'outline' || props.variant === 'ghost') return '#007AFF';
    return 'white';
  }};
  
  font-size: \${props => {
    switch (props.size) {
      case 'small': return '14px';
      case 'large': return '18px';
      default: return '16px';
    }
  }};
  
  font-weight: 600;
  text-align: center;
\`;

// Usage
const DynamicStyledExample = () => {
  return (
    <Container>
      <Card variant="primary" elevated>
        <Title style={{ color: 'white' }}>Primary Card</Title>
      </Card>
      
      <StyledButton 
        size="large" 
        variant="solid"
        onPress={() => {}}
      >
        <StyledButtonText size="large" variant="solid">
          Large Button
        </StyledButtonText>
      </StyledButton>
      
      <StyledButton 
        variant="outline"
        disabled
        onPress={() => {}}
      >
        <StyledButtonText variant="outline">
          Disabled Outline
        </StyledButtonText>
      </StyledButton>
    </Container>
  );
};</code></pre>
                    </div>

                    <h2><i class="fas fa-palette"></i> Theming with Styled Components</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Theme Provider</span>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import styled, { ThemeProvider } from 'styled-components/native';

// Define theme interface
interface Theme {
  colors: {
    primary: string;
    secondary: string;
    background: string;
    surface: string;
    text: string;
    textSecondary: string;
    error: string;
    success: string;
  };
  spacing: {
    xs: number;
    sm: number;
    md: number;
    lg: number;
    xl: number;
  };
  typography: {
    h1: {
      fontSize: number;
      fontWeight: string;
    };
    h2: {
      fontSize: number;
      fontWeight: string;
    };
    body: {
      fontSize: number;
      lineHeight: number;
    };
  };
  borderRadius: {
    sm: number;
    md: number;
    lg: number;
  };
}

// Light theme
const lightTheme: Theme = {
  colors: {
    primary: '#007AFF',
    secondary: '#5856D6',
    background: '#F2F2F7',
    surface: '#FFFFFF',
    text: '#000000',
    textSecondary: '#666666',
    error: '#FF3B30',
    success: '#34C759',
  },
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
  },
  typography: {
    h1: {
      fontSize: 32,
      fontWeight: 'bold',
    },
    h2: {
      fontSize: 24,
      fontWeight: '600',
    },
    body: {
      fontSize: 16,
      lineHeight: 24,
    },
  },
  borderRadius: {
    sm: 4,
    md: 8,
    lg: 16,
  },
};

// Dark theme
const darkTheme: Theme = {
  ...lightTheme,
  colors: {
    ...lightTheme.colors,
    background: '#000000',
    surface: '#1C1C1E',
    text: '#FFFFFF',
    textSecondary: '#999999',
  },
};

// Themed components
const ThemedContainer = styled.View\`
  flex: 1;
  background-color: \${props => props.theme.colors.background};
  padding: \${props => props.theme.spacing.md}px;
\`;

const ThemedCard = styled.View\`
  background-color: \${props => props.theme.colors.surface};
  padding: \${props => props.theme.spacing.lg}px;
  border-radius: \${props => props.theme.borderRadius.lg}px;
  margin-bottom: \${props => props.theme.spacing.md}px;
  shadow-color: #000;
  shadow-offset: 0px 2px;
  shadow-opacity: 0.1;
  shadow-radius: 4px;
  elevation: 3;
\`;

const ThemedTitle = styled.Text\`
  font-size: \${props => props.theme.typography.h1.fontSize}px;
  font-weight: \${props => props.theme.typography.h1.fontWeight};
  color: \${props => props.theme.colors.text};
  margin-bottom: \${props => props.theme.spacing.sm}px;
\`;

const ThemedText = styled.Text\`
  font-size: \${props => props.theme.typography.body.fontSize}px;
  line-height: \${props => props.theme.typography.body.lineHeight}px;
  color: \${props => props.theme.colors.textSecondary};
\`;

// App with theme
const ThemedApp = () => {
  const [isDark, setIsDark] = React.useState(false);
  const theme = isDark ? darkTheme : lightTheme;

  return (
    <ThemeProvider theme={theme}>
      <ThemedContainer>
        <ThemedCard>
          <ThemedTitle>Themed App</ThemedTitle>
          <ThemedText>
            This app uses styled-components theming
          </ThemedText>
        </ThemedCard>
        
        <Button onPress={() => setIsDark(!isDark)}>
          <ButtonText>Toggle Theme</ButtonText>
        </Button>
      </ThemedContainer>
    </ThemeProvider>
  );
};</code></pre>
                    </div>

                    <h2><i class="fas fa-component"></i> Advanced Patterns</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Advanced Styled Components</span>
                        </div>
                        <pre><code class="language-typescript">// Extending styled components
const BaseButton = styled.TouchableOpacity\`
  padding: 12px 24px;
  border-radius: 8px;
  align-items: center;
  justify-content: center;
\`;

const PrimaryButton = styled(BaseButton)\`
  background-color: #007AFF;
\`;

const SecondaryButton = styled(BaseButton)\`
  background-color: transparent;
  border-width: 2px;
  border-color: #007AFF;
\`;

// Component with attrs
const Input = styled.TextInput.attrs(props => ({
  placeholderTextColor: props.theme?.colors.textSecondary || '#999',
  autoCapitalize: 'none',
  autoCorrect: false,
}))\`
  background-color: \${props => props.theme?.colors.surface || '#fff'};
  color: \${props => props.theme?.colors.text || '#000'};
  padding: 12px 16px;
  border-radius: 8px;
  border-width: 1px;
  border-color: \${props => props.theme?.colors.border || '#e0e0e0'};
  font-size: 16px;
\`;

// CSS helper
import { css } from 'styled-components/native';

const flexCenter = css\`
  align-items: center;
  justify-content: center;
\`;

const CenteredView = styled.View\`
  \${flexCenter}
  flex: 1;
\`;

// Conditional styling with css helper
const MessageBox = styled.View<{ type: 'info' | 'success' | 'error' }>\`
  padding: 16px;
  border-radius: 8px;
  margin: 8px;
  
  \${props => {
    switch (props.type) {
      case 'success':
        return css\`
          background-color: #34C759;
          border-color: #30A34A;
        \`;
      case 'error':
        return css\`
          background-color: #FF3B30;
          border-color: #D70015;
        \`;
      default:
        return css\`
          background-color: #007AFF;
          border-color: #0051D5;
        \`;
    }
  }}
\`;

// Global styles
import { createGlobalStyle } from 'styled-components/native';

const GlobalStyles = createGlobalStyle\`
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }
\`;</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4><i class="fas fa-lightbulb"></i> Styled Components Tips</h4>
                        <p>• Use TypeScript for better prop typing<br>
                        • Create a theme file for consistency<br>
                        • Use attrs for default props<br>
                        • Keep styled components near their usage<br>
                        • Consider performance with many dynamic styles</p>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Styled Components Quiz</h3>
                        <p class="quiz-question">What's the main advantage of styled-components?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Smaller bundle size
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                CSS-in-JS with dynamic styling
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Better performance
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Native CSS support
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-paint-brush"></i> Project: Styled UI Kit</h3>
                        <p class="project-description">Build a styled-components UI kit:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="styled1">
                                <label for="styled1">Create themed button variants</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="styled2">
                                <label for="styled2">Build form components with validation states</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="styled3">
                                <label for="styled3">Implement dark/light theme switcher</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="styled4">
                                <label for="styled4">Create animated components</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="styled5">
                                <label for="styled5">Build responsive grid system</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'themes': {
        title: 'Theming',
        content: `
                    <h1><i class="fas fa-palette"></i> Theming in React Native</h1>
                    
                    <p>Implementing a robust theming system allows users to personalize their experience and supports features like dark mode. Let's explore different approaches to theming.</p>

                    <h2><i class="fas fa-moon"></i> Context-Based Theming</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Theme Context Setup</span>
                            <div class="code-actions">
                                <button class="code-btn" onclick="copyCode(this)">Copy</button>
                            </div>
                        </div>
                        <pre><code class="language-typescript">import React, { createContext, useContext, useState, useEffect } from 'react';
import { Appearance, ColorSchemeName } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Theme type definitions
interface Colors {
  primary: string;
  secondary: string;
  background: string;
  surface: string;
  text: string;
  textSecondary: string;
  border: string;
  error: string;
  success: string;
  warning: string;
  info: string;
}

interface Theme {
  dark: boolean;
  colors: Colors;
  spacing: {
    xs: number;
    sm: number;
    md: number;
    lg: number;
    xl: number;
  };
  typography: {
    h1: { fontSize: number; fontWeight: string; lineHeight: number };
    h2: { fontSize: number; fontWeight: string; lineHeight: number };
    h3: { fontSize: number; fontWeight: string; lineHeight: number };
    body: { fontSize: number; lineHeight: number };
    caption: { fontSize: number; lineHeight: number };
  };
  borderRadius: {
    sm: number;
    md: number;
    lg: number;
    full: number;
  };
  shadows: {
    sm: object;
    md: object;
    lg: object;
  };
}

// Light theme
const lightTheme: Theme = {
  dark: false,
  colors: {
    primary: '#007AFF',
    secondary: '#5856D6',
    background: '#F2F2F7',
    surface: '#FFFFFF',
    text: '#000000',
    textSecondary: '#666666',
    border: '#C6C6C8',
    error: '#FF3B30',
    success: '#34C759',
    warning: '#FF9500',
    info: '#5856D6',
  },
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
  },
  typography: {
    h1: { fontSize: 32, fontWeight: 'bold', lineHeight: 40 },
    h2: { fontSize: 24, fontWeight: '600', lineHeight: 32 },
    h3: { fontSize: 20, fontWeight: '600', lineHeight: 28 },
    body: { fontSize: 16, lineHeight: 24 },
    caption: { fontSize: 12, lineHeight: 16 },
  },
  borderRadius: {
    sm: 4,
    md: 8,
    lg: 16,
    full: 9999,
  },
  shadows: {
    sm: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2,
      elevation: 2,
    },
    md: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.1,
      shadowRadius: 4,
      elevation: 4,
    },
    lg: {
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.15,
      shadowRadius: 8,
      elevation: 8,
    },
  },
};

// Dark theme
const darkTheme: Theme = {
  ...lightTheme,
  dark: true,
  colors: {
    primary: '#0A84FF',
    secondary: '#5E5CE6',
    background: '#000000',
    surface: '#1C1C1E',
    text: '#FFFFFF',
    textSecondary: '#999999',
    border: '#38383A',
    error: '#FF453A',
    success: '#32D74B',
    warning: '#FF9F0A',
    info: '#5E5CE6',
  },
};

// Theme context
interface ThemeContextType {
  theme: Theme;
  toggleTheme: () => void;
  setTheme: (theme: 'light' | 'dark' | 'system') => void;
  themeMode: 'light' | 'dark' | 'system';
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Theme provider
export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [themeMode, setThemeMode] = useState<'light' | 'dark' | 'system'>('system');
  const [systemTheme, setSystemTheme] = useState<ColorSchemeName>(Appearance.getColorScheme());

  useEffect(() => {
    // Load saved theme preference
    loadThemePreference();

    // Listen for system theme changes
    const subscription = Appearance.addChangeListener(({ colorScheme }) => {
      setSystemTheme(colorScheme);
    });

    return () => subscription.remove();
  }, []);

  const loadThemePreference = async () => {
    try {
      const savedTheme = await AsyncStorage.getItem('themeMode');
      if (savedTheme) {
        setThemeMode(savedTheme as 'light' | 'dark' | 'system');
      }
    } catch (error) {
      console.error('Error loading theme preference:', error);
    }
  };

  const saveThemePreference = async (mode: 'light' | 'dark' | 'system') => {
    try {
      await AsyncStorage.setItem('themeMode', mode);
    } catch (error) {
      console.error('Error saving theme preference:', error);
    }
  };

  const getCurrentTheme = (): Theme => {
    if (themeMode === 'system') {
      return systemTheme === 'dark' ? darkTheme : lightTheme;
    }
    return themeMode === 'dark' ? darkTheme : lightTheme;
  };

  const toggleTheme = () => {
    const newMode = themeMode === 'light' ? 'dark' : 'light';
    setThemeMode(newMode);
    saveThemePreference(newMode);
  };

  const setTheme = (mode: 'light' | 'dark' | 'system') => {
    setThemeMode(mode);
    saveThemePreference(mode);
  };

  const value = {
    theme: getCurrentTheme(),
    toggleTheme,
    setTheme,
    themeMode,
  };

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
};

// Custom hook
export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
};</code></pre>
                    </div>

                    <h2><i class="fas fa-brush"></i> Using the Theme</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Themed Components</span>
                        </div>
                        <pre><code class="language-typescript">import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Switch } from 'react-native';
import { useTheme } from './ThemeContext';

// Themed component
const ThemedScreen = () => {
  const { theme, toggleTheme, setTheme, themeMode } = useTheme();

  return (
    <View style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <View style={[styles.card, { backgroundColor: theme.colors.surface }, theme.shadows.md]}>
        <Text style={[styles.title, { color: theme.colors.text }]}>
          Theme Settings
        </Text>
        
        <View style={styles.option}>
          <Text style={[styles.label, { color: theme.colors.text }]}>
            Dark Mode
          </Text>
          <Switch
            value={theme.dark}
            onValueChange={toggleTheme}
            trackColor={{ false: '#767577', true: theme.colors.primary }}
            thumbColor={theme.dark ? '#f4f3f4' : '#f4f3f4'}
          />
        </View>

        <View style={styles.themeButtons}>
          {(['light', 'dark', 'system'] as const).map((mode) => (
            <TouchableOpacity
              key={mode}
              style={[
                styles.themeButton,
                { 
                  backgroundColor: themeMode === mode ? theme.colors.primary : theme.colors.surface,
                  borderColor: theme.colors.border,
                }
              ]}
              onPress={() => setTheme(mode)}
            >
              <Text style={[
                styles.buttonText,
                { color: themeMode === mode ? '#fff' : theme.colors.text }
              ]}>
                {mode.charAt(0).toUpperCase() + mode.slice(1)}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      {/* Color Palette */}
      <View style={[styles.card, { backgroundColor: theme.colors.surface }, theme.shadows.md]}>
        <Text style={[styles.title, { color: theme.colors.text }]}>
          Color Palette
        </Text>
        <View style={styles.colorGrid}>
          {Object.entries(theme.colors).map(([name, color]) => (
            <View key={name} style={styles.colorItem}>
              <View style={[styles.colorBox, { backgroundColor: color }]} />
              <Text style={[styles.colorName, { color: theme.colors.textSecondary }]}>
                {name}
              </Text>
              <Text style={[styles.colorValue, { color: theme.colors.textSecondary }]}>
                {color}
              </Text>
            </View>
          ))}
        </View>
      </View>
    </View>
  );
};

// Create themed styles hook
export const createThemedStyles = <T extends StyleSheet.NamedStyles<T>>(
  stylesFn: (theme: Theme) => T
) => {
  return () => {
    const { theme } = useTheme();
    return StyleSheet.create(stylesFn(theme));
  };
};

// Usage with themed styles hook
const useStyles = createThemedStyles((theme) => ({
  container: {
    flex: 1,
    padding: theme.spacing.md,
  },
  text: {
    color: theme.colors.text,
    fontSize: theme.typography.body.fontSize,
  },
  primaryButton: {
    backgroundColor: theme.colors.primary,
    padding: theme.spacing.md,
    borderRadius: theme.borderRadius.md,
  },
}));

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  card: {
    padding: 20,
    borderRadius: 12,
    marginBottom: 16,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  option: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
  },
  themeButtons: {
    flexDirection: 'row',
    gap: 10,
  },
  themeButton: {
    flex: 1,
    padding: 10,
    borderRadius: 8,
    borderWidth: 1,
    alignItems: 'center',
  },
  buttonText: {
    fontSize: 14,
    fontWeight: '600',
  },
  colorGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 10,
  },
  colorItem: {
    width: '30%',
    alignItems: 'center',
    marginBottom: 10,
  },
  colorBox: {
    width: 60,
    height: 60,
    borderRadius: 8,
    marginBottom: 4,
  },
  colorName: {
    fontSize: 12,
  },
  colorValue: {
    fontSize: 10,
  },
});</code></pre>
                    </div>

                    <h2><i class="fas fa-cog"></i> Advanced Theming Patterns</h2>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Theme Utilities</span>
                        </div>
                        <pre><code class="language-typescript">// Theme-aware components
import { TextProps, ViewProps } from 'react-native';

export const ThemedText: React.FC<TextProps & { variant?: keyof Theme['typography'] }> = ({ 
  style, 
  variant = 'body',
  ...props 
}) => {
  const { theme } = useTheme();
  const variantStyle = theme.typography[variant];
  
  return (
    <Text 
      style={[
        { color: theme.colors.text },
        variantStyle,
        style
      ]} 
      {...props} 
    />
  );
};

export const ThemedView: React.FC<ViewProps & { surface?: boolean }> = ({ 
  style, 
  surface,
  ...props 
}) => {
  const { theme } = useTheme();
  
  return (
    <View 
      style={[
        { backgroundColor: surface ? theme.colors.surface : theme.colors.background },
        style
      ]} 
      {...props} 
    />
  );
};

// Color manipulation utilities
export const lighten = (color: string, amount: number): string => {
  // Implementation to lighten color
  return color;
};

export const darken = (color: string, amount: number): string => {
  // Implementation to darken color
  return color;
};

export const alpha = (color: string, opacity: number): string => {
  // Convert hex to rgba with opacity
  return color;
};

// Dynamic theme creation
export const createTheme = (overrides: Partial<Theme>): Theme => {
  return {
    ...lightTheme,
    ...overrides,
    colors: {
      ...lightTheme.colors,
      ...overrides.colors,
    },
    // ... merge other nested properties
  };
};

// Theme variants
export const themes = {
  light: lightTheme,
  dark: darkTheme,
  blue: createTheme({
    colors: {
      primary: '#0066CC',
      secondary: '#004499',
    },
  }),
  green: createTheme({
    colors: {
      primary: '#00AA55',
      secondary: '#008844',
    },
  }),
};</code></pre>
                    </div>

                    <div class="tip-box">
                        <h4><i class="fas fa-lightbulb"></i> Theming Best Practices</h4>
                        <p>• Use semantic color names (primary, surface) not literal (blue, white)<br>
                        • Test themes with different font sizes for accessibility<br>
                        • Provide system theme option for battery saving<br>
                        • Store theme preference locally<br>
                        • Consider contrast ratios for text readability</p>
                    </div>

                    <div class="quiz-container">
                        <h3><i class="fas fa-question"></i> Theming Quiz</h3>
                        <p class="quiz-question">What's the best way to implement dark mode?</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Duplicate all style files
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'correct')">
                                Use theme context with semantic colors
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Use conditional styles everywhere
                            </div>
                            <div class="quiz-option" onclick="checkAnswer(this, 'incorrect')">
                                Build separate apps
                            </div>
                        </div>
                        <div class="quiz-feedback" id="quizFeedback"></div>
                    </div>

                    <div class="project-card">
                        <h3 class="project-title"><i class="fas fa-swatchbook"></i> Project: Theme System</h3>
                        <p class="project-description">Build a complete theming system:</p>
                        <div class="project-tasks">
                            <div class="project-task">
                                <input type="checkbox" id="theme1">
                                <label for="theme1">Create multiple theme presets</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="theme2">
                                <label for="theme2">Implement theme persistence</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="theme3">
                                <label for="theme3">Add custom theme creator</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="theme4">
                                <label for="theme4">Build themed component library</label>
                            </div>
                            <div class="project-task">
                                <input type="checkbox" id="theme5">
                                <label for="theme5">Support system theme detection</label>
                            </div>
                        </div>
                    </div>
                `
      },
      'usestate': {
        content: `
        <div class="content-section">
            <h1>useState Hook</h1>
            
            <div class="info-box">
                <p>The useState Hook is the most fundamental Hook in React Native. It allows functional components to have state, making them more powerful and eliminating the need for class components in most cases.</p>
            </div>

            <h2>Basic Syntax</h2>
            <pre><code class="language-javascript">import React, { useState } from 'react';

const [state, setState] = useState(initialValue);

// Example
const [count, setCount] = useState(0);
const [name, setName] = useState('');
const [isVisible, setIsVisible] = useState(true);
const [user, setUser] = useState({ name: '', age: 0 });</code></pre>

            <h2>Simple Counter Example</h2>
            <pre><code class="language-javascript">import React, { useState } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const Counter = () => {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  const reset = () => setCount(0);

  return (
    <View style={styles.container}>
      <Text style={styles.counter}>{count}</Text>
      <View style={styles.buttonRow}>
        <Button title="−" onPress={decrement} />
        <Button title="Reset" onPress={reset} />
        <Button title="+" onPress={increment} />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  counter: {
    fontSize: 48,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  buttonRow: {
    flexDirection: 'row',
    gap: 10,
  },
});</code></pre>

            <h2>Multiple State Variables</h2>
            <pre><code class="language-javascript">const UserProfile = () => {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState('');
  const [isSubscribed, setIsSubscribed] = useState(false);

  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Name"
        value={name}
        onChangeText={setName}
        style={styles.input}
      />
      <TextInput
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        style={styles.input}
        keyboardType="email-address"
      />
      <TextInput
        placeholder="Age"
        value={age}
        onChangeText={setAge}
        style={styles.input}
        keyboardType="numeric"
      />
      <View style={styles.checkboxRow}>
        <Switch
          value={isSubscribed}
          onValueChange={setIsSubscribed}
        />
        <Text>Subscribe to newsletter</Text>
      </View>
    </View>
  );
};</code></pre>

            <h2>Object State</h2>
            <pre><code class="language-javascript">const FormExample = () => {
  const [formData, setFormData] = useState({
    username: '',
    password: '',
    rememberMe: false,
  });

  // Update specific field
  const updateField = (field, value) => {
    setFormData(prevState => ({
      ...prevState,
      [field]: value,
    }));
  };

  // Alternative: using spread operator
  const handleUsernameChange = (text) => {
    setFormData({ ...formData, username: text });
  };

  return (
    <View>
      <TextInput
        placeholder="Username"
        value={formData.username}
        onChangeText={(text) => updateField('username', text)}
      />
      <TextInput
        placeholder="Password"
        value={formData.password}
        onChangeText={(text) => updateField('password', text)}
        secureTextEntry
      />
      <Switch
        value={formData.rememberMe}
        onValueChange={(value) => updateField('rememberMe', value)}
      />
    </View>
  );
};</code></pre>

            <h2>Array State</h2>
            <pre><code class="language-javascript">const TodoList = () => {
  const [todos, setTodos] = useState([]);
  const [inputText, setInputText] = useState('');

  const addTodo = () => {
    if (inputText.trim()) {
      setTodos([...todos, {
        id: Date.now(),
        text: inputText,
        completed: false,
      }]);
      setInputText('');
    }
  };

  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id
        ? { ...todo, completed: !todo.completed }
        : todo
    ));
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <View style={styles.container}>
      <View style={styles.inputRow}>
        <TextInput
          style={styles.input}
          value={inputText}
          onChangeText={setInputText}
          placeholder="Add a todo..."
        />
        <Button title="Add" onPress={addTodo} />
      </View>
      
      <FlatList
        data={todos}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => (
          <View style={styles.todoItem}>
            <TouchableOpacity onPress={() => toggleTodo(item.id)}>
              <Text style={[
                styles.todoText,
                item.completed && styles.completedText
              ]}>
                {item.text}
              </Text>
            </TouchableOpacity>
            <Button
              title="Delete"
              onPress={() => deleteTodo(item.id)}
              color="red"
            />
          </View>
        )}
      />
    </View>
  );
};</code></pre>

            <h2>Functional Updates</h2>
            <pre><code class="language-javascript">const Counter = () => {
  const [count, setCount] = useState(0);

  // ❌ Problem: Stale closure
  const incrementMultiple = () => {
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1);
    // Only increments by 1!
  };

  // ✅ Solution: Functional update
  const incrementMultipleCorrect = () => {
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
    // Correctly increments by 3
  };

  // Async example
  const delayedIncrement = () => {
    setTimeout(() => {
      // ❌ Uses stale value
      // setCount(count + 1);
      
      // ✅ Always uses current value
      setCount(prev => prev + 1);
    }, 2000);
  };

  return (
    <View>
      <Text>Count: {count}</Text>
      <Button title="Increment x3" onPress={incrementMultipleCorrect} />
      <Button title="Delayed +1" onPress={delayedIncrement} />
    </View>
  );
};</code></pre>

            <h2>Lazy Initial State</h2>
            <pre><code class="language-javascript">// ❌ Expensive computation runs on every render
const ExpensiveComponent = () => {
  const [data, setData] = useState(
    computeExpensiveInitialData() // Runs every render!
  );
  return <View>...</View>;
};

// ✅ Expensive computation runs only once
const OptimizedComponent = () => {
  const [data, setData] = useState(() => 
    computeExpensiveInitialData() // Runs only on mount
  );
  return <View>...</View>;
};

// Real-world example
const TodoApp = () => {
  // Load todos from AsyncStorage only on mount
  const [todos, setTodos] = useState(() => {
    try {
      const savedTodos = AsyncStorage.getItem('todos');
      return savedTodos ? JSON.parse(savedTodos) : [];
    } catch (error) {
      return [];
    }
  });

  // Save todos whenever they change
  useEffect(() => {
    AsyncStorage.setItem('todos', JSON.stringify(todos));
  }, [todos]);

  return <TodoList todos={todos} setTodos={setTodos} />;
};</code></pre>

            <h2>Common Patterns</h2>
            <pre><code class="language-javascript">// Toggle boolean state
const [isVisible, setIsVisible] = useState(false);
const toggle = () => setIsVisible(!isVisible);
// Better: const toggle = () => setIsVisible(prev => !prev);

// Previous/Next navigation
const [currentIndex, setCurrentIndex] = useState(0);
const data = ['Page 1', 'Page 2', 'Page 3'];

const goNext = () => {
  setCurrentIndex(prev => 
    prev < data.length - 1 ? prev + 1 : prev
  );
};

const goPrevious = () => {
  setCurrentIndex(prev => prev > 0 ? prev - 1 : prev);
};

// Form validation state
const [form, setForm] = useState({
  email: '',
  password: '',
});
const [errors, setErrors] = useState({});

const validateForm = () => {
  const newErrors = {};
  if (!form.email.includes('@')) {
    newErrors.email = 'Invalid email';
  }
  if (form.password.length < 8) {
    newErrors.password = 'Password too short';
  }
  setErrors(newErrors);
  return Object.keys(newErrors).length === 0;
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Keep state as simple as possible</li>
                    <li>Use multiple useState calls for unrelated data</li>
                    <li>Use functional updates when new state depends on previous state</li>
                    <li>Use lazy initial state for expensive computations</li>
                    <li>Don't mutate state directly - always create new objects/arrays</li>
                </ul>
            </div>
        </div>
    `,
        quiz: [
          {
            question: "What is the correct way to update state based on the previous state?",
            options: [
              "setState(state + 1)",
              "setState(prev => prev + 1)",
              "state = state + 1",
              "this.setState({state: state + 1})"
            ],
            correct: 1
          },
          {
            question: "When should you use lazy initial state?",
            options: [
              "Always",
              "Never",
              "When the initial state requires expensive computation",
              "Only with arrays"
            ],
            correct: 2
          },
          {
            question: "How do you update a specific property in an object state?",
            options: [
              "state.property = newValue",
              "setState({property: newValue})",
              "setState({...state, property: newValue})",
              "setState(state.property = newValue)"
            ],
            correct: 2
          }
        ],
        project: {
          title: "Build a Task Manager App",
          description: "Create a task manager with add, edit, delete, and filter functionality using useState",
          requirements: [
            "Add new tasks with title and description",
            "Mark tasks as complete/incomplete",
            "Edit existing tasks",
            "Delete tasks",
            "Filter tasks by status (all/active/completed)",
            "Display task count",
            "Persist tasks using AsyncStorage"
          ],
          hints: [
            "Use an array of objects for tasks",
            "Each task should have id, title, description, and completed properties",
            "Use functional updates for all state modifications",
            "Implement filter as a separate state variable"
          ]
        }
      },
      'useeffect': {
        content: `
        <div class="content-section">
            <h1>useEffect Hook</h1>
            
            <div class="info-box">
                <p>The useEffect Hook lets you perform side effects in functional components. It serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount in React class components.</p>
            </div>

            <h2>Basic Syntax</h2>
            <pre><code class="language-javascript">import React, { useEffect } from 'react';

useEffect(() => {
  // Effect code here
  
  return () => {
    // Cleanup code here (optional)
  };
}, [dependencies]); // Dependency array</code></pre>

            <h2>Component Lifecycle with useEffect</h2>
            <pre><code class="language-javascript">const LifecycleDemo = () => {
  const [count, setCount] = useState(0);

  // componentDidMount
  useEffect(() => {
    console.log('Component mounted');
    
    return () => {
      console.log('Component will unmount');
    };
  }, []); // Empty dependency array

  // componentDidUpdate
  useEffect(() => {
    console.log('Count updated:', count);
  }, [count]); // Runs when count changes

  // Runs after every render
  useEffect(() => {
    console.log('Component rendered');
  }); // No dependency array

  return (
    <View>
      <Text>Count: {count}</Text>
      <Button title="Increment" onPress={() => setCount(count + 1)} />
    </View>
  );
};</code></pre>

            <h2>Data Fetching</h2>
            <pre><code class="language-javascript">const UserProfile = ({ userId }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // Prevent state updates after unmount
    let isCancelled = false;

    const fetchUser = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(\`https://api.example.com/users/\${userId}\`);
        if (!response.ok) throw new Error('Failed to fetch');
        
        const data = await response.json();
        
        if (!isCancelled) {
          setUser(data);
        }
      } catch (err) {
        if (!isCancelled) {
          setError(err.message);
        }
      } finally {
        if (!isCancelled) {
          setLoading(false);
        }
      }
    };

    fetchUser();

    // Cleanup function
    return () => {
      isCancelled = true;
    };
  }, [userId]); // Re-fetch when userId changes

  if (loading) return <ActivityIndicator />;
  if (error) return <Text>Error: {error}</Text>;
  if (!user) return <Text>No user found</Text>;

  return (
    <View>
      <Text>{user.name}</Text>
      <Text>{user.email}</Text>
    </View>
  );
};</code></pre>

            <h2>Timers and Intervals</h2>
            <pre><code class="language-javascript">const Timer = () => {
  const [seconds, setSeconds] = useState(0);
  const [isActive, setIsActive] = useState(false);

  useEffect(() => {
    let interval = null;

    if (isActive) {
      interval = setInterval(() => {
        setSeconds(seconds => seconds + 1);
      }, 1000);
    } else if (!isActive && seconds !== 0) {
      clearInterval(interval);
    }

    // Cleanup
    return () => clearInterval(interval);
  }, [isActive, seconds]);

  const toggle = () => setIsActive(!isActive);
  const reset = () => {
    setSeconds(0);
    setIsActive(false);
  };

  return (
    <View style={styles.container}>
      <Text style={styles.time}>
        {Math.floor(seconds / 60)}:{(seconds % 60).toString().padStart(2, '0')}
      </Text>
      <View style={styles.buttonRow}>
        <Button
          title={isActive ? 'Pause' : 'Start'}
          onPress={toggle}
        />
        <Button title="Reset" onPress={reset} />
      </View>
    </View>
  );
};</code></pre>

            <h2>Event Listeners</h2>
            <pre><code class="language-javascript">const KeyboardAwareView = ({ children }) => {
  const [keyboardHeight, setKeyboardHeight] = useState(0);

  useEffect(() => {
    const showSubscription = Keyboard.addListener(
      'keyboardDidShow',
      (e) => setKeyboardHeight(e.endCoordinates.height)
    );
    
    const hideSubscription = Keyboard.addListener(
      'keyboardDidHide',
      () => setKeyboardHeight(0)
    );

    // Cleanup
    return () => {
      showSubscription.remove();
      hideSubscription.remove();
    };
  }, []);

  return (
    <View style={{ paddingBottom: keyboardHeight }}>
      {children}
    </View>
  );
};

// App State listener
const AppStateExample = () => {
  const [appState, setAppState] = useState(AppState.currentState);

  useEffect(() => {
    const subscription = AppState.addEventListener(
      'change',
      nextAppState => {
        if (appState.match(/inactive|background/) && 
            nextAppState === 'active') {
          console.log('App has come to the foreground!');
        }
        setAppState(nextAppState);
      }
    );

    return () => subscription.remove();
  }, [appState]);

  return <Text>Current state: {appState}</Text>;
};</code></pre>

            <h2>Local Storage Operations</h2>
            <pre><code class="language-javascript">const SettingsScreen = () => {
  const [settings, setSettings] = useState({
    theme: 'light',
    notifications: true,
    language: 'en',
  });

  // Load settings on mount
  useEffect(() => {
    const loadSettings = async () => {
      try {
        const saved = await AsyncStorage.getItem('userSettings');
        if (saved) {
          setSettings(JSON.parse(saved));
        }
      } catch (error) {
        console.error('Failed to load settings:', error);
      }
    };

    loadSettings();
  }, []);

  // Save settings whenever they change
  useEffect(() => {
    const saveSettings = async () => {
      try {
        await AsyncStorage.setItem(
          'userSettings',
          JSON.stringify(settings)
        );
      } catch (error) {
        console.error('Failed to save settings:', error);
      }
    };

    saveSettings();
  }, [settings]);

  const updateSetting = (key, value) => {
    setSettings(prev => ({ ...prev, [key]: value }));
  };

  return (
    <View>
      <Text>Theme: {settings.theme}</Text>
      <Switch
        value={settings.notifications}
        onValueChange={(value) => updateSetting('notifications', value)}
      />
    </View>
  );
};</code></pre>

            <h2>Debouncing with useEffect</h2>
            <pre><code class="language-javascript">const SearchInput = ({ onSearch }) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [isSearching, setIsSearching] = useState(false);

  useEffect(() => {
    // Don't search if term is empty
    if (!searchTerm.trim()) {
      return;
    }

    setIsSearching(true);

    // Debounce search
    const timeoutId = setTimeout(() => {
      onSearch(searchTerm).finally(() => {
        setIsSearching(false);
      });
    }, 500); // 500ms delay

    // Cleanup - cancel previous timeout
    return () => {
      clearTimeout(timeoutId);
      setIsSearching(false);
    };
  }, [searchTerm, onSearch]);

  return (
    <View style={styles.searchContainer}>
      <TextInput
        style={styles.searchInput}
        value={searchTerm}
        onChangeText={setSearchTerm}
        placeholder="Search..."
      />
      {isSearching && <ActivityIndicator />}
    </View>
  );
};</code></pre>

            <h2>Custom Hook with useEffect</h2>
            <pre><code class="language-javascript">// Custom hook for device orientation
const useOrientation = () => {
  const [orientation, setOrientation] = useState(
    Dimensions.get('window').width > Dimensions.get('window').height
      ? 'landscape'
      : 'portrait'
  );

  useEffect(() => {
    const updateOrientation = ({ window }) => {
      setOrientation(window.width > window.height ? 'landscape' : 'portrait');
    };

    const subscription = Dimensions.addEventListener(
      'change',
      updateOrientation
    );

    return () => subscription?.remove();
  }, []);

  return orientation;
};

// Usage
const ResponsiveComponent = () => {
  const orientation = useOrientation();

  return (
    <View style={[
      styles.container,
      orientation === 'landscape' && styles.landscape
    ]}>
      <Text>Current orientation: {orientation}</Text>
    </View>
  );
};</code></pre>

            <h2>Common Pitfalls</h2>
            <pre><code class="language-javascript">// ❌ Missing dependency
const BadExample = ({ userId }) => {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetchUser(userId); // ESLint warning: missing dependency
  }, []); // Should include userId
};

// ✅ Correct dependencies
const GoodExample = ({ userId }) => {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetchUser(userId);
  }, [userId]);
};

// ❌ Async function directly in useEffect
useEffect(async () => {
  const data = await fetchData(); // Error!
}, []);

// ✅ Async function inside useEffect
useEffect(() => {
  const loadData = async () => {
    const data = await fetchData();
    setData(data);
  };
  
  loadData();
}, []);

// ❌ Setting state after unmount
useEffect(() => {
  setTimeout(() => {
    setData(newData); // May cause memory leak
  }, 1000);
}, []);

// ✅ Cleanup to prevent state updates
useEffect(() => {
  let isMounted = true;
  
  setTimeout(() => {
    if (isMounted) {
      setData(newData);
    }
  }, 1000);
  
  return () => {
    isMounted = false;
  };
}, []);</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Always include all dependencies in the dependency array</li>
                    <li>Use cleanup functions to prevent memory leaks</li>
                    <li>Don't call Hooks inside loops, conditions, or nested functions</li>
                    <li>Split effects by concern - use multiple useEffect calls</li>
                    <li>Be careful with object/array dependencies - they cause re-runs</li>
                </ul>
            </div>
        </div>
    `,
        quiz: [
          {
            question: "When does useEffect with an empty dependency array run?",
            options: [
              "After every render",
              "Only on mount",
              "Only on unmount",
              "Never"
            ],
            correct: 1
          },
          {
            question: "How do you prevent a memory leak when fetching data?",
            options: [
              "Use async/await",
              "Clear the state",
              "Use a cleanup function with a flag",
              "Don't use useEffect"
            ],
            correct: 2
          },
          {
            question: "What happens if you omit the dependency array?",
            options: [
              "Effect runs only once",
              "Effect never runs",
              "Effect runs after every render",
              "Error is thrown"
            ],
            correct: 2
          }
        ],
        project: {
          title: "Real-time Chat Interface",
          description: "Build a chat interface that updates in real-time using useEffect for polling",
          requirements: [
            "Fetch messages every 2 seconds",
            "Display loading state during fetch",
            "Handle errors gracefully",
            "Stop polling when component unmounts",
            "Auto-scroll to latest message",
            "Show typing indicator when someone is typing",
            "Save draft messages to AsyncStorage"
          ],
          hints: [
            "Use setInterval for polling",
            "Clean up interval in return function",
            "Use refs for auto-scroll behavior",
            "Implement exponential backoff for errors"
          ]
        }
      },
      'usecontext': {
        content: `
        <div class="content-section">
            <h1>Context API</h1>
            
            <div class="info-box">
                <p>Context provides a way to pass data through the component tree without having to pass props down manually at every level. It's designed to share data that can be considered "global" for a tree of React components.</p>
            </div>

            <h2>Creating and Using Context</h2>
            <pre><code class="language-javascript">import React, { createContext, useContext, useState } from 'react';

// 1. Create Context
const ThemeContext = createContext();

// 2. Create Provider Component
export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };

  const value = {
    theme,
    toggleTheme,
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
};

// 3. Custom Hook for using context
export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
};

// 4. Usage in components
const ThemedButton = () => {
  const { theme, toggleTheme } = useTheme();

  return (
    <TouchableOpacity
      style={[
        styles.button,
        theme === 'dark' && styles.darkButton
      ]}
      onPress={toggleTheme}
    >
      <Text style={[
        styles.buttonText,
        theme === 'dark' && styles.darkButtonText
      ]}>
        Toggle Theme
      </Text>
    </TouchableOpacity>
  );
};</code></pre>

            <h2>Authentication Context</h2>
            <pre><code class="language-javascript">// AuthContext.js
const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Check if user is logged in on mount
    checkAuthState();
  }, []);

  const checkAuthState = async () => {
    try {
      const token = await AsyncStorage.getItem('authToken');
      if (token) {
        // Verify token and get user data
        const userData = await verifyToken(token);
        setUser(userData);
      }
    } catch (error) {
      console.error('Auth check failed:', error);
    } finally {
      setLoading(false);
    }
  };

  const login = async (email, password) => {
    try {
      const response = await api.login(email, password);
      const { user, token } = response.data;
      
      await AsyncStorage.setItem('authToken', token);
      setUser(user);
      
      return { success: true };
    } catch (error) {
      return { 
        success: false, 
        error: error.message 
      };
    }
  };

  const logout = async () => {
    try {
      await AsyncStorage.removeItem('authToken');
      setUser(null);
    } catch (error) {
      console.error('Logout failed:', error);
    }
  };

  const value = {
    user,
    loading,
    login,
    logout,
    isAuthenticated: !!user,
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};</code></pre>

            <h2>Multiple Contexts</h2>
            <pre><code class="language-javascript">// App.js - Combining multiple providers
const App = () => {
  return (
    <AuthProvider>
      <ThemeProvider>
        <LanguageProvider>
          <NotificationProvider>
            <NavigationContainer>
              <RootNavigator />
            </NavigationContainer>
          </NotificationProvider>
        </LanguageProvider>
      </ThemeProvider>
    </AuthProvider>
  );
};

// Better: Create a combined provider
const AppProviders = ({ children }) => {
  return (
    <AuthProvider>
      <ThemeProvider>
        <LanguageProvider>
          <NotificationProvider>
            {children}
          </NotificationProvider>
        </LanguageProvider>
      </ThemeProvider>
    </AuthProvider>
  );
};

const App = () => {
  return (
    <AppProviders>
      <NavigationContainer>
        <RootNavigator />
      </NavigationContainer>
    </AppProviders>
  );
};</code></pre>

            <h2>Shopping Cart Context</h2>
            <pre><code class="language-javascript">// CartContext.js
const CartContext = createContext();

export const CartProvider = ({ children }) => {
  const [items, setItems] = useState([]);

  const addToCart = (product) => {
    setItems(prevItems => {
      const existingItem = prevItems.find(
        item => item.id === product.id
      );

      if (existingItem) {
        return prevItems.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
      }

      return [...prevItems, { ...product, quantity: 1 }];
    });
  };

  const removeFromCart = (productId) => {
    setItems(prevItems =>
      prevItems.filter(item => item.id !== productId)
    );
  };

  const updateQuantity = (productId, quantity) => {
    if (quantity <= 0) {
      removeFromCart(productId);
      return;
    }

    setItems(prevItems =>
      prevItems.map(item =>
        item.id === productId
          ? { ...item, quantity }
          : item
      )
    );
  };

  const clearCart = () => setItems([]);

  const cartTotal = items.reduce(
    (total, item) => total + (item.price * item.quantity),
    0
  );

  const cartCount = items.reduce(
    (count, item) => count + item.quantity,
    0
  );

  const value = {
    items,
    addToCart,
    removeFromCart,
    updateQuantity,
    clearCart,
    cartTotal,
    cartCount,
  };

  return (
    <CartContext.Provider value={value}>
      {children}
    </CartContext.Provider>
  );
};

export const useCart = () => {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within CartProvider');
  }
  return context;
};</code></pre>

            <h2>Language/Localization Context</h2>
            <pre><code class="language-javascript">// LanguageContext.js
import translations from './translations';

const LanguageContext = createContext();

export const LanguageProvider = ({ children }) => {
  const [language, setLanguage] = useState('en');

  const t = (key) => {
    return translations[language][key] || key;
  };

  const changeLanguage = async (newLanguage) => {
    setLanguage(newLanguage);
    await AsyncStorage.setItem('language', newLanguage);
  };

  useEffect(() => {
    // Load saved language preference
    const loadLanguage = async () => {
      const savedLanguage = await AsyncStorage.getItem('language');
      if (savedLanguage) {
        setLanguage(savedLanguage);
      }
    };
    loadLanguage();
  }, []);

  const value = {
    language,
    changeLanguage,
    t,
  };

  return (
    <LanguageContext.Provider value={value}>
      {children}
    </LanguageContext.Provider>
  );
};

export const useLanguage = () => {
  const context = useContext(LanguageContext);
  if (!context) {
    throw new Error('useLanguage must be used within LanguageProvider');
  }
  return context;
};

// Usage
const WelcomeScreen = () => {
  const { t, language, changeLanguage } = useLanguage();

  return (
    <View>
      <Text>{t('welcome_message')}</Text>
      <Text>{t('current_language')}: {language}</Text>
      <Button
        title={t('change_language')}
        onPress={() => changeLanguage('es')}
      />
    </View>
  );
};</code></pre>

            <h2>Form Context Example</h2>
            <pre><code class="language-javascript">// FormContext.js
const FormContext = createContext();

export const FormProvider = ({ children, onSubmit }) => {
  const [values, setValues] = useState({});
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const setValue = (name, value) => {
    setValues(prev => ({ ...prev, [name]: value }));
    // Clear error when user types
    if (errors[name]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }
  };

  const setFieldTouched = (name) => {
    setTouched(prev => ({ ...prev, [name]: true }));
  };

  const validateField = (name, value) => {
    // Example validation
    if (!value) {
      return 'Required';
    }
    if (name === 'email' && !value.includes('@')) {
      return 'Invalid email';
    }
    return null;
  };

  const handleSubmit = () => {
    // Validate all fields
    const newErrors = {};
    Object.keys(values).forEach(key => {
      const error = validateField(key, values[key]);
      if (error) {
        newErrors[key] = error;
      }
    });

    if (Object.keys(newErrors).length === 0) {
      onSubmit(values);
    } else {
      setErrors(newErrors);
      setTouched(
        Object.keys(values).reduce(
          (acc, key) => ({ ...acc, [key]: true }),
          {}
        )
      );
    }
  };

  const value = {
    values,
    errors,
    touched,
    setValue,
    setFieldTouched,
    handleSubmit,
  };

  return (
    <FormContext.Provider value={value}>
      {children}
    </FormContext.Provider>
  );
};

// Form Field Component
export const FormField = ({ name, ...props }) => {
  const {
    values,
    errors,
    touched,
    setValue,
    setFieldTouched,
  } = useContext(FormContext);

  return (
    <View>
      <TextInput
        {...props}
        value={values[name] || ''}
        onChangeText={(text) => setValue(name, text)}
        onBlur={() => setFieldTouched(name)}
        style={[
          styles.input,
          touched[name] && errors[name] && styles.errorInput
        ]}
      />
      {touched[name] && errors[name] && (
        <Text style={styles.errorText}>{errors[name]}</Text>
      )}
    </View>
  );
};</code></pre>

            <h2>Performance Optimization</h2>
            <pre><code class="language-javascript">// Split contexts to avoid unnecessary re-renders
const UserContext = createContext();
const UserActionsContext = createContext();

export const UserProvider = ({ children }) => {
  const [user, setUser] = useState(null);

  // Memoize actions to prevent re-renders
  const actions = useMemo(() => ({
    updateUser: (userData) => setUser(userData),
    clearUser: () => setUser(null),
  }), []);

  return (
    <UserContext.Provider value={user}>
      <UserActionsContext.Provider value={actions}>
        {children}
      </UserActionsContext.Provider>
    </UserContext.Provider>
  );
};

// Separate hooks for data and actions
export const useUser = () => useContext(UserContext);
export const useUserActions = () => useContext(UserActionsContext);

// Component that only needs user data won't re-render
// when actions change
const UserDisplay = () => {
  const user = useUser();
  return <Text>{user?.name}</Text>;
};

// Component that only needs actions won't re-render
// when user data changes
const LogoutButton = () => {
  const { clearUser } = useUserActions();
  return <Button title="Logout" onPress={clearUser} />;
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Use Context for truly global state (auth, theme, language)</li>
                    <li>Don't overuse Context - props are fine for local state</li>
                    <li>Split contexts when data changes at different rates</li>
                    <li>Always provide default values or error handling</li>
                    <li>Create custom hooks for consuming context</li>
                    <li>Memoize context values to prevent unnecessary re-renders</li>
                </ul>
            </div>
        </div>
    `,
        quiz: [
          {
            question: "When should you use Context API?",
            options: [
              "For all state management",
              "Only for component state",
              "For global/shared state across many components",
              "Never, always use props"
            ],
            correct: 2
          },
          {
            question: "What happens when Context value changes?",
            options: [
              "Nothing",
              "Only the provider re-renders",
              "All consuming components re-render",
              "The entire app re-renders"
            ],
            correct: 2
          },
          {
            question: "How do you optimize Context performance?",
            options: [
              "Use multiple contexts",
              "Memoize context values",
              "Split data and actions",
              "All of the above"
            ],
            correct: 3
          }
        ],
        project: {
          title: "Multi-Feature Settings App",
          description: "Build a settings app using multiple contexts for theme, language, and user preferences",
          requirements: [
            "Theme context with light/dark mode",
            "Language context with at least 2 languages",
            "User preferences context",
            "Settings persistence with AsyncStorage",
            "Settings screen with all options",
            "Apply settings throughout the app",
            "Reset to defaults option"
          ],
          hints: [
            "Create separate contexts for different concerns",
            "Use a root provider component",
            "Implement proper error boundaries",
            "Save settings on change, load on mount"
          ]
        }
      },
      'usereducer': {
        content: `
        <div class="content-section">
            <h1>useReducer Hook</h1>
            
            <div class="info-box">
                <p>useReducer is an alternative to useState for managing complex state logic. It's preferable when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.</p>
            </div>

            <h2>Basic Syntax</h2>
            <pre><code class="language-javascript">import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return initialState;
    default:
      throw new Error(\`Unknown action: \${action.type}\`);
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <View>
      <Text>Count: {state.count}</Text>
      <Button 
        title="+" 
        onPress={() => dispatch({ type: 'increment' })} 
      />
      <Button 
        title="-" 
        onPress={() => dispatch({ type: 'decrement' })} 
      />
      <Button 
        title="Reset" 
        onPress={() => dispatch({ type: 'reset' })} 
      />
    </View>
  );
}</code></pre>

            <h2>Complex State Management</h2>
            <pre><code class="language-javascript">// Todo App with useReducer
const todoReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: Date.now(),
            text: action.payload,
            completed: false,
          },
        ],
      };
    
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        ),
      };
    
    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload),
      };
    
    case 'SET_FILTER':
      return {
        ...state,
        filter: action.payload,
      };
    
    case 'CLEAR_COMPLETED':
      return {
        ...state,
        todos: state.todos.filter(todo => !todo.completed),
      };
    
    default:
      return state;
  }
};

const initialTodoState = {
  todos: [],
  filter: 'all', // all, active, completed
};

const TodoApp = () => {
  const [state, dispatch] = useReducer(todoReducer, initialTodoState);
  const [inputText, setInputText] = useState('');

  const filteredTodos = state.todos.filter(todo => {
    if (state.filter === 'active') return !todo.completed;
    if (state.filter === 'completed') return todo.completed;
    return true;
  });

  const addTodo = () => {
    if (inputText.trim()) {
      dispatch({ type: 'ADD_TODO', payload: inputText });
      setInputText('');
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.inputRow}>
        <TextInput
          value={inputText}
          onChangeText={setInputText}
          placeholder="Add a todo..."
          style={styles.input}
        />
        <Button title="Add" onPress={addTodo} />
      </View>

      <View style={styles.filters}>
        {['all', 'active', 'completed'].map(filter => (
          <TouchableOpacity
            key={filter}
            onPress={() => dispatch({ type: 'SET_FILTER', payload: filter })}
            style={[
              styles.filterButton,
              state.filter === filter && styles.activeFilter,
            ]}
          >
            <Text>{filter}</Text>
          </TouchableOpacity>
        ))}
      </View>

      <FlatList
        data={filteredTodos}
        keyExtractor={item => item.id.toString()}
        renderItem={({ item }) => (
          <View style={styles.todoItem}>
            <TouchableOpacity
              onPress={() => dispatch({ type: 'TOGGLE_TODO', payload: item.id })}
            >
              <Text style={item.completed && styles.completed}>
                {item.text}
              </Text>
            </TouchableOpacity>
            <Button
              title="Delete"
              onPress={() => dispatch({ type: 'DELETE_TODO', payload: item.id })}
            />
          </View>
        )}
      />

      <Button
        title="Clear Completed"
        onPress={() => dispatch({ type: 'CLEAR_COMPLETED' })}
      />
    </View>
  );
};</code></pre>

            <h2>Form Management with useReducer</h2>
            <pre><code class="language-javascript">const formReducer = (state, action) => {
  switch (action.type) {
    case 'UPDATE_FIELD':
      return {
        ...state,
        values: {
          ...state.values,
          [action.field]: action.value,
        },
        errors: {
          ...state.errors,
          [action.field]: '', // Clear error on field update
        },
      };
    
    case 'SET_ERRORS':
      return {
        ...state,
        errors: action.errors,
      };
    
    case 'SET_SUBMITTING':
      return {
        ...state,
        isSubmitting: action.value,
      };
    
    case 'RESET_FORM':
      return action.initialState;
    
    default:
      return state;
  }
};

const RegistrationForm = () => {
  const initialState = {
    values: {
      username: '',
      email: '',
      password: '',
      confirmPassword: '',
    },
    errors: {},
    isSubmitting: false,
  };

  const [state, dispatch] = useReducer(formReducer, initialState);

  const updateField = (field, value) => {
    dispatch({ type: 'UPDATE_FIELD', field, value });
  };

  const validate = () => {
    const errors = {};
    
    if (!state.values.username) {
      errors.username = 'Username is required';
    }
    
    if (!state.values.email) {
      errors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(state.values.email)) {
      errors.email = 'Email is invalid';
    }
    
    if (!state.values.password) {
      errors.password = 'Password is required';
    } else if (state.values.password.length < 8) {
      errors.password = 'Password must be at least 8 characters';
    }
    
    if (state.values.password !== state.values.confirmPassword) {
      errors.confirmPassword = 'Passwords do not match';
    }
    
    return errors;
  };

  const handleSubmit = async () => {
    const errors = validate();
    
    if (Object.keys(errors).length > 0) {
      dispatch({ type: 'SET_ERRORS', errors });
      return;
    }
    
    dispatch({ type: 'SET_SUBMITTING', value: true });
    
    try {
      // Submit form
      await api.register(state.values);
      Alert.alert('Success', 'Registration successful!');
      dispatch({ type: 'RESET_FORM', initialState });
    } catch (error) {
      Alert.alert('Error', error.message);
    } finally {
      dispatch({ type: 'SET_SUBMITTING', value: false });
    }
  };

  return (
    <ScrollView style={styles.container}>
      <TextInput
        placeholder="Username"
        value={state.values.username}
        onChangeText={(text) => updateField('username', text)}
        style={styles.input}
      />
      {state.errors.username && (
        <Text style={styles.error}>{state.errors.username}</Text>
      )}

      <TextInput
        placeholder="Email"
        value={state.values.email}
        onChangeText={(text) => updateField('email', text)}
        keyboardType="email-address"
        style={styles.input}
      />
      {state.errors.email && (
        <Text style={styles.error}>{state.errors.email}</Text>
      )}

      <TextInput
        placeholder="Password"
        value={state.values.password}
        onChangeText={(text) => updateField('password', text)}
        secureTextEntry
        style={styles.input}
      />
      {state.errors.password && (
        <Text style={styles.error}>{state.errors.password}</Text>
      )}

      <TextInput
        placeholder="Confirm Password"
        value={state.values.confirmPassword}
        onChangeText={(text) => updateField('confirmPassword', text)}
        secureTextEntry
        style={styles.input}
      />
      {state.errors.confirmPassword && (
        <Text style={styles.error}>{state.errors.confirmPassword}</Text>
      )}

      <Button
        title={state.isSubmitting ? 'Submitting...' : 'Register'}
        onPress={handleSubmit}
        disabled={state.isSubmitting}
      />
    </ScrollView>
  );
};</code></pre>

            <h2>Shopping Cart with useReducer</h2>
            <pre><code class="language-javascript">const cartReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_ITEM': {
      const existingItem = state.items.find(
        item => item.id === action.payload.id
      );

      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =>
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          ),
        };
      }

      return {
        ...state,
        items: [...state.items, { ...action.payload, quantity: 1 }],
      };
    }

    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.payload),
      };

    case 'UPDATE_QUANTITY':
      return {
        ...state,
        items: state.items.map(item =>
          item.id === action.payload.id
            ? { ...item, quantity: action.payload.quantity }
            : item
        ).filter(item => item.quantity > 0),
      };

    case 'CLEAR_CART':
      return {
        ...state,
        items: [],
      };

    case 'SET_SHIPPING':
      return {
        ...state,
        shipping: action.payload,
      };

    case 'APPLY_COUPON':
      return {
        ...state,
        coupon: action.payload,
        discount: calculateDiscount(action.payload, state),
      };

    default:
      return state;
  }
};

const ShoppingCart = () => {
  const initialState = {
    items: [],
    shipping: 0,
    coupon: null,
    discount: 0,
  };

  const [state, dispatch] = useReducer(cartReducer, initialState);

const subtotal = state.items && Array.isArray(state.items) 
  ? state.items.reduce(
      (sum, item) => sum + (item.price * item.quantity),
      0
    )
  : 0;

  const total = subtotal + state.shipping - state.discount;

  return (
    <View style={styles.container}>
      <FlatList
        data={state.items}
        renderItem={({ item }) => (
          <CartItem
            item={item}
            onUpdateQuantity={(quantity) =>
              dispatch({
                type: 'UPDATE_QUANTITY',
                payload: { id: item.id, quantity },
              })
            }
            onRemove={() =>
              dispatch({ type: 'REMOVE_ITEM', payload: item.id })
            }
          />
        )}
      />

      <View style={styles.summary}>
        <Text>Subtotal: {subtotal.toFixed(2)}</Text>
        <Text>Shipping: {state.shipping.toFixed(2)}</Text>
        {state.discount > 0 && (
          <Text>Discount: -{state.discount.toFixed(2)}</Text>
        )}
        <Text style={styles.total}>Total: {total.toFixed(2)}</Text>
      </View>

      <Button
        title="Clear Cart"
        onPress={() => dispatch({ type: 'CLEAR_CART' })}
      />
    </View>
  );
};</code></pre>

            <h2>Async Actions with useReducer</h2>
            <pre><code class="language-javascript">const dataReducer = (state, action) => {
  switch (action.type) {
    case 'FETCH_START':
      return {
        ...state,
        loading: true,
        error: null,
      };
    
    case 'FETCH_SUCCESS':
      return {
        ...state,
        loading: false,
        data: action.payload,
      };
    
    case 'FETCH_ERROR':
      return {
        ...state,
        loading: false,
        error: action.payload,
      };
    
    case 'REFRESH':
      return {
        ...state,
        refreshing: true,
      };
    
    default:
      return state;
  }
};

const useDataFetch = (url) => {
  const initialState = {
    data: null,
    loading: true,
    error: null,
    refreshing: false,
  };

  const [state, dispatch] = useReducer(dataReducer, initialState);

  const fetchData = useCallback(async (isRefresh = false) => {
    dispatch({ type: isRefresh ? 'REFRESH' : 'FETCH_START' });

    try {
      const response = await fetch(url);
      if (!response.ok) throw new Error('Failed to fetch');
      
      const data = await response.json();
      dispatch({ type: 'FETCH_SUCCESS', payload: data });
    } catch (error) {
      dispatch({ type: 'FETCH_ERROR', payload: error.message });
    }
  }, [url]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return {
    ...state,
    refetch: () => fetchData(true),
  };
};</code></pre>

            <h2>useReducer with Context</h2>
            <pre><code class="language-javascript">// Combining useReducer with Context for global state
const StateContext = createContext();
const DispatchContext = createContext();

const appReducer = (state, action) => {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload };
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    case 'SET_LANGUAGE':
      return { ...state, language: action.payload };
    case 'LOGOUT':
      return { ...initialState, theme: state.theme };
    default:
      return state;
  }
};

export const AppStateProvider = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, initialState);

  return (
    <StateContext.Provider value={state}>
      <DispatchContext.Provider value={dispatch}>
        {children}
      </DispatchContext.Provider>
    </StateContext.Provider>
  );
};

// Custom hooks
export const useAppState = () => {
  const state = useContext(StateContext);
  if (!state) {
    throw new Error('useAppState must be used within AppStateProvider');
  }
  return state;
};

export const useAppDispatch = () => {
  const dispatch = useContext(DispatchContext);
  if (!dispatch) {
    throw new Error('useAppDispatch must be used within AppStateProvider');
  }
  return dispatch;
};

// Usage
const UserProfile = () => {
  const { user } = useAppState();
  const dispatch = useAppDispatch();

  const logout = () => {
    dispatch({ type: 'LOGOUT' });
  };

  return (
    <View>
      <Text>{user?.name}</Text>
      <Button title="Logout" onPress={logout} />
    </View>
  );
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Use useReducer for complex state logic with multiple sub-values</li>
                    <li>Always provide a default case in your reducer</li>
                    <li>Keep reducers pure - no side effects</li>
                    <li>Use action types as constants to avoid typos</li>
                    <li>Consider combining with Context for global state management</li>
                    <li>Use Immer for complex state updates if needed</li>
                </ul>
            </div>
        </div>
    `,
        quiz: [
          {
            question: "When should you use useReducer instead of useState?",
            options: [
              "Always",
              "Never",
              "When state logic is complex or involves multiple sub-values",
              "Only for forms"
            ],
            correct: 2
          },
          {
            question: "What should a reducer function never do?",
            options: [
              "Return a new state",
              "Have side effects like API calls",
              "Use switch statements",
              "Return the current state"
            ],
            correct: 1
          },
          {
            question: "What does dispatch do in useReducer?",
            options: [
              "Updates state directly",
              "Sends an action to the reducer",
              "Makes API calls",
              "Renders the component"
            ],
            correct: 1
          }
        ],
        project: {
          title: "Advanced Todo App with useReducer",
          description: "Build a feature-rich todo app using useReducer for state management",
          requirements: [
            "Add, edit, delete todos",
            "Filter by status (all, active, completed)",
            "Sort by date, priority, or alphabetically",
            "Bulk operations (mark all complete, delete completed)",
            "Undo/redo functionality",
            "Save state to AsyncStorage",
            "Tags/categories for todos"
          ],
          hints: [
            "Keep a history array for undo/redo",
            "Use action creators for complex actions",
            "Implement middleware pattern for side effects",
            "Consider using Immer for easier state updates"
          ]
        }
      },
      'custom-hooks': {
        content: `
        <div class="content-section">
            <h1>Custom Hooks</h1>
            
            <div class="info-box">
                <p>Custom Hooks are JavaScript functions that start with "use" and can call other Hooks. They let you extract component logic into reusable functions, making your code more modular and easier to test.</p>
            </div>

            <h2>Basic Custom Hook</h2>
            <pre><code class="language-javascript">// useCounter.js
import { useState } from 'react';

export const useCounter = (initialValue = 0) => {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount(prev => prev + 1);
  const decrement = () => setCount(prev => prev - 1);
  const reset = () => setCount(initialValue);
  const setValue = (value) => setCount(value);

  return {
    count,
    increment,
    decrement,
    reset,
    setValue,
  };
};

// Usage
const CounterComponent = () => {
  const { count, increment, decrement, reset } = useCounter(0);

  return (
    <View>
      <Text>Count: {count}</Text>
      <Button title="+" onPress={increment} />
      <Button title="-" onPress={decrement} />
      <Button title="Reset" onPress={reset} />
    </View>
  );
};</code></pre>

            <h2>useToggle Hook</h2>
            <pre><code class="language-javascript">// useToggle.js
export const useToggle = (initialValue = false) => {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => {
    setValue(v => !v);
  }, []);

  const setTrue = useCallback(() => {
    setValue(true);
  }, []);

  const setFalse = useCallback(() => {
    setValue(false);
  }, []);

  return {
    value,
    toggle,
    setTrue,
    setFalse,
    setValue,
  };
};

// Usage
const ModalExample = () => {
  const {
    value: isModalVisible,
    setTrue: showModal,
    setFalse: hideModal,
  } = useToggle();

  return (
    <View>
      <Button title="Show Modal" onPress={showModal} />
      <Modal
        visible={isModalVisible}
        onRequestClose={hideModal}
        transparent
        animationType="slide"
      >
        <View style={styles.modalContent}>
          <Text>Modal Content</Text>
          <Button title="Close" onPress={hideModal} />
        </View>
      </Modal>
    </View>
  );
};</code></pre>

            <h2>useAsyncStorage Hook</h2>
            <pre><code class="language-javascript">// useAsyncStorage.js
export const useAsyncStorage = (key, initialValue) => {
  const [storedValue, setStoredValue] = useState(initialValue);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Load value on mount
  useEffect(() => {
    loadValue();
  }, []);

  const loadValue = async () => {
    try {
      setLoading(true);
      const item = await AsyncStorage.getItem(key);
      const value = item ? JSON.parse(item) : initialValue;
      setStoredValue(value);
    } catch (error) {
      setError(error);
      console.error(\`Error loading \${key}:\`, error);
    } finally {
      setLoading(false);
    }
  };

  const setValue = async (value) => {
    try {
      setError(null);
      const valueToStore = value instanceof Function 
        ? value(storedValue) 
        : value;
      
      setStoredValue(valueToStore);
      await AsyncStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      setError(error);
      console.error(\`Error saving \${key}:\`, error);
    }
  };

  const removeValue = async () => {
    try {
      setError(null);
      setStoredValue(initialValue);
      await AsyncStorage.removeItem(key);
    } catch (error) {
      setError(error);
      console.error(\`Error removing \${key}:\`, error);
    }
  };

  return {
    value: storedValue,
    setValue,
    removeValue,
    loading,
    error,
    refresh: loadValue,
  };
};

// Usage
const SettingsScreen = () => {
  const {
    value: settings,
    setValue: saveSettings,
    loading,
  } = useAsyncStorage('userSettings', {
    theme: 'light',
    notifications: true,
  });

  if (loading) return <ActivityIndicator />;

  return (
    <View>
      <Text>Theme: {settings.theme}</Text>
      <Switch
        value={settings.notifications}
        onValueChange={(enabled) =>
          saveSettings({ ...settings, notifications: enabled })
        }
      />
    </View>
  );
};</code></pre>

            <h2>useFetch Hook</h2>
            <pre><code class="language-javascript">// useFetch.js
export const useFetch = (url, options = {}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch(url, options);
      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
      }

      const jsonData = await response.json();
      setData(jsonData);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }, [url, JSON.stringify(options)]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const refetch = () => {
    fetchData();
  };

  return { data, loading, error, refetch };
};

// Advanced version with abort controller
export const useAdvancedFetch = (url, options = {}) => {
  const [state, setState] = useState({
    data: null,
    loading: true,
    error: null,
  });

  const abortControllerRef = useRef(null);

  const fetchData = useCallback(async () => {
    abortControllerRef.current?.abort();
    abortControllerRef.current = new AbortController();

    setState(prev => ({ ...prev, loading: true, error: null }));

    try {
      const response = await fetch(url, {
        ...options,
        signal: abortControllerRef.current.signal,
      });

      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
      }

      const data = await response.json();
      setState({ data, loading: false, error: null });
    } catch (err) {
      if (err.name !== 'AbortError') {
        setState(prev => ({ ...prev, loading: false, error: err }));
      }
    }
  }, [url, JSON.stringify(options)]);

  useEffect(() => {
    fetchData();

    return () => {
      abortControllerRef.current?.abort();
    };
  }, [fetchData]);

  return {
    ...state,
    refetch: fetchData,
  };
};</code></pre>

            <h2>useDebounce Hook</h2>
            <pre><code class="language-javascript">// useDebounce.js
export const useDebounce = (value, delay = 500) => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};

// Usage with search
const SearchScreen = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 300);
  const [results, setResults] = useState([]);
  const [searching, setSearching] = useState(false);

  useEffect(() => {
    if (debouncedSearchTerm) {
      performSearch();
    } else {
      setResults([]);
    }
  }, [debouncedSearchTerm]);

  const performSearch = async () => {
    setSearching(true);
    try {
      const response = await api.search(debouncedSearchTerm);
      setResults(response.data);
    } catch (error) {
      console.error('Search failed:', error);
    } finally {
      setSearching(false);
    }
  };

  return (
    <View>
      <TextInput
        value={searchTerm}
        onChangeText={setSearchTerm}
        placeholder="Search..."
        style={styles.searchInput}
      />
      {searching && <ActivityIndicator />}
      <FlatList
        data={results}
        renderItem={({ item }) => (
          <Text>{item.title}</Text>
        )}
      />
    </View>
  );
};</code></pre>

            <h2>useKeyboard Hook</h2>
            <pre><code class="language-javascript">// useKeyboard.js
export const useKeyboard = () => {
  const [keyboardHeight, setKeyboardHeight] = useState(0);
  const [isKeyboardVisible, setIsKeyboardVisible] = useState(false);

  useEffect(() => {
    const showSubscription = Keyboard.addListener(
      'keyboardDidShow',
      (e) => {
        setKeyboardHeight(e.endCoordinates.height);
        setIsKeyboardVisible(true);
      }
    );

    const hideSubscription = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardHeight(0);
        setIsKeyboardVisible(false);
      }
    );

    return () => {
      showSubscription.remove();
      hideSubscription.remove();
    };
  }, []);

  return {
    keyboardHeight,
    isKeyboardVisible,
  };
};

// Usage
const ChatInput = () => {
  const { keyboardHeight, isKeyboardVisible } = useKeyboard();

  return (
    <Animated.View
      style={[
        styles.inputContainer,
        {
          transform: [{
            translateY: isKeyboardVisible ? -keyboardHeight : 0
          }]
        }
      ]}
    >
      <TextInput
        placeholder="Type a message..."
        style={styles.input}
      />
      <Button title="Send" onPress={sendMessage} />
    </Animated.View>
  );
};</code></pre>

            <h2>useForm Hook</h2>
            <pre><code class="language-javascript">// useForm.js
export const useForm = (initialValues, validate) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = (name, value) => {
    setValues(prev => ({ ...prev, [name]: value }));
    
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }
  };

  const handleBlur = (name) => {
    setTouched(prev => ({ ...prev, [name]: true }));
    
    // Validate single field on blur
    if (validate) {
      const fieldError = validate({ [name]: values[name] })[name];
      if (fieldError) {
        setErrors(prev => ({ ...prev, [name]: fieldError }));
      }
    }
  };

  const handleSubmit = async (onSubmit) => {
    setIsSubmitting(true);
    
    // Validate all fields
    if (validate) {
      const validationErrors = validate(values);
      setErrors(validationErrors);
      
      if (Object.keys(validationErrors).length > 0) {
        setIsSubmitting(false);
        return;
      }
    }

    try {
      await onSubmit(values);
      // Reset form on successful submit
      setValues(initialValues);
      setTouched({});
      setErrors({});
    } catch (error) {
      console.error('Form submission error:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const resetForm = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  };

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    resetForm,
    setFieldValue: handleChange,
    setFieldError: (name, error) => 
      setErrors(prev => ({ ...prev, [name]: error })),
  };
};

// Usage
const LoginForm = () => {
  const validate = (values) => {
    const errors = {};
    
    if (!values.email) {
      errors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      errors.email = 'Email is invalid';
    }
    
    if (!values.password) {
      errors.password = 'Password is required';
    }
    
    return errors;
  };

  const form = useForm(
    { email: '', password: '' },
    validate
  );

  const handleLogin = async (values) => {
    const result = await api.login(values);
    if (result.success) {
      navigation.navigate('Home');
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Email"
        value={form.values.email}
        onChangeText={(text) => form.handleChange('email', text)}
        onBlur={() => form.handleBlur('email')}
        keyboardType="email-address"
        style={[
          styles.input,
          form.touched.email && form.errors.email && styles.inputError
        ]}
      />
      {form.touched.email && form.errors.email && (
        <Text style={styles.errorText}>{form.errors.email}</Text>
      )}

      <TextInput
        placeholder="Password"
        value={form.values.password}
        onChangeText={(text) => form.handleChange('password', text)}
        onBlur={() => form.handleBlur('password')}
        secureTextEntry
        style={[
          styles.input,
          form.touched.password && form.errors.password && styles.inputError
        ]}
      />
      {form.touched.password && form.errors.password && (
        <Text style={styles.errorText}>{form.errors.password}</Text>
      )}

      <Button
        title={form.isSubmitting ? 'Logging in...' : 'Login'}
        onPress={() => form.handleSubmit(handleLogin)}
        disabled={form.isSubmitting}
      />
    </View>
  );
};</code></pre>

            <h2>usePermissions Hook</h2>
            <pre><code class="language-javascript">// usePermissions.js
import { PermissionsAndroid, Platform } from 'react-native';

export const usePermissions = () => {
  const [permissions, setPermissions] = useState({});
  const [loading, setLoading] = useState(false);

  const checkPermission = async (permission) => {
    if (Platform.OS !== 'android') {
      return true; // iOS permissions handled differently
    }

    try {
      const granted = await PermissionsAndroid.check(permission);
      setPermissions(prev => ({ ...prev, [permission]: granted }));
      return granted;
    } catch (error) {
      console.error('Permission check error:', error);
      return false;
    }
  };

  const requestPermission = async (permission, rationale) => {
    if (Platform.OS !== 'android') {
      return true;
    }

    try {
      setLoading(true);
      const granted = await PermissionsAndroid.request(
        permission,
        rationale
      );
      
      const isGranted = granted === PermissionsAndroid.RESULTS.GRANTED;
      setPermissions(prev => ({ ...prev, [permission]: isGranted }));
      
      return isGranted;
    } catch (error) {
      console.error('Permission request error:', error);
      return false;
    } finally {
      setLoading(false);
    }
  };

  const requestMultiple = async (permissionsArray) => {
    if (Platform.OS !== 'android') {
      return true;
    }

    try {
      setLoading(true);
      const results = await PermissionsAndroid.requestMultiple(
        permissionsArray
      );
      
      const newPermissions = {};
      permissionsArray.forEach(permission => {
        newPermissions[permission] = 
          results[permission] === PermissionsAndroid.RESULTS.GRANTED;
      });
      
      setPermissions(prev => ({ ...prev, ...newPermissions }));
      
      return Object.values(newPermissions).every(granted => granted);
    } catch (error) {
      console.error('Multiple permissions request error:', error);
      return false;
    } finally {
      setLoading(false);
    }
  };

  return {
    permissions,
    loading,
    checkPermission,
    requestPermission,
    requestMultiple,
  };
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Always prefix custom hooks with "use"</li>
                    <li>Keep hooks focused on a single concern</li>
                    <li>Return an object for multiple values (better than array)</li>
                    <li>Document your custom hooks well</li>
                    <li>Test custom hooks separately from components</li>
                    <li>Use TypeScript for better type safety</li>
                </ul>
            </div>
        </div>
    `,
        quiz: [
          {
            question: "What is the naming convention for custom hooks?",
            options: [
              "They must start with 'hook'",
              "They must start with 'use'",
              "They must end with 'Hook'",
              "Any name is fine"
            ],
            correct: 1
          },
          {
            question: "What can custom hooks do?",
            options: [
              "Only return state values",
              "Only handle side effects",
              "Call other hooks and return any values",
              "Only work with useState"
            ],
            correct: 2
          },
          {
            question: "Where can you call custom hooks?",
            options: [
              "Anywhere in your code",
              "Only at the top level of React functions",
              "Inside conditionals",
              "Inside loops"
            ],
            correct: 1
          }
        ],
        project: {
          title: "Build a Custom Hook Library",
          description: "Create a collection of reusable custom hooks for common React Native patterns",
          requirements: [
            "useApi hook for API calls with loading/error states",
            "useAnimation hook for common animations",
            "useGeolocation hook for location tracking",
            "useTheme hook with theme switching",
            "useNetwork hook for connectivity status",
            "usePushNotifications hook",
            "Create TypeScript definitions for all hooks"
          ],
          hints: [
            "Consider edge cases like cleanup and error handling",
            "Make hooks configurable with options",
            "Provide good default values",
            "Include usage examples in comments"
          ]
        }
      },
      'redux': {
        content: `
        <div class="content-section">
            <h1>Redux Integration</h1>
            
            <div class="info-box">
                <p>Redux is a predictable state container for JavaScript apps. With Redux Toolkit (RTK), Redux has become much easier to use while maintaining its powerful features for managing complex application state.</p>
            </div>

            <h2>Installation</h2>
            <pre><code class="language-bash"># Install Redux Toolkit and React-Redux
npm install @reduxjs/toolkit react-redux

# Optional: Redux DevTools
npm install redux-devtools-extension</code></pre>

            <h2>Redux Store Setup</h2>
            <pre><code class="language-javascript">// store/index.js
import { configureStore } from '@reduxjs/toolkit';
import authReducer from './authSlice';
import cartReducer from './cartSlice';
import productsReducer from './productsSlice';

export const store = configureStore({
  reducer: {
    auth: authReducer,
    cart: cartReducer,
    products: productsReducer,
  },
});

// App.js
import React from 'react';
import { Provider } from 'react-redux';
import { store } from './store';
import { NavigationContainer } from '@react-navigation/native';
import RootNavigator from './navigation/RootNavigator';

export default function App() {
  return (
    <Provider store={store}>
      <NavigationContainer>
        <RootNavigator />
      </NavigationContainer>
    </Provider>
  );
}</code></pre>

            <h2>Creating Slices with Redux Toolkit</h2>
            <pre><code class="language-javascript">// store/authSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { authAPI } from '../api/auth';

// Async thunk for login
export const loginUser = createAsyncThunk(
  'auth/login',
  async ({ email, password }, { rejectWithValue }) => {
    try {
      const response = await authAPI.login(email, password);
      const { user, token } = response.data;
      
      // Save token to AsyncStorage
      await AsyncStorage.setItem('authToken', token);
      
      return { user, token };
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || 'Login failed');
    }
  }
);

// Async thunk for logout
export const logoutUser = createAsyncThunk(
  'auth/logout',
  async () => {
    await AsyncStorage.removeItem('authToken');
    return null;
  }
);

// Auth slice
const authSlice = createSlice({
  name: 'auth',
  initialState: {
    user: null,
    token: null,
    isLoading: false,
    error: null,
    isAuthenticated: false,
  },
  reducers: {
    setUser: (state, action) => {
      state.user = action.payload;
      state.isAuthenticated = !!action.payload;
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Login cases
      .addCase(loginUser.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.isLoading = false;
        state.user = action.payload.user;
        state.token = action.payload.token;
        state.isAuthenticated = true;
        state.error = null;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
        state.isAuthenticated = false;
      })
      // Logout cases
      .addCase(logoutUser.fulfilled, (state) => {
        state.user = null;
        state.token = null;
        state.isAuthenticated = false;
        state.error = null;
      });
  },
});

export const { setUser, clearError } = authSlice.actions;
export default authSlice.reducer;

// Selectors
export const selectUser = (state) => state.auth.user;
export const selectIsAuthenticated = (state) => state.auth.isAuthenticated;
export const selectAuthLoading = (state) => state.auth.isLoading;
export const selectAuthError = (state) => state.auth.error;</code></pre>

            <h2>Shopping Cart Slice</h2>
            <pre><code class="language-javascript">// store/cartSlice.js
import { createSlice } from '@reduxjs/toolkit';

const cartSlice = createSlice({
  name: 'cart',
  initialState: {
    items: [],
    totalAmount: 0,
    totalQuantity: 0,
  },
  reducers: {
    addToCart: (state, action) => {
      const newItem = action.payload;
      const existingItem = state.items.find(item => item.id === newItem.id);
      
      if (existingItem) {
        existingItem.quantity += 1;
        existingItem.totalPrice += newItem.price;
      } else {
        state.items.push({
          ...newItem,
          quantity: 1,
          totalPrice: newItem.price,
        });
      }
      
      state.totalQuantity += 1;
      state.totalAmount += newItem.price;
    },
    
    removeFromCart: (state, action) => {
      const id = action.payload;
      const existingItem = state.items.find(item => item.id === id);
      
      if (existingItem) {
        state.totalQuantity -= existingItem.quantity;
        state.totalAmount -= existingItem.totalPrice;
        state.items = state.items.filter(item => item.id !== id);
      }
    },
    
    updateQuantity: (state, action) => {
      const { id, quantity } = action.payload;
      const existingItem = state.items.find(item => item.id === id);
      
      if (existingItem) {
        const quantityDiff = quantity - existingItem.quantity;
        existingItem.quantity = quantity;
        existingItem.totalPrice = existingItem.price * quantity;
        
        state.totalQuantity += quantityDiff;
        state.totalAmount += quantityDiff * existingItem.price;
        
        // Remove item if quantity is 0
        if (quantity === 0) {
          state.items = state.items.filter(item => item.id !== id);
        }
      }
    },
    
    clearCart: (state) => {
      state.items = [];
      state.totalAmount = 0;
      state.totalQuantity = 0;
    },
  },
});

export const { 
  addToCart, 
  removeFromCart, 
  updateQuantity, 
  clearCart 
} = cartSlice.actions;

export default cartSlice.reducer;

// Selectors
export const selectCartItems = (state) => state.cart.items;
export const selectCartTotal = (state) => state.cart.totalAmount;
export const selectCartQuantity = (state) => state.cart.totalQuantity;
export const selectCartItemById = (id) => (state) => 
  state.cart.items.find(item => item.id === id);</code></pre>

            <h2>Using Redux in Components</h2>
            <pre><code class="language-javascript">// screens/LoginScreen.js
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { 
  loginUser, 
  clearError, 
  selectAuthLoading, 
  selectAuthError,
  selectIsAuthenticated 
} from '../store/authSlice';

const LoginScreen = ({ navigation }) => {
  const dispatch = useDispatch();
  const isLoading = useSelector(selectAuthLoading);
  const error = useSelector(selectAuthError);
  const isAuthenticated = useSelector(selectIsAuthenticated);
  
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  useEffect(() => {
    if (isAuthenticated) {
      navigation.navigate('Home');
    }
  }, [isAuthenticated, navigation]);

  useEffect(() => {
    // Clear error when component unmounts
    return () => {
      dispatch(clearError());
    };
  }, [dispatch]);

  const handleLogin = () => {
    dispatch(loginUser({ email, password }));
  };

  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        style={styles.input}
      />
      
      <TextInput
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        style={styles.input}
      />
      
      {error && <Text style={styles.error}>{error}</Text>}
      
      <Button
        title={isLoading ? 'Logging in...' : 'Login'}
        onPress={handleLogin}
        disabled={isLoading}
      />
    </View>
  );
};</code></pre>

            <h2>Product List with Redux</h2>
            <pre><code class="language-javascript">// store/productsSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { productsAPI } from '../api/products';

export const fetchProducts = createAsyncThunk(
  'products/fetchProducts',
  async ({ page = 1, category = '' }) => {
    const response = await productsAPI.getProducts({ page, category });
    return response.data;
  }
);

const productsSlice = createSlice({
  name: 'products',
  initialState: {
    items: [],
    currentPage: 1,
    totalPages: 1,
    isLoading: false,
    error: null,
    filters: {
      category: '',
      sortBy: 'name',
    },
  },
  reducers: {
    setFilter: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
      state.currentPage = 1; // Reset to first page when filter changes
    },
    resetFilters: (state) => {
      state.filters = {
        category: '',
        sortBy: 'name',
      };
      state.currentPage = 1;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchProducts.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        state.isLoading = false;
        state.items = action.payload.products;
        state.totalPages = action.payload.totalPages;
        state.currentPage = action.payload.currentPage;
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.error.message;
      });
  },
});

export const { setFilter, resetFilters } = productsSlice.actions;
export default productsSlice.reducer;</code></pre>

            <h2>Redux with Hooks</h2>
            <pre><code class="language-javascript">// Custom Redux hooks
import { useDispatch, useSelector } from 'react-redux';
import { addToCart, removeFromCart } from '../store/cartSlice';

// Custom hook for cart operations
export const useCart = () => {
  const dispatch = useDispatch();
  const cartItems = useSelector(state => state.cart.items);
  const totalAmount = useSelector(state => state.cart.totalAmount);
  const totalQuantity = useSelector(state => state.cart.totalQuantity);

  const addItem = (product) => {
    dispatch(addToCart(product));
  };

  const removeItem = (productId) => {
    dispatch(removeFromCart(productId));
  };

  const isInCart = (productId) => {
    return cartItems.some(item => item.id === productId);
  };

  return {
    items: cartItems,
    totalAmount,
    totalQuantity,
    addItem,
    removeItem,
    isInCart,
  };
};

// Usage in component
const ProductCard = ({ product }) => {
  const { addItem, isInCart } = useCart();
  const inCart = isInCart(product.id);

  return (
    <View style={styles.card}>
      <Image source={{ uri: product.image }} style={styles.image} />
      <Text style={styles.name}>{product.name}</Text>
      <Text style={styles.price}>{product.price}</Text>
      
      <TouchableOpacity
        style={[styles.button, inCart && styles.buttonDisabled]}
        onPress={() => !inCart && addItem(product)}
        disabled={inCart}
      >
        <Text style={styles.buttonText}>
          {inCart ? 'In Cart' : 'Add to Cart'}
        </Text>
      </TouchableOpacity>
    </View>
  );
};</code></pre>

            <h2>Redux Persist</h2>
            <pre><code class="language-javascript">// store/index.js with Redux Persist
import { configureStore } from '@reduxjs/toolkit';
import { persistStore, persistReducer } from 'redux-persist';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { combineReducers } from 'redux';
import authReducer from './authSlice';
import cartReducer from './cartSlice';

const persistConfig = {
  key: 'root',
  storage: AsyncStorage,
  whitelist: ['auth', 'cart'], // Only persist auth and cart
  blacklist: ['products'], // Don't persist products
};

const rootReducer = combineReducers({
  auth: authReducer,
  cart: cartReducer,
  products: productsReducer,
});

const persistedReducer = persistReducer(persistConfig, rootReducer);

export const store = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE'],
      },
    }),
});

export const persistor = persistStore(store);

// App.js
import { PersistGate } from 'redux-persist/integration/react';
import { persistor } from './store';

export default function App() {
  return (
    <Provider store={store}>
      <PersistGate loading={<LoadingScreen />} persistor={persistor}>
        <NavigationContainer>
          <RootNavigator />
        </NavigationContainer>
      </PersistGate>
    </Provider>
  );
}</code></pre>

            <h2>Redux DevTools</h2>
            <pre><code class="language-javascript">// Enable Redux DevTools
import { configureStore } from '@reduxjs/toolkit';

export const store = configureStore({
  reducer: {
    // your reducers
  },
  devTools: __DEV__, // Enable only in development
});

// With Reactotron (React Native debugging tool)
import Reactotron from 'reactotron-react-native';
import { reactotronRedux } from 'reactotron-redux';

Reactotron
  .configure()
  .use(reactotronRedux())
  .connect();

const store = configureStore({
  reducer: rootReducer,
  enhancers: [Reactotron.createEnhancer()],
});</code></pre>

            <h2>RTK Query</h2>
            <pre><code class="language-javascript">// api/apiSlice.js - RTK Query for API calls
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import AsyncStorage from '@react-native-async-storage/async-storage';

export const apiSlice = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({
    baseUrl: 'https://api.example.com',
    prepareHeaders: async (headers) => {
      const token = await AsyncStorage.getItem('authToken');
      if (token) {
        headers.set('authorization', \`Bearer \${token}\`);
      }
      return headers;
    },
  }),
  tagTypes: ['Product', 'User', 'Order'],
  endpoints: (builder) => ({
    getProducts: builder.query({
      query: (params) => ({
        url: '/products',
        params,
      }),
      providesTags: ['Product'],
    }),
    
    getProduct: builder.query({
      query: (id) => \`/products/\${id}\`,
      providesTags: (result, error, id) => [{ type: 'Product', id }],
    }),
    
    createOrder: builder.mutation({
      query: (orderData) => ({
        url: '/orders',
        method: 'POST',
        body: orderData,
      }),
      invalidatesTags: ['Order'],
    }),
  }),
});

export const {
  useGetProductsQuery,
  useGetProductQuery,
  useCreateOrderMutation,
} = apiSlice;

// Using RTK Query in components
const ProductList = () => {
  const { data, error, isLoading, refetch } = useGetProductsQuery({
    page: 1,
    limit: 10,
  });

  if (isLoading) return <ActivityIndicator />;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <FlatList
      data={data?.products}
      renderItem={({ item }) => <ProductCard product={item} />}
      onRefresh={refetch}
      refreshing={isLoading}
    />
  );
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Use Redux Toolkit (RTK) instead of plain Redux</li>
                    <li>Keep your Redux state normalized</li>
                    <li>Use RTK Query for API state management</li>
                    <li>Don't put everything in Redux - use local state when appropriate</li>
                    <li>Create selector functions for computed values</li>
                    <li>Use TypeScript for better type safety</li>
                </ul>
            </div>
        </div>
    `,
        quiz: [
          {
            question: "What is the recommended way to write Redux logic?",
            options: [
              "Plain Redux with manual action creators",
              "Redux Toolkit (RTK)",
              "Redux Saga only",
              "MobX instead of Redux"
            ],
            correct: 1
          },
          {
            question: "What does createSlice automatically generate?",
            options: [
              "Only reducers",
              "Only action creators",
              "Both reducers and action creators",
              "API endpoints"
            ],
            correct: 2
          },
          {
            question: "When should you use RTK Query?",
            options: [
              "For all state management",
              "For API/server state management",
              "Only for GraphQL APIs",
              "Never, use regular Redux"
            ],
            correct: 1
          }
        ],
        project: {
          title: "E-commerce App with Redux",
          description: "Build a complete e-commerce app using Redux Toolkit for state management",
          requirements: [
            "User authentication with JWT tokens",
            "Product listing with filters and search",
            "Shopping cart functionality",
            "Order management",
            "User profile and settings",
            "Wishlist feature",
            "Use RTK Query for API calls",
            "Implement Redux Persist for offline support"
          ],
          hints: [
            "Structure your store with feature-based slices",
            "Use RTK Query for all API interactions",
            "Implement proper error handling",
            "Add loading states for better UX"
          ]
        }
      },
      'zustand': {
        content: `
        <div class="content-section">
            <h1>Zustand</h1>
            
            <div class="info-box">
                <p>Zustand is a small, fast, and scalable state management solution for React. It's much simpler than Redux while still being powerful enough for complex applications. Perfect for React Native apps that need global state without boilerplate.</p>
            </div>

            <h2>Installation</h2>
            <pre><code class="language-bash"># Install Zustand
npm install zustand

# Optional: Zustand middleware
npm install immer # For immutable updates</code></pre>

            <h2>Basic Store Creation</h2>
            <pre><code class="language-javascript">// stores/useCounterStore.js
import { create } from 'zustand';

const useCounterStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
  incrementBy: (amount) => set((state) => ({ count: state.count + amount })),
}));

// Usage in component
import React from 'react';
import { View, Text, Button } from 'react-native';
import useCounterStore from './stores/useCounterStore';

const Counter = () => {
  // Subscribe to the whole store
  const { count, increment, decrement, reset } = useCounterStore();
  
  // Or subscribe to specific values
  const count = useCounterStore((state) => state.count);
  const increment = useCounterStore((state) => state.increment);

  return (
    <View>
      <Text>Count: {count}</Text>
      <Button title="+" onPress={increment} />
      <Button title="-" onPress={decrement} />
      <Button title="Reset" onPress={reset} />
    </View>
  );
};</code></pre>

            <h2>Authentication Store</h2>
            <pre><code class="language-javascript">// stores/useAuthStore.js
import { create } from 'zustand';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { authAPI } from '../api/auth';

const useAuthStore = create((set, get) => ({
  user: null,
  token: null,
  isLoading: false,
  error: null,
  isAuthenticated: false,

  // Actions
  login: async (email, password) => {
    set({ isLoading: true, error: null });
    
    try {
      const response = await authAPI.login(email, password);
      const { user, token } = response.data;
      
      // Save token to AsyncStorage
      await AsyncStorage.setItem('authToken', token);
      
      set({
        user,
        token,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      });
      
      return { success: true };
    } catch (error) {
      set({
        isLoading: false,
        error: error.message,
        isAuthenticated: false,
      });
      
      return { success: false, error: error.message };
    }
  },

  logout: async () => {
    await AsyncStorage.removeItem('authToken');
    set({
      user: null,
      token: null,
      isAuthenticated: false,
      error: null,
    });
  },

  updateUser: (userData) => {
    set((state) => ({
      user: { ...state.user, ...userData },
    }));
  },

  checkAuthStatus: async () => {
    set({ isLoading: true });
    
    try {
      const token = await AsyncStorage.getItem('authToken');
      if (token) {
        // Verify token with API
        const response = await authAPI.verifyToken(token);
        set({
          user: response.data.user,
          token,
          isAuthenticated: true,
          isLoading: false,
        });
      } else {
        set({ isLoading: false });
      }
    } catch (error) {
      await AsyncStorage.removeItem('authToken');
      set({
        isLoading: false,
        isAuthenticated: false,
      });
    }
  },

  clearError: () => set({ error: null }),
}));

export default useAuthStore;</code></pre>

            <h2>Shopping Cart Store with Persist</h2>
            <pre><code class="language-javascript">// stores/useCartStore.js
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';

const useCartStore = create(
  persist(
    (set, get) => ({
      items: [],
      
      // Computed values
      get totalAmount() {
        return get().items.reduce(
          (total, item) => total + item.price * item.quantity,
          0
        );
      },
      
      get totalQuantity() {
        return get().items.reduce(
          (total, item) => total + item.quantity,
          0
        );
      },

      // Actions
      addToCart: (product) => {
        set((state) => {
          const existingItem = state.items.find(
            item => item.id === product.id
          );

          if (existingItem) {
            return {
              items: state.items.map(item =>
                item.id === product.id
                  ? { ...item, quantity: item.quantity + 1 }
                  : item
              ),
            };
          }

          return {
            items: [...state.items, { ...product, quantity: 1 }],
          };
        });
      },

      removeFromCart: (productId) => {
        set((state) => ({
          items: state.items.filter(item => item.id !== productId),
        }));
      },

      updateQuantity: (productId, quantity) => {
        if (quantity <= 0) {
          get().removeFromCart(productId);
          return;
        }

        set((state) => ({
          items: state.items.map(item =>
            item.id === productId
              ? { ...item, quantity }
              : item
          ),
        }));
      },

      clearCart: () => set({ items: [] }),

      isInCart: (productId) => {
        return get().items.some(item => item.id === productId);
      },

      getCartItem: (productId) => {
        return get().items.find(item => item.id === productId);
      },
    }),
    {
      name: 'cart-storage',
      storage: createJSONStorage(() => AsyncStorage),
    }
  )
);

export default useCartStore;</code></pre>

            <h2>Multiple Stores Pattern</h2>
            <pre><code class="language-javascript">// stores/useAppStore.js - Combining multiple stores
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';

// User store slice
const createUserSlice = (set) => ({
  user: null,
  setUser: (user) => set({ user }),
  updateUser: (updates) => 
    set((state) => ({ user: { ...state.user, ...updates } })),
});

// Settings store slice
const createSettingsSlice = (set) => ({
  theme: 'light',
  language: 'en',
  notifications: true,
  setTheme: (theme) => set({ theme }),
  setLanguage: (language) => set({ language }),
  toggleNotifications: () => 
    set((state) => ({ notifications: !state.notifications })),
});

// UI store slice
const createUISlice = (set) => ({
  isLoading: false,
  error: null,
  modal: null,
  setLoading: (isLoading) => set({ isLoading }),
  setError: (error) => set({ error }),
  showModal: (modal) => set({ modal }),
  hideModal: () => set({ modal: null }),
});

// Combined store
const useAppStore = create(
  subscribeWithSelector((set, get) => ({
    ...createUserSlice(set),
    ...createSettingsSlice(set),
    ...createUISlice(set),
    
    // Cross-slice actions
    resetApp: () => set({
      user: null,
      theme: 'light',
      language: 'en',
      notifications: true,
      isLoading: false,
      error: null,
      modal: null,
    }),
  }))
);

export default useAppStore;

// Selectors for better performance
export const useUser = () => useAppStore((state) => state.user);
export const useTheme = () => useAppStore((state) => state.theme);
export const useIsLoading = () => useAppStore((state) => state.isLoading);</code></pre>

            <h2>Advanced Patterns with Immer</h2>
            <pre><code class="language-javascript">// stores/useTodoStore.js - Using Immer for complex updates
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

const useTodoStore = create(
  immer((set) => ({
    todos: [],
    filter: 'all', // all, active, completed

    addTodo: (text) =>
      set((state) => {
        state.todos.push({
          id: Date.now(),
          text,
          completed: false,
          createdAt: new Date().toISOString(),
        });
      }),

    toggleTodo: (id) =>
      set((state) => {
        const todo = state.todos.find(t => t.id === id);
        if (todo) {
          todo.completed = !todo.completed;
        }
      }),

    updateTodo: (id, updates) =>
      set((state) => {
        const index = state.todos.findIndex(t => t.id === id);
        if (index !== -1) {
          state.todos[index] = { ...state.todos[index], ...updates };
        }
      }),

    deleteTodo: (id) =>
      set((state) => {
        state.todos = state.todos.filter(t => t.id !== id);
      }),

    setFilter: (filter) =>
      set((state) => {
        state.filter = filter;
      }),

    clearCompleted: () =>
      set((state) => {
        state.todos = state.todos.filter(t => !t.completed);
      }),

    // Computed selector
    get filteredTodos() {
      const state = useTodoStore.getState();
      switch (state.filter) {
        case 'active':
          return state.todos.filter(t => !t.completed);
        case 'completed':
          return state.todos.filter(t => t.completed);
        default:
          return state.todos;
      }
    },
  }))
);

export default useTodoStore;</code></pre>

            <h2>Async Actions and Loading States</h2>
            <pre><code class="language-javascript">// stores/useProductStore.js
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { productsAPI } from '../api/products';

const useProductStore = create(
  devtools(
    (set, get) => ({
      products: [],
      currentProduct: null,
      isLoading: false,
      error: null,
      filters: {
        category: '',
        minPrice: 0,
        maxPrice: 1000,
      },

      // Async actions
      fetchProducts: async () => {
        set({ isLoading: true, error: null });
        
        try {
          const { filters } = get();
          const response = await productsAPI.getProducts(filters);
          set({
            products: response.data,
            isLoading: false,
          });
        } catch (error) {
          set({
            error: error.message,
            isLoading: false,
          });
        }
      },

      fetchProductById: async (id) => {
        set({ isLoading: true, error: null });
        
        try {
          const response = await productsAPI.getProduct(id);
          set({
            currentProduct: response.data,
            isLoading: false,
          });
        } catch (error) {
          set({
            error: error.message,
            isLoading: false,
          });
        }
      },

      setFilter: (filterName, value) => {
        set((state) => ({
          filters: {
            ...state.filters,
            [filterName]: value,
          },
        }));
        
        // Auto-fetch when filters change
        get().fetchProducts();
      },

      resetFilters: () => {
        set({
          filters: {
            category: '',
            minPrice: 0,
            maxPrice: 1000,
          },
        });
        get().fetchProducts();
      },
    }),
    {
      name: 'product-store', // name for devtools
    }
  )
);

export default useProductStore;</code></pre>

            <h2>Subscription and Middleware</h2>
            <pre><code class="language-javascript">// stores/useNotificationStore.js
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import PushNotification from 'react-native-push-notification';

const useNotificationStore = create(
  subscribeWithSelector((set, get) => ({
    notifications: [],
    unreadCount: 0,
    pushEnabled: true,

    addNotification: (notification) => {
      set((state) => ({
        notifications: [notification, ...state.notifications],
        unreadCount: state.unreadCount + 1,
      }));

      // Show push notification if enabled
      if (get().pushEnabled) {
        PushNotification.localNotification({
          title: notification.title,
          message: notification.message,
          playSound: true,
        });
      }
    },

    markAsRead: (id) => {
      set((state) => ({
        notifications: state.notifications.map(n =>
          n.id === id ? { ...n, read: true } : n
        ),
        unreadCount: Math.max(0, state.unreadCount - 1),
      }));
    },

    markAllAsRead: () => {
      set((state) => ({
        notifications: state.notifications.map(n => ({ ...n, read: true })),
        unreadCount: 0,
      }));
    },

    clearNotifications: () => {
      set({ notifications: [], unreadCount: 0 });
    },

    togglePushNotifications: () => {
      set((state) => ({ pushEnabled: !state.pushEnabled }));
    },
  }))
);

// Subscribe to unread count changes
useNotificationStore.subscribe(
  (state) => state.unreadCount,
  (unreadCount) => {
    // Update badge count
    PushNotification.setApplicationIconBadgeNumber(unreadCount);
  }
);

export default useNotificationStore;</code></pre>

            <h2>Testing Zustand Stores</h2>
            <pre><code class="language-javascript">// __tests__/useCartStore.test.js
import { renderHook, act } from '@testing-library/react-hooks';
import useCartStore from '../stores/useCartStore';

describe('useCartStore', () => {
  beforeEach(() => {
    // Reset store before each test
    useCartStore.setState({ items: [] });
  });

  test('should add item to cart', () => {
    const { result } = renderHook(() => useCartStore());

    act(() => {
      result.current.addToCart({
        id: 1,
        name: 'Product 1',
        price: 10,
      });
    });

    expect(result.current.items).toHaveLength(1);
    expect(result.current.items[0].quantity).toBe(1);
  });

  test('should calculate total amount', () => {
    const { result } = renderHook(() => useCartStore());

    act(() => {
      result.current.addToCart({ id: 1, price: 10 });
      result.current.addToCart({ id: 2, price: 20 });
    });

    expect(result.current.totalAmount).toBe(30);
  });

  test('should update quantity', () => {
    const { result } = renderHook(() => useCartStore());

    act(() => {
      result.current.addToCart({ id: 1, price: 10 });
      result.current.updateQuantity(1, 3);
    });

    expect(result.current.items[0].quantity).toBe(3);
  });
});</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Keep stores focused - one store per domain</li>
                    <li>Use selectors to prevent unnecessary re-renders</li>
                    <li>Leverage middleware for persistence and devtools</li>
                    <li>Use Immer for complex nested state updates</li>
                    <li>Combine stores only when they're truly related</li>
                    <li>Test your stores separately from components</li>
                </ul>
            </div>
        </div>
    `,
        quiz: [
          {
            question: "What makes Zustand different from Redux?",
            options: [
              "It requires more boilerplate",
              "It's simpler with less boilerplate",
              "It doesn't support TypeScript",
              "It can't handle async actions"
            ],
            correct: 1
          },
          {
            question: "How do you subscribe to specific state values in Zustand?",
            options: [
              "useStore.subscribe()",
              "useStore((state) => state.value)",
              "connect(mapStateToProps)",
              "useSelector()"
            ],
            correct: 1
          },
          {
            question: "What middleware helps with nested state updates?",
            options: [
              "Redux-thunk",
              "Redux-saga",
              "Immer",
              "Persist"
            ],
            correct: 2
          }
        ],
        project: {
          title: "Social Media App with Zustand",
          description: "Build a social media app using Zustand for all state management",
          requirements: [
            "User authentication and profile management",
            "Post creation with images",
            "Real-time feed updates",
            "Comments and likes functionality",
            "Notification system",
            "Dark/light theme switching",
            "Offline support with persistence",
            "Search functionality"
          ],
          hints: [
            "Create separate stores for auth, posts, and UI",
            "Use Immer for complex post updates",
            "Implement optimistic updates for likes",
            "Use subscriptions for real-time features"
          ]
        }
      },
      'mobx': {
        content: `
        <div class="content-section">
            <h1>MobX</h1>
            
            <div class="info-box">
                <p>MobX is a simple, scalable state management solution that makes state management simple again by transparently applying functional reactive programming. It's particularly powerful for complex applications with lots of derived state.</p>
            </div>

            <h2>Installation</h2>
            <pre><code class="language-bash"># Install MobX and React bindings
npm install mobx mobx-react-lite

# For React Native, you might need to configure Metro
# Add to metro.config.js:
module.exports = {
  resolver: {
    resolverMainFields: ['react-native', 'browser', 'main'],
  },
};</code></pre>

            <h2>Basic Observable State</h2>
            <pre><code class="language-javascript">// stores/CounterStore.js
import { makeAutoObservable } from 'mobx';

class CounterStore {
  count = 0;

  constructor() {
    // Make all properties observable and methods actions
    makeAutoObservable(this);
  }

  increment() {
    this.count++;
  }

  decrement() {
    this.count--;
  }

  reset() {
    this.count = 0;
  }

  incrementBy(amount) {
    this.count += amount;
  }
}

export const counterStore = new CounterStore();

// Component using MobX
import React from 'react';
import { View, Text, Button } from 'react-native';
import { observer } from 'mobx-react-lite';
import { counterStore } from './stores/CounterStore';

const Counter = observer(() => {
  return (
    <View>
      <Text>Count: {counterStore.count}</Text>
      <Button title="+" onPress={() => counterStore.increment()} />
      <Button title="-" onPress={() => counterStore.decrement()} />
      <Button title="Reset" onPress={() => counterStore.reset()} />
    </View>
  );
});

export default Counter;</code></pre>

            <h2>Complex Store with Computed Values</h2>
            <pre><code class="language-javascript">// stores/TodoStore.js
import { makeAutoObservable, runInAction } from 'mobx';
import AsyncStorage from '@react-native-async-storage/async-storage';

class TodoStore {
  todos = [];
  filter = 'all'; // all, active, completed
  isLoading = false;
  error = null;

  constructor() {
    makeAutoObservable(this);
    this.loadTodos();
  }

  // Computed values
  get filteredTodos() {
    switch (this.filter) {
      case 'active':
        return this.todos.filter(todo => !todo.completed);
      case 'completed':
        return this.todos.filter(todo => todo.completed);
      default:
        return this.todos;
    }
  }

  get activeCount() {
    return this.todos.filter(todo => !todo.completed).length;
  }

  get completedCount() {
    return this.todos.filter(todo => todo.completed).length;
  }

  get progress() {
    if (this.todos.length === 0) return 0;
    return (this.completedCount / this.todos.length) * 100;
  }

  // Actions
  addTodo(text) {
    const todo = {
      id: Date.now(),
      text,
      completed: false,
      createdAt: new Date().toISOString(),
    };
    this.todos.push(todo);
    this.saveTodos();
  }

  toggleTodo(id) {
    const todo = this.todos.find(t => t.id === id);
    if (todo) {
      todo.completed = !todo.completed;
      this.saveTodos();
    }
  }

  updateTodo(id, text) {
    const todo = this.todos.find(t => t.id === id);
    if (todo) {
      todo.text = text;
      todo.updatedAt = new Date().toISOString();
      this.saveTodos();
    }
  }

  deleteTodo(id) {
    const index = this.todos.findIndex(t => t.id === id);
    if (index !== -1) {
      this.todos.splice(index, 1);
      this.saveTodos();
    }
  }

  setFilter(filter) {
    this.filter = filter;
  }

  clearCompleted() {
    this.todos = this.todos.filter(todo => !todo.completed);
    this.saveTodos();
  }

  // Async actions
  async loadTodos() {
    this.isLoading = true;
    try {
      const todosJson = await AsyncStorage.getItem('todos');
      runInAction(() => {
        this.todos = todosJson ? JSON.parse(todosJson) : [];
        this.isLoading = false;
      });
    } catch (error) {
      runInAction(() => {
        this.error = error.message;
        this.isLoading = false;
      });
    }
  }

  async saveTodos() {
    try {
      await AsyncStorage.setItem('todos', JSON.stringify(this.todos));
    } catch (error) {
      console.error('Failed to save todos:', error);
    }
  }
}

export const todoStore = new TodoStore();</code></pre>

            <h2>Authentication Store with MobX</h2>
            <pre><code class="language-javascript">// stores/AuthStore.js
import { makeObservable, observable, action, computed, runInAction } from 'mobx';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { authAPI } from '../api/auth';

class AuthStore {
  user = null;
  token = null;
  isLoading = false;
  error = null;

  constructor() {
    makeObservable(this, {
      user: observable,
      token: observable,
      isLoading: observable,
      error: observable,
      isAuthenticated: computed,
      login: action,
      logout: action,
      updateUser: action,
      setLoading: action,
      setError: action,
    });
    
    this.checkAuthStatus();
  }

  get isAuthenticated() {
    return !!this.user && !!this.token;
  }

  setLoading(loading) {
    this.isLoading = loading;
  }

  setError(error) {
    this.error = error;
  }

  async login(email, password) {
    this.setLoading(true);
    this.setError(null);

    try {
      const response = await authAPI.login(email, password);
      const { user, token } = response.data;

      await AsyncStorage.setItem('authToken', token);

      runInAction(() => {
        this.user = user;
        this.token = token;
        this.isLoading = false;
      });

      return { success: true };
    } catch (error) {
      runInAction(() => {
        this.error = error.message;
        this.isLoading = false;
      });
      
      return { success: false, error: error.message };
    }
  }

  async logout() {
    await AsyncStorage.removeItem('authToken');
    runInAction(() => {
      this.user = null;
      this.token = null;
      this.error = null;
    });
  }

  updateUser(updates) {
    if (this.user) {
      Object.assign(this.user, updates);
    }
  }

  async checkAuthStatus() {
    this.setLoading(true);
    
    try {
      const token = await AsyncStorage.getItem('authToken');
      if (token) {
        const response = await authAPI.verifyToken(token);
        runInAction(() => {
          this.user = response.data.user;
          this.token = token;
          this.isLoading = false;
        });
      } else {
        this.setLoading(false);
      }
    } catch (error) {
      await AsyncStorage.removeItem('authToken');
      runInAction(() => {
        this.user = null;
        this.token = null;
        this.isLoading = false;
      });
    }
  }
}

export const authStore = new AuthStore();</code></pre>

            <h2>Root Store Pattern</h2>
            <pre><code class="language-javascript">// stores/RootStore.js
import { AuthStore } from './AuthStore';
import { TodoStore } from './TodoStore';
import { UIStore } from './UIStore';
import { CartStore } from './CartStore';

class RootStore {
  constructor() {
    this.authStore = new AuthStore(this);
    this.todoStore = new TodoStore(this);
    this.uiStore = new UIStore(this);
    this.cartStore = new CartStore(this);
  }

  // Cross-store actions
  async logout() {
    await this.authStore.logout();
    this.todoStore.clearTodos();
    this.cartStore.clearCart();
    this.uiStore.reset();
  }
}

export const rootStore = new RootStore();

// React Context for providing stores
import React, { createContext, useContext } from 'react';

const StoreContext = createContext(null);

export const StoreProvider = ({ children }) => {
  return (
    <StoreContext.Provider value={rootStore}>
      {children}
    </StoreContext.Provider>
  );
};

export const useStore = () => {
  const store = useContext(StoreContext);
  if (!store) {
    throw new Error('useStore must be used within StoreProvider');
  }
  return store;
};

// Usage in App.js
import { StoreProvider } from './stores/RootStore';

export default function App() {
  return (
    <StoreProvider>
      <NavigationContainer>
        <RootNavigator />
      </NavigationContainer>
    </StoreProvider>
  );
}</code></pre>

            <h2>MobX with React Hooks</h2>
            <pre><code class="language-javascript">// Custom hooks for MobX stores
import { useStore } from '../stores/RootStore';

export const useAuth = () => {
  const { authStore } = useStore();
  return authStore;
};

export const useTodos = () => {
  const { todoStore } = useStore();
  return todoStore;
};

// Component using custom hooks
import React from 'react';
import { observer } from 'mobx-react-lite';
import { useAuth, useTodos } from '../hooks/storeHooks';

const TodoScreen = observer(() => {
  const auth = useAuth();
  const todos = useTodos();
  const [newTodo, setNewTodo] = useState('');

  const handleAddTodo = () => {
    if (newTodo.trim()) {
      todos.addTodo(newTodo);
      setNewTodo('');
    }
  };

  if (!auth.isAuthenticated) {
    return <Text>Please login to view todos</Text>;
  }

  return (
    <View style={styles.container}>
      <Text>Welcome, {auth.user.name}!</Text>
      
      <View style={styles.stats}>
        <Text>Active: {todos.activeCount}</Text>
        <Text>Completed: {todos.completedCount}</Text>
        <Text>Progress: {todos.progress.toFixed(0)}%</Text>
      </View>

      <View style={styles.inputRow}>
        <TextInput
          value={newTodo}
          onChangeText={setNewTodo}
          placeholder="Add a todo..."
          style={styles.input}
        />
        <Button title="Add" onPress={handleAddTodo} />
      </View>

      <FlatList
        data={todos.filteredTodos}
        keyExtractor={item => item.id.toString()}
        renderItem={({ item }) => (
          <TodoItem
            todo={item}
            onToggle={() => todos.toggleTodo(item.id)}
            onDelete={() => todos.deleteTodo(item.id)}
          />
        )}
      />

      <View style={styles.filters}>
        {['all', 'active', 'completed'].map(filter => (
          <TouchableOpacity
            key={filter}
            onPress={() => todos.setFilter(filter)}
            style={[
              styles.filterButton,
              todos.filter === filter && styles.activeFilter,
            ]}
          >
            <Text>{filter}</Text>
          </TouchableOpacity>
        ))}
      </View>
    </View>
  );
});</code></pre>

            <h2>MobX Reactions and When</h2>
            <pre><code class="language-javascript">// stores/NotificationStore.js
import { makeAutoObservable, reaction, when } from 'mobx';
import PushNotification from 'react-native-push-notification';

class NotificationStore {
  notifications = [];
  unreadCount = 0;
  pushEnabled = true;

  constructor(rootStore) {
    this.rootStore = rootStore;
    makeAutoObservable(this);

    // Reaction: Update badge when unread count changes
    reaction(
      () => this.unreadCount,
      (count) => {
        PushNotification.setApplicationIconBadgeNumber(count);
      }
    );

    // When: Show welcome notification after first login
    when(
      () => this.rootStore.authStore.isAuthenticated,
      () => {
        this.addNotification({
          title: 'Welcome!',
          message: \`Welcome back, \${this.rootStore.authStore.user?.name}!\`,
          type: 'info',
        });
      }
    );

    // Reaction: Auto-save notifications
    reaction(
      () => this.notifications.slice(), // Create new reference
      (notifications) => {
        this.saveNotifications(notifications);
      },
      { delay: 1000 } // Debounce saves
    );
  }

  addNotification(notification) {
    const newNotification = {
      id: Date.now(),
      ...notification,
      read: false,
      timestamp: new Date().toISOString(),
    };

    this.notifications.unshift(newNotification);
    this.unreadCount++;

    if (this.pushEnabled) {
      PushNotification.localNotification({
        title: notification.title,
        message: notification.message,
        playSound: true,
      });
    }
  }

  markAsRead(id) {
    const notification = this.notifications.find(n => n.id === id);
    if (notification && !notification.read) {
      notification.read = true;
      this.unreadCount = Math.max(0, this.unreadCount - 1);
    }
  }

  async saveNotifications(notifications) {
    try {
      await AsyncStorage.setItem(
        'notifications',
        JSON.stringify(notifications.slice(0, 50)) // Keep last 50
      );
    } catch (error) {
      console.error('Failed to save notifications:', error);
    }
  }
}</code></pre>

            <h2>MobX DevTools and Debugging</h2>
            <pre><code class="language-javascript">// Enable MobX strict mode in development
import { configure } from 'mobx';

if (__DEV__) {
  configure({
    enforceActions: 'always', // Ensure state modifications happen in actions
    computedRequiresReaction: true, // Warn about unused computed values
    reactionRequiresObservable: true,
    observableRequiresReaction: true,
    disableErrorBoundaries: true,
  });
}

// Spy on all MobX events
import { spy } from 'mobx';

if (__DEV__) {
  spy((event) => {
    if (event.type === 'action') {
      console.log(\`Action: \${event.name}\`, event.arguments);
    }
  });
}

// React Native Debugger integration
import { makeAutoObservable } from 'mobx';
import remotedev from 'mobx-remotedev';

class TodoStore {
  // ... store implementation
}

// Wrap store with remotedev in development
const todoStore = __DEV__ 
  ? remotedev(new TodoStore(), { name: 'TodoStore' })
  : new TodoStore();</code></pre>

            <h2>Testing MobX Stores</h2>
            <pre><code class="language-javascript">// __tests__/TodoStore.test.js
import { TodoStore } from '../stores/TodoStore';

describe('TodoStore', () => {
  let store;

  beforeEach(() => {
    store = new TodoStore();
  });

  test('should add todo', () => {
    store.addTodo('Test todo');
    
    expect(store.todos).toHaveLength(1);
    expect(store.todos[0].text).toBe('Test todo');
    expect(store.todos[0].completed).toBe(false);
  });

  test('should compute active count', () => {
    store.addTodo('Todo 1');
    store.addTodo('Todo 2');
    store.addTodo('Todo 3');
    store.toggleTodo(store.todos[0].id);

    expect(store.activeCount).toBe(2);
    expect(store.completedCount).toBe(1);
  });

  test('should filter todos', () => {
    store.addTodo('Active todo');
    store.addTodo('Completed todo');
    store.toggleTodo(store.todos[1].id);

    store.setFilter('active');
    expect(store.filteredTodos).toHaveLength(1);
    expect(store.filteredTodos[0].text).toBe('Active todo');

    store.setFilter('completed');
    expect(store.filteredTodos).toHaveLength(1);
    expect(store.filteredTodos[0].text).toBe('Completed todo');
  });
});</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Use makeAutoObservable for simpler syntax</li>
                    <li>Keep computed values pure - no side effects</li>
                    <li>Use runInAction for async state updates</li>
                    <li>Implement root store pattern for complex apps</li>
                    <li>Use reactions sparingly - prefer computed values</li>
                    <li>Enable strict mode in development</li>
                    <li>Test stores independently from components</li>
                </ul>
            </div>
        </div>
    `,
        quiz: [
          {
            question: "What is the key concept that makes MobX reactive?",
            options: [
              "Redux actions",
              "Observable state",
              "useState hooks",
              "Context API"
            ],
            correct: 1
          },
          {
            question: "When should you use runInAction?",
            options: [
              "For all actions",
              "Only for computed values",
              "For async state updates",
              "Never"
            ],
            correct: 2
          },
          {
            question: "What does the observer HOC do?",
            options: [
              "Makes state observable",
              "Makes components re-render when observables change",
              "Creates actions",
              "Manages side effects"
            ],
            correct: 1
          }
        ],
        project: {
          title: "Real-time Dashboard with MobX",
          description: "Build a real-time analytics dashboard using MobX for reactive state management",
          requirements: [
            "Live data updates with WebSocket",
            "Multiple chart types with real-time updates",
            "Filter and sort capabilities",
            "User preferences with persistence",
            "Notification system for alerts",
            "Export data functionality",
            "Dark/light theme support",
            "Performance monitoring"
          ],
          hints: [
            "Use computed values for chart data",
            "Implement reactions for WebSocket updates",
            "Use root store pattern for organization",
            "Leverage MobX's automatic dependency tracking"
          ]
        }
      },

      'react-navigation': {
    content: `
        <div class="content-section">
            <h1>React Navigation Setup</h1>
            
            <div class="info-box">
                <p>React Navigation is the most popular navigation library for React Native. It provides a way to navigate between screens, handle the navigation stack, and manage navigation state in your app.</p>
            </div>

            <h2>Installation</h2>
            <pre><code class="language-bash"># Install the core navigation package
npm install @react-navigation/native

# Install required dependencies
npm install react-native-screens react-native-safe-area-context

# For iOS, install pods
cd ios && pod install

# Additional navigators (install as needed)
npm install @react-navigation/stack
npm install @react-navigation/bottom-tabs
npm install @react-navigation/drawer
npm install @react-navigation/material-top-tabs
npm install @react-navigation/material-bottom-tabs</code></pre>

            <h2>Android Setup</h2>
            <pre><code class="language-java">// android/app/src/main/java/.../MainActivity.java
import android.os.Bundle;

public class MainActivity extends ReactActivity {
  // Add this method
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(null);
  }
}</code></pre>

            <h2>Basic Navigation Container</h2>
            <pre><code class="language-javascript">// App.js
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';

// Import your screens
import HomeScreen from './screens/HomeScreen';
import DetailsScreen from './screens/DetailsScreen';
import ProfileScreen from './screens/ProfileScreen';

const Stack = createNativeStackNavigator();

function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator initialRouteName="Home">
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="Details" component={DetailsScreen} />
        <Stack.Screen name="Profile" component={ProfileScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}

export default App;</code></pre>

            <h2>Navigation Options</h2>
            <pre><code class="language-javascript">// Configuring screen options
<Stack.Navigator
  initialRouteName="Home"
  screenOptions={{
    headerStyle: {
      backgroundColor: '#0066ff',
    },
    headerTintColor: '#fff',
    headerTitleStyle: {
      fontWeight: 'bold',
    },
    headerBackTitle: 'Back',
    animation: 'slide_from_right', // iOS style animation
  }}
>
  <Stack.Screen 
    name="Home" 
    component={HomeScreen}
    options={{
      title: 'Welcome',
      headerRight: () => (
        <Button
          onPress={() => alert('This is a button!')}
          title="Info"
          color="#fff"
        />
      ),
    }}
  />
  
  <Stack.Screen 
    name="Details" 
    component={DetailsScreen}
    options={({ route }) => ({
      title: route.params?.title || 'Details',
      headerStyle: {
        backgroundColor: route.params?.color || '#0066ff',
      },
    })}
  />
  
  <Stack.Screen 
    name="Profile" 
    component={ProfileScreen}
    options={{
      headerShown: false, // Hide header for this screen
    }}
  />
</Stack.Navigator></code></pre>

            <h2>Basic Navigation</h2>
            <pre><code class="language-javascript">// HomeScreen.js
import React from 'react';
import { View, Text, Button, TouchableOpacity, StyleSheet } from 'react-native';

function HomeScreen({ navigation }) {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Home Screen</Text>
      
      {/* Navigate to Details */}
      <Button
        title="Go to Details"
        onPress={() => navigation.navigate('Details')}
      />
      
      {/* Navigate with params */}
      <Button
        title="Go to Details with Params"
        onPress={() => 
          navigation.navigate('Details', {
            itemId: 86,
            title: 'Custom Title',
            color: '#ff6600',
          })
        }
      />
      
      {/* Push a new instance */}
      <Button
        title="Push Details"
        onPress={() => navigation.push('Details')}
      />
      
      {/* Replace current screen */}
      <Button
        title="Replace with Profile"
        onPress={() => navigation.replace('Profile')}
      />
      
      {/* Go back (if possible) */}
      <Button
        title="Try Go Back"
        onPress={() => navigation.goBack()}
        disabled={!navigation.canGoBack()}
      />
      
      {/* Pop to top of stack */}
      <Button
        title="Pop to Top"
        onPress={() => navigation.popToTop()}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
  },
});</code></pre>

            <h2>Receiving Navigation Params</h2>
            <pre><code class="language-javascript">// DetailsScreen.js
import React, { useLayoutEffect } from 'react';
import { View, Text, Button } from 'react-native';

function DetailsScreen({ route, navigation }) {
  // Get params
  const { itemId, title, color } = route.params || {};

  // Update header dynamically
  useLayoutEffect(() => {
    navigation.setOptions({
      title: title || 'Details',
      headerStyle: {
        backgroundColor: color || '#0066ff',
      },
    });
  }, [navigation, title, color]);

  return (
    <View style={styles.container}>
      <Text>Details Screen</Text>
      <Text>Item ID: {itemId}</Text>
      
      {/* Update params */}
      <Button
        title="Update Title"
        onPress={() =>
          navigation.setParams({
            title: 'Updated Title',
          })
        }
      />
      
      {/* Navigate to same screen with different params */}
      <Button
        title="Go to Details Again"
        onPress={() =>
          navigation.push('Details', {
            itemId: Math.floor(Math.random() * 100),
          })
        }
      />
      
      {/* Go back with data */}
      <Button
        title="Go Back with Data"
        onPress={() => {
          // Pass data back to previous screen
          navigation.navigate({
            name: 'Home',
            params: { post: 'Data from Details' },
            merge: true,
          });
        }}
      />
    </View>
  );
}</code></pre>

            <h2>Navigation Lifecycle</h2>
            <pre><code class="language-javascript">import React, { useEffect } from 'react';
import { useFocusEffect } from '@react-navigation/native';

function ScreenWithLifecycle({ navigation }) {
  // Component mount/unmount
  useEffect(() => {
    console.log('Component mounted');
    
    return () => {
      console.log('Component unmounted');
    };
  }, []);

  // Screen focus/blur
  useFocusEffect(
    React.useCallback(() => {
      console.log('Screen focused');
      
      // Do something when screen is focused
      const subscription = fetchData();
      
      return () => {
        console.log('Screen blurred');
        // Clean up when screen loses focus
        subscription.unsubscribe();
      };
    }, [])
  );

  // Navigation events
  useEffect(() => {
    const unsubscribe = navigation.addListener('beforeRemove', (e) => {
      // Prevent default behavior
      e.preventDefault();

      // Prompt the user before leaving the screen
      Alert.alert(
        'Discard changes?',
        'You have unsaved changes. Are you sure to discard them and leave the screen?',
        [
          { text: "Don't leave", style: 'cancel', onPress: () => {} },
          {
            text: 'Discard',
            style: 'destructive',
            onPress: () => navigation.dispatch(e.data.action),
          },
        ]
      );
    });

    return unsubscribe;
  }, [navigation]);

  return <View>...</View>;
}</code></pre>

            <h2>Navigation State and Reset</h2>
            <pre><code class="language-javascript">import { CommonActions, StackActions } from '@react-navigation/native';

// Reset navigation state
const resetAction = CommonActions.reset({
  index: 0,
  routes: [{ name: 'Home' }],
});
navigation.dispatch(resetAction);

// Navigate to nested screen
navigation.navigate('Account', {
  screen: 'Settings',
  params: { user: 'jane' },
});

// Pop multiple screens
const popAction = StackActions.pop(2);
navigation.dispatch(popAction);

// Replace current screen
const replaceAction = StackActions.replace('Profile', {
  user: 'jane',
});
navigation.dispatch(replaceAction);

// Push new screen
const pushAction = StackActions.push('Details', {
  itemId: 123,
});
navigation.dispatch(pushAction);</code></pre>

            <h2>TypeScript Support</h2>
            <pre><code class="language-typescript">// types/navigation.ts
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { RouteProp } from '@react-navigation/native';

// Define the param list for your navigator
export type RootStackParamList = {
  Home: undefined;
  Details: {
    itemId: number;
    title?: string;
    color?: string;
  };
  Profile: {
    userId: string;
  };
};

// Navigation prop types
export type HomeScreenNavigationProp = NativeStackNavigationProp<
  RootStackParamList,
  'Home'
>;

export type DetailsScreenNavigationProp = NativeStackNavigationProp<
  RootStackParamList,
  'Details'
>;

export type DetailsScreenRouteProp = RouteProp<
  RootStackParamList,
  'Details'
>;

// Usage in components
import { HomeScreenNavigationProp } from '../types/navigation';

interface Props {
  navigation: HomeScreenNavigationProp;
}

const HomeScreen: React.FC<Props> = ({ navigation }) => {
  // TypeScript now knows the available routes and params
  navigation.navigate('Details', {
    itemId: 123,
    title: 'TypeScript Example',
  });
};</code></pre>

            <h2>Deep Linking Setup</h2>
            <pre><code class="language-javascript">// App.js
const linking = {
  prefixes: ['myapp://', 'https://myapp.com'],
  config: {
    screens: {
      Home: 'home',
      Details: {
        path: 'details/:itemId',
        parse: {
          itemId: (itemId) => parseInt(itemId, 10),
        },
      },
      Profile: 'user/:userId',
      NotFound: '*',
    },
  },
};

function App() {
  return (
    <NavigationContainer linking={linking}>
      <Stack.Navigator>
        {/* screens */}
      </Stack.Navigator>
    </NavigationContainer>
  );
}

// iOS: Add to Info.plist
<key>CFBundleURLTypes</key>
<array>
  <dict>
    <key>CFBundleURLSchemes</key>
    <array>
      <string>myapp</string>
    </array>
  </dict>
</array>

// Android: Add to AndroidManifest.xml
<intent-filter>
  <action android:name="android.intent.action.VIEW" />
  <category android:name="android.intent.category.DEFAULT" />
  <category android:name="android.intent.category.BROWSABLE" />
  <data android:scheme="myapp" />
</intent-filter></code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Always wrap your app with NavigationContainer</li>
                    <li>Use TypeScript for better type safety</li>
                    <li>Handle navigation params defensively</li>
                    <li>Clean up subscriptions in useFocusEffect</li>
                    <li>Use navigate() for going to a screen, push() for adding new instance</li>
                    <li>Implement proper deep linking for better UX</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What is the difference between navigate() and push()?",
            options: [
                "They are the same",
                "navigate() goes to existing screen or creates new, push() always adds new",
                "push() is faster",
                "navigate() only works with params"
            ],
            correct: 1
        },
        {
            question: "When should you use useFocusEffect?",
            options: [
                "For component mount/unmount",
                "For screen focus/blur events",
                "For navigation params",
                "For styling"
            ],
            correct: 1
        },
        {
            question: "What does NavigationContainer do?",
            options: [
                "Renders screens",
                "Manages navigation state and links",
                "Handles gestures",
                "Styles the header"
            ],
            correct: 1
        }
    ],
    project: {
        title: "Multi-Screen App with Navigation",
        description: "Build an app with multiple screens and proper navigation setup",
        requirements: [
            "Setup React Navigation with TypeScript",
            "Create at least 5 different screens",
            "Implement navigation with params",
            "Add custom header components",
            "Handle back navigation properly",
            "Implement deep linking",
            "Add navigation state persistence"
        ],
        hints: [
            "Use TypeScript for better type safety",
            "Create a navigation service for navigation outside components",
            "Implement proper loading states",
            "Test deep links on both platforms"
        ]
    }
},
'stack-navigator': {
    content: `
        <div class="content-section">
            <h1>Stack Navigator</h1>
            
            <div class="info-box">
                <p>Stack Navigator provides a way for your app to transition between screens where each new screen is placed on top of a stack. It's perfect for typical mobile navigation patterns.</p>
            </div>

            <h2>Installation</h2>
            <pre><code class="language-bash"># Install stack navigator
npm install @react-navigation/stack

# Additional dependencies for stack
npm install react-native-gesture-handler
npm install react-native-reanimated

# For iOS
cd ios && pod install</code></pre>

            <h2>Basic Stack Navigator</h2>
            <pre><code class="language-javascript">import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { enableScreens } from 'react-native-screens';

// Enable screens for better performance
enableScreens();

// Create stack navigator
const Stack = createStackNavigator();

// Screens
import HomeScreen from './screens/HomeScreen';
import DetailsScreen from './screens/DetailsScreen';
import SettingsScreen from './screens/SettingsScreen';

function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator
        initialRouteName="Home"
        screenOptions={{
          headerStyle: {
            backgroundColor: '#0066ff',
          },
          headerTintColor: '#fff',
          headerTitleStyle: {
            fontWeight: 'bold',
          },
        }}
      >
        <Stack.Screen 
          name="Home" 
          component={HomeScreen}
          options={{ title: 'My Home' }}
        />
        <Stack.Screen 
          name="Details" 
          component={DetailsScreen} 
        />
        <Stack.Screen 
          name="Settings" 
          component={SettingsScreen} 
        />
      </Stack.Navigator>
    </NavigationContainer>
  );
}</code></pre>

            <h2>Custom Header</h2>
            <pre><code class="language-javascript">// Custom header component
const CustomHeader = ({ scene, previous, navigation }) => {
  const { options } = scene.descriptor;
  const title = options.headerTitle ?? options.title ?? scene.route.name;

  return (
    <View style={styles.header}>
      {previous && (
        <TouchableOpacity
          onPress={navigation.goBack}
          style={styles.backButton}
        >
          <Icon name="arrow-left" size={24} color="#fff" />
        </TouchableOpacity>
      )}
      
      <Text style={styles.headerTitle}>{title}</Text>
      
      <TouchableOpacity
        onPress={() => navigation.navigate('Settings')}
        style={styles.settingsButton}
      >
        <Icon name="settings" size={24} color="#fff" />
      </TouchableOpacity>
    </View>
  );
};

// Using custom header
<Stack.Navigator
  screenOptions={{
    header: (props) => <CustomHeader {...props} />,
  }}
>
  {/* screens */}
</Stack.Navigator>

// Or for specific screen
<Stack.Screen 
  name="Home" 
  component={HomeScreen}
  options={{
    header: (props) => <CustomHeader {...props} />,
  }}
/></code></pre>

            <h2>Animation Configurations</h2>
            <pre><code class="language-javascript">import { 
  CardStyleInterpolators,
  TransitionSpecs,
  HeaderStyleInterpolators
} from '@react-navigation/stack';

// Predefined animations
<Stack.Navigator
  screenOptions={{
    cardStyleInterpolator: CardStyleInterpolators.forHorizontalIOS,
    // Other options:
    // CardStyleInterpolators.forVerticalIOS
    // CardStyleInterpolators.forModalPresentationIOS
    // CardStyleInterpolators.forFadeFromBottomAndroid
    // CardStyleInterpolators.forRevealFromBottomAndroid
  }}
>

// Custom animation
const customTransition = {
  gestureEnabled: true,
  gestureDirection: 'horizontal',
  transitionSpec: {
    open: TransitionSpecs.TransitionIOSSpec,
    close: TransitionSpecs.TransitionIOSSpec,
  },
  cardStyleInterpolator: ({ current, next, layouts }) => {
    return {
      cardStyle: {
        transform: [
          {
            translateX: current.progress.interpolate({
              inputRange: [0, 1],
              outputRange: [layouts.screen.width, 0],
            }),
          },
          {
            scale: next
              ? next.progress.interpolate({
                  inputRange: [0, 1],
                  outputRange: [1, 0.9],
                })
              : 1,
          },
        ],
      },
      overlayStyle: {
        opacity: current.progress.interpolate({
          inputRange: [0, 1],
          outputRange: [0, 0.5],
        }),
      },
    };
  },
};

<Stack.Screen 
  name="Details" 
  component={DetailsScreen}
  options={customTransition}
/></code></pre>

            <h2>Modal Presentation</h2>
            <pre><code class="language-javascript">// Modal stack configuration
function RootStack() {
  return (
    <Stack.Navigator mode="modal" headerMode="none">
      <Stack.Screen 
        name="Main" 
        component={MainStack} 
      />
      <Stack.Screen 
        name="Modal" 
        component={ModalScreen}
        options={{
          cardStyleInterpolator: CardStyleInterpolators.forModalPresentationIOS,
        }}
      />
    </Stack.Navigator>
  );
}

// Alternative: Using presentation prop
<Stack.Navigator>
  <Stack.Group>
    <Stack.Screen name="Home" component={HomeScreen} />
    <Stack.Screen name="Details" component={DetailsScreen} />
  </Stack.Group>
  
  <Stack.Group screenOptions={{ presentation: 'modal' }}>
    <Stack.Screen name="Modal" component={ModalScreen} />
    <Stack.Screen name="Modal2" component={Modal2Screen} />
  </Stack.Group>
  
  <Stack.Group screenOptions={{ presentation: 'transparentModal' }}>
    <Stack.Screen 
      name="Overlay" 
      component={OverlayScreen}
      options={{
        cardStyle: { backgroundColor: 'transparent' },
        cardOverlayEnabled: true,
      }}
    />
  </Stack.Group>
</Stack.Navigator></code></pre>

            <h2>Conditional Navigation</h2>
            <pre><code class="language-javascript">// Auth flow example
function Navigation() {
  const { user, isLoading } = useAuth();

  if (isLoading) {
    return <SplashScreen />;
  }

  return (
    <NavigationContainer>
      <Stack.Navigator screenOptions={{ headerShown: false }}>
        {user ? (
          // User is signed in
          <>
            <Stack.Screen name="Home" component={HomeScreen} />
            <Stack.Screen name="Profile" component={ProfileScreen} />
            <Stack.Screen name="Settings" component={SettingsScreen} />
          </>
        ) : (
          // No user, show auth screens
          <>
            <Stack.Screen 
              name="SignIn" 
              component={SignInScreen}
              options={{
                animationTypeForReplace: !user ? 'pop' : 'push',
              }}
            />
            <Stack.Screen name="SignUp" component={SignUpScreen} />
            <Stack.Screen name="ForgotPassword" component={ForgotPasswordScreen} />
          </>
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
}</code></pre>

            <h2>Nested Stack Navigators</h2>
            <pre><code class="language-javascript">// Main stack
const MainStack = createStackNavigator();
const SettingsStack = createStackNavigator();
const ProfileStack = createStackNavigator();

function SettingsStackScreen() {
  return (
    <SettingsStack.Navigator>
      <SettingsStack.Screen 
        name="SettingsHome" 
        component={SettingsHomeScreen} 
      />
      <SettingsStack.Screen 
        name="AccountSettings" 
        component={AccountSettingsScreen} 
      />
      <SettingsStack.Screen 
        name="NotificationSettings" 
        component={NotificationSettingsScreen} 
      />
    </SettingsStack.Navigator>
  );
}

function ProfileStackScreen() {
  return (
    <ProfileStack.Navigator>
      <ProfileStack.Screen 
        name="ProfileHome" 
        component={ProfileHomeScreen} 
      />
      <ProfileStack.Screen 
        name="EditProfile" 
        component={EditProfileScreen} 
      />
      <ProfileStack.Screen 
        name="Following" 
        component={FollowingScreen} 
      />
    </ProfileStack.Navigator>
  );
}

// Root navigator
function App() {
  return (
    <NavigationContainer>
      <MainStack.Navigator>
        <MainStack.Screen 
          name="Home" 
          component={HomeScreen} 
        />
        <MainStack.Screen 
          name="Settings" 
          component={SettingsStackScreen}
          options={{ headerShown: false }}
        />
        <MainStack.Screen 
          name="Profile" 
          component={ProfileStackScreen}
          options={{ headerShown: false }}
        />
      </MainStack.Navigator>
    </NavigationContainer>
  );
}</code></pre>

            <h2>Advanced Header Options</h2>
            <pre><code class="language-javascript">// Dynamic header with scroll
function ScrollableScreen({ navigation }) {
  const scrollY = useRef(new Animated.Value(0)).current;

  useLayoutEffect(() => {
    navigation.setOptions({
      headerStyle: {
        elevation: 0,
        shadowOpacity: 0,
        borderBottomWidth: 0,
      },
      headerBackground: () => (
        <Animated.View
          style={{
            backgroundColor: '#0066ff',
            ...StyleSheet.absoluteFillObject,
            opacity: scrollY.interpolate({
              inputRange: [0, 100],
              outputRange: [0, 1],
              extrapolate: 'clamp',
            }),
          }}
        />
      ),
      headerTransparent: true,
    });
  }, [navigation, scrollY]);

  return (
    <Animated.ScrollView
      onScroll={Animated.event(
        [{ nativeEvent: { contentOffset: { y: scrollY } } }],
        { useNativeDriver: false }
      )}
      scrollEventThrottle={16}
    >
      {/* Content */}
    </Animated.ScrollView>
  );
}

// Floating header
<Stack.Screen 
  name="Floating" 
  component={FloatingScreen}
  options={{
    headerTransparent: true,
    headerBackground: () => (
      <BlurView
        style={StyleSheet.absoluteFill}
        blurType="light"
        blurAmount={10}
      />
    ),
    headerTintColor: '#000',
  }}
/></code></pre>

            <h2>Gesture Configuration</h2>
            <pre><code class="language-javascript">// Configure gestures
<Stack.Screen 
  name="Details" 
  component={DetailsScreen}
  options={{
    gestureEnabled: true,
    gestureDirection: 'horizontal',
    gestureResponseDistance: {
      horizontal: 200, // default is 135
      vertical: 135,
    },
    gestureVelocityImpact: 0.3, // default is 0.3
    
    // Custom gesture handler
    onGestureStart: () => {
      console.log('Gesture started');
    },
    onGestureCanceled: () => {
      console.log('Gesture canceled');
    },
    onGestureEnd: () => {
      console.log('Gesture ended');
    },
  }}
/>

// Disable swipe back on specific screen
<Stack.Screen 
  name="Form" 
  component={FormScreen}
  options={{
    gestureEnabled: false,
  }}
  listeners={{
    beforeRemove: (e) => {
      if (!hasUnsavedChanges) {
        return;
      }

      e.preventDefault();
      
      Alert.alert(
        'Discard changes?',
        'You have unsaved changes. Discard them?',
        [
          { text: "Cancel", style: 'cancel' },
          { 
            text: 'Discard', 
            style: 'destructive',
            onPress: () => navigation.dispatch(e.data.action)
          },
        ]
      );
    },
  }}
/></code></pre>

            <h2>Performance Optimization</h2>
            <pre><code class="language-javascript">// Use React.memo for screens
const HomeScreen = React.memo(({ navigation }) => {
  return (
    <View>
      {/* Screen content */}
    </View>
  );
});

// Lazy load screens
const ProfileScreen = React.lazy(() => import('./screens/ProfileScreen'));

<Stack.Screen 
  name="Profile" 
  component={ProfileScreen}
  options={{
    lazy: true,
  }}
/>

// Optimize large lists in stack
const ListScreen = () => {
  const navigation = useNavigation();
  
  return (
    <FlatList
      data={data}
      removeClippedSubviews={true}
      maxToRenderPerBatch={10}
      windowSize={10}
      initialNumToRender={10}
      renderItem={({ item }) => (
        <TouchableOpacity
          onPress={() => navigation.push('Details', { item })}
        >
          <Text>{item.title}</Text>
        </TouchableOpacity>
      )}
    />
  );
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Use enableScreens() for better performance</li>
                    <li>Implement proper loading states during navigation</li>
                    <li>Handle gesture conflicts with ScrollView</li>
                    <li>Use headerMode and mode props wisely</li>
                    <li>Optimize heavy screens with lazy loading</li>
                    <li>Test animations on low-end devices</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What is the purpose of CardStyleInterpolators?",
            options: [
                "To style the card component",
                "To define screen transition animations",
                "To handle gestures",
                "To configure headers"
            ],
            correct: 1
        },
        {
            question: "How do you create a modal presentation?",
            options: [
                "Use mode='modal' on Stack.Navigator",
                "Use presentation='modal' in screenOptions",
                "Both A and B",
                "Use isModal={true}"
            ],
            correct: 2
        },
        {
            question: "What does gestureResponseDistance control?",
            options: [
                "Animation speed",
                "Distance from edge to start gesture",
                "Swipe velocity",
                "Screen size"
            ],
            correct: 1
        }
    ],
    project: {
        title: "Instagram-like Navigation",
        description: "Build an Instagram-style app with complex stack navigation",
        requirements: [
            "Home feed with push to details",
            "Modal presentation for create post",
            "Nested stacks for profile sections",
            "Custom transitions between screens",
            "Floating/transparent headers",
            "Gesture handling with form validation",
            "Image viewer with swipe to dismiss"
        ],
        hints: [
            "Use presentation modes effectively",
            "Implement custom transitions for image viewer",
            "Handle back gesture on forms with unsaved changes",
            "Optimize list performance with proper FlatList config"
        ]
    }
},
'tab-navigator': {
    content: `
        <div class="content-section">
            <h1>Tab Navigator</h1>
            
            <div class="info-box">
                <p>Tab Navigator is used to create tab-based navigation, commonly found at the bottom of mobile apps. It allows users to quickly switch between different sections of your app.</p>
            </div>

            <h2>Installation</h2>
            <pre><code class="language-bash"># Install bottom tabs
npm install @react-navigation/bottom-tabs

# For Material Bottom Tabs (Android style)
npm install @react-navigation/material-bottom-tabs react-native-paper

# For Material Top Tabs
npm install @react-navigation/material-top-tabs react-native-tab-view

# Additional dependencies
npm install react-native-vector-icons

# iOS setup for vector icons
cd ios && pod install</code></pre>

            <h2>Basic Bottom Tab Navigator</h2>
            <pre><code class="language-javascript">import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import Icon from 'react-native-vector-icons/Ionicons';

// Import screens
import HomeScreen from './screens/HomeScreen';
import SearchScreen from './screens/SearchScreen';
import NotificationScreen from './screens/NotificationScreen';
import ProfileScreen from './screens/ProfileScreen';

const Tab = createBottomTabNavigator();

function App() {
  return (
    <NavigationContainer>
      <Tab.Navigator
        screenOptions={({ route }) => ({
          tabBarIcon: ({ focused, color, size }) => {
            let iconName;

            if (route.name === 'Home') {
              iconName = focused ? 'home' : 'home-outline';
            } else if (route.name === 'Search') {
              iconName = focused ? 'search' : 'search-outline';
            } else if (route.name === 'Notifications') {
              iconName = focused ? 'notifications' : 'notifications-outline';
            } else if (route.name === 'Profile') {
              iconName = focused ? 'person' : 'person-outline';
            }

            return <Icon name={iconName} size={size} color={color} />;
          },
          tabBarActiveTintColor: '#0066ff',
          tabBarInactiveTintColor: 'gray',
          tabBarShowLabel: true,
          tabBarStyle: {
            backgroundColor: '#fff',
            borderTopWidth: 1,
            borderTopColor: '#e0e0e0',
            paddingBottom: 5,
            paddingTop: 5,
            height: 60,
          },
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} />
        <Tab.Screen name="Search" component={SearchScreen} />
        <Tab.Screen 
          name="Notifications" 
          component={NotificationScreen}
          options={{
            tabBarBadge: 3, // Show badge with number
          }}
        />
        <Tab.Screen name="Profile" component={ProfileScreen} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}</code></pre>

            <h2>Custom Tab Bar</h2>
            <pre><code class="language-javascript">// Custom tab bar component
const CustomTabBar = ({ state, descriptors, navigation }) => {
  return (
    <View style={styles.tabBar}>
      {state.routes.map((route, index) => {
        const { options } = descriptors[route.key];
        const label = options.tabBarLabel ?? options.title ?? route.name;
        const isFocused = state.index === index;

        const onPress = () => {
          const event = navigation.emit({
            type: 'tabPress',
            target: route.key,
            canPreventDefault: true,
          });

          if (!isFocused && !event.defaultPrevented) {
            navigation.navigate(route.name);
          }
        };

        const onLongPress = () => {
          navigation.emit({
            type: 'tabLongPress',
            target: route.key,
          });
        };

        return (
          <TouchableOpacity
            key={index}
            accessibilityRole="button"
            accessibilityState={isFocused ? { selected: true } : {}}
            accessibilityLabel={options.tabBarAccessibilityLabel}
            testID={options.tabBarTestID}
            onPress={onPress}
            onLongPress={onLongPress}
            style={styles.tabItem}
          >
            <Animated.View
              style={[
                styles.iconContainer,
                {
                  transform: [
                    {
                      scale: isFocused
                        ? withSpring(1.2)
                        : withSpring(1)
                    },
                  ],
                },
              ]}
            >
              {options.tabBarIcon({
                focused: isFocused,
                color: isFocused ? '#0066ff' : '#666',
                size: 24,
              })}
            </Animated.View>
            
            <Animated.Text
              style={[
                styles.label,
                {
                  color: isFocused ? '#0066ff' : '#666',
                  opacity: isFocused ? 1 : 0.7,
                },
              ]}
            >
              {label}
            </Animated.Text>
            
            {options.tabBarBadge && (
              <View style={styles.badge}>
                <Text style={styles.badgeText}>{options.tabBarBadge}</Text>
              </View>
            )}
          </TouchableOpacity>
        );
      })}
    </View>
  );
};

// Use custom tab bar
<Tab.Navigator tabBar={(props) => <CustomTabBar {...props} />}>
  {/* screens */}
</Tab.Navigator></code></pre>

            <h2>Material Bottom Tabs</h2>
            <pre><code class="language-javascript">import { createMaterialBottomTabNavigator } from '@react-navigation/material-bottom-tabs';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';

const Tab = createMaterialBottomTabNavigator();

function MaterialBottomTabs() {
  return (
    <Tab.Navigator
      initialRouteName="Home"
      activeColor="#fff"
      inactiveColor="#95a5a6"
      barStyle={{ backgroundColor: '#0066ff' }}
      shifting={true} // Enable shifting animation
    >
      <Tab.Screen
        name="Home"
        component={HomeScreen}
        options={{
          tabBarLabel: 'Home',
          tabBarColor: '#0066ff', // Color when this tab is active
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="home" color={color} size={26} />
          ),
        }}
      />
      <Tab.Screen
        name="Search"
        component={SearchScreen}
        options={{
          tabBarLabel: 'Search',
          tabBarColor: '#9b59b6',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="magnify" color={color} size={26} />
          ),
        }}
      />
      <Tab.Screen
        name="Notifications"
        component={NotificationScreen}
        options={{
          tabBarLabel: 'Updates',
          tabBarColor: '#e74c3c',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="bell" color={color} size={26} />
          ),
          tabBarBadge: true, // Show dot badge
        }}
      />
      <Tab.Screen
        name="Profile"
        component={ProfileScreen}
        options={{
          tabBarLabel: 'Profile',
          tabBarColor: '#27ae60',
          tabBarIcon: ({ color }) => (
            <MaterialCommunityIcons name="account" color={color} size={26} />
          ),
        }}
      />
    </Tab.Navigator>
  );
}</code></pre>

            <h2>Top Tab Navigator</h2>
            <pre><code class="language-javascript">import { createMaterialTopTabNavigator } from '@react-navigation/material-top-tabs';

const TopTab = createMaterialTopTabNavigator();

function TopTabNavigator() {
  return (
    <TopTab.Navigator
      initialRouteName="Feed"
      screenOptions={{
        tabBarActiveTintColor: '#0066ff',
        tabBarInactiveTintColor: '#666',
        tabBarLabelStyle: { 
          fontSize: 12,
          fontWeight: 'bold',
        },
        tabBarStyle: { 
          backgroundColor: '#fff',
          elevation: 0,
          shadowOpacity: 0,
          borderBottomWidth: 1,
          borderBottomColor: '#e0e0e0',
        },
        tabBarIndicatorStyle: {
          backgroundColor: '#0066ff',
          height: 3,
        },
        tabBarPressColor: '#e0e0e0',
        swipeEnabled: true,
        lazy: true, // Lazy load tabs
      }}
    >
      <TopTab.Screen 
        name="Feed" 
        component={FeedScreen}
        options={{ tabBarLabel: 'Feed' }}
      />
      <TopTab.Screen 
        name="Following" 
        component={FollowingScreen}
        options={{ tabBarLabel: 'Following' }}
      />
      <TopTab.Screen 
        name="Trending" 
        component={TrendingScreen}
        options={{ tabBarLabel: 'Trending' }}
      />
    </TopTab.Navigator>
  );
}

// Custom tab bar for top tabs
function CustomTopTabBar({ state, descriptors, navigation, position }) {
  const inputRange = state.routes.map((_, i) => i);

  return (
    <View style={styles.topTabBar}>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        style={styles.scrollView}
      >
        {state.routes.map((route, index) => {
          const { options } = descriptors[route.key];
          const label = options.tabBarLabel ?? route.name;
          const isFocused = state.index === index;

          const onPress = () => {
            navigation.navigate(route.name);
          };

          const opacity = position.interpolate({
            inputRange,
            outputRange: inputRange.map(i => (i === index ? 1 : 0.5)),
          });

          return (
            <TouchableOpacity
              key={index}
              onPress={onPress}
              style={styles.topTabItem}
            >
              <Animated.Text
                style={[
                  styles.topTabLabel,
                  { opacity },
                  isFocused && styles.activeLabel,
                ]}
              >
                {label}
              </Animated.Text>
            </TouchableOpacity>
          );
        })}
      </ScrollView>
      
      <Animated.View
        style={[
          styles.indicator,
          {
            transform: [{
              translateX: position.interpolate({
                inputRange,
                outputRange: inputRange.map(i => i * 100),
              }),
            }],
          },
        ]}
      />
    </View>
  );
}</code></pre>

            <h2>Nested Navigation with Tabs</h2>
            <pre><code class="language-javascript">// Combining Stack and Tab navigators
const HomeStack = createStackNavigator();
const SearchStack = createStackNavigator();
const ProfileStack = createStackNavigator();

function HomeStackScreen() {
  return (
    <HomeStack.Navigator>
      <HomeStack.Screen name="HomeMain" component={HomeScreen} />
      <HomeStack.Screen name="Details" component={DetailsScreen} />
      <HomeStack.Screen name="Comments" component={CommentsScreen} />
    </HomeStack.Navigator>
  );
}

function SearchStackScreen() {
  return (
    <SearchStack.Navigator>
      <SearchStack.Screen name="SearchMain" component={SearchScreen} />
      <SearchStack.Screen name="SearchResults" component={SearchResultsScreen} />
      <SearchStack.Screen name="Filter" component={FilterScreen} />
    </SearchStack.Navigator>
  );
}

function TabNavigator() {
  return (
    <Tab.Navigator
      screenOptions={{
        headerShown: false, // Hide tab navigator header
      }}
    >
      <Tab.Screen 
        name="HomeTab" 
        component={HomeStackScreen}
        options={{
          tabBarLabel: 'Home',
          tabBarIcon: ({ color, size }) => (
            <Icon name="home" size={size} color={color} />
          ),
        }}
      />
      <Tab.Screen 
        name="SearchTab" 
        component={SearchStackScreen}
        options={{
          tabBarLabel: 'Search',
          tabBarIcon: ({ color, size }) => (
            <Icon name="search" size={size} color={color} />
          ),
        }}
      />
      <Tab.Screen 
        name="ProfileTab" 
        component={ProfileStackScreen}
        options={{
          tabBarLabel: 'Profile',
          tabBarIcon: ({ color, size }) => (
            <Icon name="person" size={size} color={color} />
          ),
        }}
      />
    </Tab.Navigator>
  );
}</code></pre>

            <h2>Dynamic Tab Bar</h2>
            <pre><code class="language-javascript">// Hide tab bar on specific screens
function TabNavigator({ navigation, route }) {
  const routeName = getFocusedRouteNameFromRoute(route);

  React.useLayoutEffect(() => {
    if (routeName === 'Details' || routeName === 'Camera') {
      navigation.setOptions({ tabBarStyle: { display: 'none' } });
    } else {
      navigation.setOptions({ tabBarStyle: { display: 'flex' } });
    }
  }, [navigation, routeName]);

  return (
    <Tab.Navigator>
      {/* tab screens */}
    </Tab.Navigator>
  );
}

// Dynamic tabs based on user role
function DynamicTabs() {
  const { user } = useAuth();

  return (
    <Tab.Navigator>
      <Tab.Screen name="Home" component={HomeScreen} />
      <Tab.Screen name="Search" component={SearchScreen} />
      
      {user?.role === 'admin' && (
        <Tab.Screen 
          name="Admin" 
          component={AdminScreen}
          options={{
            tabBarIcon: ({ color, size }) => (
              <Icon name="settings" size={size} color={color} />
            ),
          }}
        />
      )}
      
      {user?.isPremium && (
        <Tab.Screen 
          name="Premium" 
          component={PremiumScreen}
          options={{
            tabBarIcon: ({ color, size }) => (
              <Icon name="star" size={size} color={color} />
            ),
          }}
        />
      )}
      
      <Tab.Screen name="Profile" component={ProfileScreen} />
    </Tab.Navigator>
  );
}</code></pre>

            <h2>Tab Bar Animations</h2>
            <pre><code class="language-javascript">// Animated tab bar with custom animations
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withSpring,
  withTiming,
} from 'react-native-reanimated';

const AnimatedTabBar = ({ state, navigation }) => {
  const translateX = useSharedValue(0);

  React.useEffect(() => {
    translateX.value = withSpring(state.index * (SCREEN_WIDTH / 4));
  }, [state.index]);

  const animatedIndicatorStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: translateX.value }],
  }));

  return (
    <View style={styles.animatedTabBar}>
      <Animated.View style={[styles.indicator, animatedIndicatorStyle]} />
      
      {state.routes.map((route, index) => {
        const isFocused = state.index === index;
        const scale = useSharedValue(isFocused ? 1 : 0.8);

        React.useEffect(() => {
          scale.value = withSpring(isFocused ? 1.2 : 1);
        }, [isFocused]);

        const animatedIconStyle = useAnimatedStyle(() => ({
          transform: [{ scale: scale.value }],
        }));

        return (
          <TouchableOpacity
            key={route.key}
            onPress={() => navigation.navigate(route.name)}
            style={styles.animatedTabItem}
          >
            <Animated.View style={animatedIconStyle}>
              <Icon
                name={getIconName(route.name, isFocused)}
                size={24}
                color={isFocused ? '#0066ff' : '#666'}
              />
            </Animated.View>
          </TouchableOpacity>
        );
      })}
    </View>
  );
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Use lazy loading for better performance</li>
                    <li>Implement proper badge management</li>
                    <li>Consider accessibility for tab navigation</li>
                    <li>Test swipe gestures with top tabs</li>
                    <li>Hide tab bar on screens where it's not needed</li>
                    <li>Use proper icons that clearly represent sections</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the difference between shifting and non-shifting material bottom tabs?",
            options: [
                "Shifting changes tab colors, non-shifting doesn't",
                "Shifting shows labels only for active tab",
                "Both A and B",
                "There's no difference"
            ],
            correct: 2
        },
        {
            question: "How do you hide the tab bar on specific screens?",
            options: [
                "Set tabBarVisible: false",
                "Use display: 'none' in tabBarStyle",
                "Remove the screen from tabs",
                "Use hideTabBar prop"
            ],
            correct: 1
        },
        {
            question: "What does the lazy prop do in tab navigators?",
            options: [
                "Makes animations slower",
                "Delays tab rendering until focused",
                "Disables swipe gestures",
                "Reduces tab bar height"
            ],
            correct: 1
        }
    ],
    project: {
        title: "Social Media App Navigation",
        description: "Build a social media app with complex tab navigation like Instagram or Twitter",
        requirements: [
            "Bottom tabs with custom icons and badges",
            "Top tabs within home screen for different feeds",
            "Nested stack navigation within each tab",
            "Custom animated tab bar",
            "Hide tab bar on detail screens",
            "Profile tab with top tabs for posts/followers",
            "Dynamic tabs based on user permissions"
        ],
        hints: [
            "Use getFocusedRouteNameFromRoute for nested navigation",
            "Implement proper lazy loading for performance",
            "Create reusable tab bar component",
            "Handle deep linking to nested screens"
        ]
    }
},
'drawer-navigator': {
    content: `
        <div class="content-section">
            <h1>Drawer Navigator</h1>
            
            <div class="info-box">
                <p>Drawer Navigator provides a sliding panel navigation pattern, commonly accessed via a hamburger menu. It's perfect for apps with many sections or settings that don't need to be accessed frequently.</p>
            </div>

            <h2>Installation</h2>
            <pre><code class="language-bash"># Install drawer navigator
npm install @react-navigation/drawer

# Required dependencies
npm install react-native-gesture-handler react-native-reanimated

# iOS setup
cd ios && pod install

# Add to the top of your app entry file (index.js or App.js)
import 'react-native-gesture-handler';</code></pre>

            <h2>Basic Drawer Navigator</h2>
            <pre><code class="language-javascript">import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import Icon from 'react-native-vector-icons/MaterialIcons';

// Import screens
import HomeScreen from './screens/HomeScreen';
import ProfileScreen from './screens/ProfileScreen';
import SettingsScreen from './screens/SettingsScreen';
import AboutScreen from './screens/AboutScreen';

const Drawer = createDrawerNavigator();

function App() {
  return (
    <NavigationContainer>
      <Drawer.Navigator
        initialRouteName="Home"
        screenOptions={{
          drawerStyle: {
            backgroundColor: '#f5f5f5',
            width: 280,
          },
          drawerLabelStyle: {
            marginLeft: -20,
            fontSize: 16,
          },
          drawerActiveBackgroundColor: '#0066ff',
          drawerActiveTintColor: '#fff',
          drawerInactiveTintColor: '#333',
          headerStyle: {
            backgroundColor: '#0066ff',
          },
          headerTintColor: '#fff',
        }}
      >
        <Drawer.Screen 
          name="Home" 
          component={HomeScreen}
          options={{
            drawerIcon: ({ focused, color, size }) => (
              <Icon 
                name="home" 
                size={size} 
                color={color} 
              />
            ),
          }}
        />
        <Drawer.Screen 
          name="Profile" 
          component={ProfileScreen}
          options={{
            drawerIcon: ({ focused, color, size }) => (
              <Icon 
                name="person" 
                size={size} 
                color={color} 
              />
            ),
          }}
        />
        <Drawer.Screen 
          name="Settings" 
          component={SettingsScreen}
          options={{
            drawerIcon: ({ focused, color, size }) => (
              <Icon 
                name="settings" 
                size={size} 
                color={color} 
              />
            ),
          }}
        />
        <Drawer.Screen 
          name="About" 
          component={AboutScreen}
          options={{
            drawerIcon: ({ focused, color, size }) => (
              <Icon 
                name="info" 
                size={size} 
                color={color} 
              />
            ),
          }}
        />
      </Drawer.Navigator>
    </NavigationContainer>
  );
}</code></pre>

            <h2>Custom Drawer Content</h2>
            <pre><code class="language-javascript">import {
  DrawerContentScrollView,
  DrawerItemList,
  DrawerItem,
} from '@react-navigation/drawer';

function CustomDrawerContent(props) {
  const { user } = useAuth();
  
  return (
    <DrawerContentScrollView {...props}>
      {/* User Header */}
      <View style={styles.drawerHeader}>
        <Image 
          source={{ uri: user?.avatar }} 
          style={styles.avatar}
        />
        <Text style={styles.userName}>{user?.name}</Text>
        <Text style={styles.userEmail}>{user?.email}</Text>
      </View>
      
      {/* Drawer Items */}
      <DrawerItemList {...props} />
      
      {/* Custom Items */}
      <DrawerItem
        label="Help Center"
        icon={({ color, size }) => (
          <Icon name="help-outline" size={size} color={color} />
        )}
        onPress={() => props.navigation.navigate('Help')}
      />
      
      <DrawerItem
        label="Rate App"
        icon={({ color, size }) => (
          <Icon name="star-outline" size={size} color={color} />
        )}
        onPress={() => {
          // Open app store
          Linking.openURL('market://details?id=com.yourapp');
        }}
      />
      
      {/* Logout Section */}
      <View style={styles.logoutSection}>
        <DrawerItem
          label="Logout"
          icon={({ color, size }) => (
            <Icon name="logout" size={size} color={color} />
          )}
          labelStyle={{ color: '#e74c3c' }}
          onPress={async () => {
            await logout();
            props.navigation.reset({
              index: 0,
              routes: [{ name: 'Login' }],
            });
          }}
        />
      </View>
      
      {/* App Version */}
      <View style={styles.appVersion}>
        <Text style={styles.versionText}>Version 1.0.0</Text>
      </View>
    </DrawerContentScrollView>
  );
}

// Use custom drawer
<Drawer.Navigator
  drawerContent={(props) => <CustomDrawerContent {...props} />}
>
  {/* screens */}
</Drawer.Navigator></code></pre>

            <h2>Advanced Drawer Configuration</h2>
            <pre><code class="language-javascript">// Animated drawer with custom styles
const AnimatedDrawer = () => {
  const progress = useDrawerProgress();
  
  const scale = Animated.interpolateNode(progress, {
    inputRange: [0, 1],
    outputRange: [1, 0.8],
  });
  
  const borderRadius = Animated.interpolateNode(progress, {
    inputRange: [0, 1],
    outputRange: [0, 20],
  });
  
  const animatedStyle = {
    transform: [{ scale }],
    borderRadius,
    overflow: 'hidden',
  };

  return (
    <Drawer.Navigator
      screenOptions={{
        drawerType: 'slide', // 'front', 'back', 'slide', 'permanent'
        drawerPosition: 'left', // 'left' or 'right'
        overlayColor: 'transparent',
        drawerStyle: {
          backgroundColor: '#1e1e1e',
          width: '80%',
        },
        sceneContainerStyle: {
          backgroundColor: '#1e1e1e',
        },
      }}
      drawerContent={(props) => {
        return (
          <Animated.View style={animatedStyle}>
            <CustomDrawerContent {...props} />
          </Animated.View>
        );
      }}
    >
      <Drawer.Screen
        name="Home"
        component={HomeScreen}
        options={{
          drawerLabel: 'Home',
          drawerIcon: ({ color }) => (
            <Icon name="home" size={24} color={color} />
          ),
        }}
      />
    </Drawer.Navigator>
  );
};</code></pre>

            <h2>Drawer with Sections</h2>
            <pre><code class="language-javascript">function SectionedDrawerContent(props) {
  return (
    <DrawerContentScrollView {...props}>
      <View style={styles.drawerContent}>
        {/* Main Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Main</Text>
          <DrawerItem
            label="Dashboard"
            icon={({ color, size }) => (
              <Icon name="dashboard" size={size} color={color} />
            )}
            onPress={() => props.navigation.navigate('Dashboard')}
          />
          <DrawerItem
            label="Analytics"
            icon={({ color, size }) => (
              <Icon name="analytics" size={size} color={color} />
            )}
            onPress={() => props.navigation.navigate('Analytics')}
          />
        </View>
        
        <Divider />
        
        {/* User Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Account</Text>
          <DrawerItem
            label="Profile"
            icon={({ color, size }) => (
              <Icon name="person" size={size} color={color} />
            )}
            onPress={() => props.navigation.navigate('Profile')}
          />
          <DrawerItem
            label="Settings"
            icon={({ color, size }) => (
              <Icon name="settings" size={size} color={color} />
            )}
            onPress={() => props.navigation.navigate('Settings')}
          />
          <DrawerItem
            label="Billing"
            icon={({ color, size }) => (
              <Icon name="credit-card" size={size} color={color} />
            )}
            onPress={() => props.navigation.navigate('Billing')}
          />
        </View>
        
        <Divider />
        
        {/* Support Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Support</Text>
          <DrawerItem
            label="Help Center"
            icon={({ color, size }) => (
              <Icon name="help" size={size} color={color} />
            )}
            onPress={() => props.navigation.navigate('Help')}
          />
          <DrawerItem
            label="Contact Us"
            icon={({ color, size }) => (
              <Icon name="email" size={size} color={color} />
            )}
            onPress={() => props.navigation.navigate('Contact')}
          />
        </View>
      </View>
    </DrawerContentScrollView>
  );
}</code></pre>

            <h2>Drawer with Nested Navigation</h2>
            <pre><code class="language-javascript">// Combining Drawer with Stack and Tab navigators
const HomeStack = createStackNavigator();
const ProfileStack = createStackNavigator();

function HomeStackScreen() {
  return (
    <HomeStack.Navigator>
      <HomeStack.Screen 
        name="HomeMain" 
        component={HomeScreen}
        options={{ headerShown: false }}
      />
      <HomeStack.Screen name="Details" component={DetailsScreen} />
      <HomeStack.Screen name="Edit" component={EditScreen} />
    </HomeStack.Navigator>
  );
}

function ProfileStackScreen() {
  return (
    <ProfileStack.Navigator>
      <ProfileStack.Screen 
        name="ProfileMain" 
        component={ProfileScreen}
        options={{ headerShown: false }}
      />
      <ProfileStack.Screen name="EditProfile" component={EditProfileScreen} />
      <ProfileStack.Screen name="ChangePassword" component={ChangePasswordScreen} />
    </ProfileStack.Navigator>
  );
}

// Tab navigator inside drawer
const Tab = createBottomTabNavigator();

function TabNavigator() {
  return (
    <Tab.Navigator>
      <Tab.Screen name="Feed" component={FeedScreen} />
      <Tab.Screen name="Search" component={SearchScreen} />
      <Tab.Screen name="Notifications" component={NotificationsScreen} />
    </Tab.Navigator>
  );
}

// Main drawer navigator
function MainDrawer() {
  return (
    <Drawer.Navigator>
      <Drawer.Screen 
        name="Home" 
        component={HomeStackScreen}
        options={{
          drawerLabel: 'Home',
          drawerIcon: ({ color }) => (
            <Icon name="home" size={24} color={color} />
          ),
        }}
      />
      <Drawer.Screen 
        name="Main" 
        component={TabNavigator}
        options={{
          drawerLabel: 'Main App',
          drawerIcon: ({ color }) => (
            <Icon name="apps" size={24} color={color} />
          ),
        }}
      />
      <Drawer.Screen 
        name="Profile" 
        component={ProfileStackScreen}
        options={{
          drawerLabel: 'Profile',
          drawerIcon: ({ color }) => (
            <Icon name="person" size={24} color={color} />
          ),
        }}
      />
    </Drawer.Navigator>
  );
}</code></pre>

            <h2>Conditional Drawer Items</h2>
            <pre><code class="language-javascript">function ConditionalDrawerContent(props) {
  const { user, subscription } = useAuth();
  const { state } = props;

  return (
    <DrawerContentScrollView {...props}>
      <DrawerItemList {...props} />
      
      {/* Admin only items */}
      {user?.role === 'admin' && (
        <>
          <DrawerItem
            label="Admin Panel"
            icon={({ color, size }) => (
              <Icon name="admin-panel-settings" size={size} color={color} />
            )}
            onPress={() => props.navigation.navigate('AdminPanel')}
            style={styles.adminItem}
          />
          <DrawerItem
            label="User Management"
            icon={({ color, size }) => (
              <Icon name="group" size={size} color={color} />
            )}
            onPress={() => props.navigation.navigate('UserManagement')}
          />
        </>
      )}
      
      {/* Premium features */}
      {subscription?.isPremium ? (
        <DrawerItem
          label="Premium Features"
          icon={({ color, size }) => (
            <Icon name="star" size={size} color={color} />
          )}
          onPress={() => props.navigation.navigate('Premium')}
          labelStyle={{ color: '#ffd700' }}
        />
      ) : (
        <DrawerItem
          label="Upgrade to Premium"
          icon={({ color, size }) => (
            <Icon name="upgrade" size={size} color={color} />
          )}
          onPress={() => props.navigation.navigate('Subscription')}
          labelStyle={{ color: '#0066ff' }}
        />
      )}
      
      {/* Dynamic notification badge */}
      <DrawerItem
        label={({ focused, color }) => (
          <View style={styles.labelWithBadge}>
            <Text style={{ color }}>Notifications</Text>
            {unreadCount > 0 && (
              <View style={styles.badge}>
                <Text style={styles.badgeText}>{unreadCount}</Text>
              </View>
            )}
          </View>
        )}
        icon={({ color, size }) => (
          <Icon name="notifications" size={size} color={color} />
        )}
        onPress={() => props.navigation.navigate('Notifications')}
      />
    </DrawerContentScrollView>
  );
}</code></pre>

            <h2>Drawer Gestures and Controls</h2>
            <pre><code class="language-javascript">// Control drawer programmatically
import { useDrawerStatus } from '@react-navigation/drawer';

function ScreenWithDrawerControl({ navigation }) {
  const isDrawerOpen = useDrawerStatus() === 'open';

  return (
    <View style={styles.container}>
      <Button
        title="Toggle Drawer"
        onPress={() => navigation.toggleDrawer()}
      />
      
      <Button
        title="Open Drawer"
        onPress={() => navigation.openDrawer()}
      />
      
      <Button
        title="Close Drawer"
        onPress={() => navigation.closeDrawer()}
      />
      
      <Text>Drawer is {isDrawerOpen ? 'open' : 'closed'}</Text>
    </View>
  );
}

// Disable drawer gestures on specific screens
<Drawer.Screen
  name="Form"
  component={FormScreen}
  options={{
    swipeEnabled: false, // Disable swipe to open
    gestureEnabled: false, // Disable all gestures
  }}
/>

// Custom gesture configuration
<Drawer.Navigator
  screenOptions={{
    swipeEdgeWidth: 100, // Width of swipeable area from edge
    swipeMinDistance: 50, // Minimum swipe distance
    keyboardDismissMode: 'on-drag', // Dismiss keyboard when dragging
    unmountOnBlur: false, // Keep screens mounted
  }}
>
  {/* screens */}
</Drawer.Navigator></code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Always import 'react-native-gesture-handler' at the top</li>
                    <li>Use custom drawer content for complex layouts</li>
                    <li>Implement proper authentication checks in drawer</li>
                    <li>Consider right-to-left (RTL) language support</li>
                    <li>Test drawer performance with many items</li>
                    <li>Provide visual feedback for active items</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What are the different drawerType options?",
            options: [
                "slide, front, back",
                "slide, front, back, permanent",
                "left, right, center",
                "push, overlay, slide"
            ],
            correct: 1
        },
        {
            question: "How do you programmatically open the drawer?",
            options: [
                "navigation.openDrawer()",
                "navigation.showDrawer()",
                "navigation.drawer.open()",
                "navigation.toggleDrawer(true)"
            ],
            correct: 0
        },
        {
            question: "What does swipeEdgeWidth control?",
            options: [
                "Drawer width",
                "Swipe gesture speed",
                "Width of swipeable area from screen edge",
                "Animation duration"
            ],
            correct: 2
        }
    ],
    project: {
        title: "Dashboard App with Drawer",
        description: "Build a dashboard app with complex drawer navigation",
        requirements: [
            "Custom drawer header with user info",
            "Sectioned drawer items",
            "Nested navigation (drawer + tabs + stack)",
            "Conditional drawer items based on user role",
            "Animated drawer with custom transitions",
            "Badge notifications in drawer",
            "Settings panel accessible from drawer"
        ],
        hints: [
            "Use DrawerContentScrollView for custom content",
            "Implement proper authentication flow",
            "Add animations using useDrawerProgress",
            "Consider using drawer for app-wide settings"
        ]
    }
},

'nested-navigation': {
    content: `
        <div class="content-section">
            <h1>Navigation Patterns</h1>
            
            <div class="info-box">
                <p>Learn common navigation patterns and best practices for building intuitive navigation flows in React Native apps. These patterns help create consistent and user-friendly navigation experiences.</p>
            </div>

            <h2>Authentication Flow</h2>
            <pre><code class="language-javascript">// AuthNavigator.js
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { useAuth } from './hooks/useAuth';

const Stack = createStackNavigator();

// Auth screens
import SplashScreen from './screens/SplashScreen';
import SignInScreen from './screens/SignInScreen';
import SignUpScreen from './screens/SignUpScreen';
import ForgotPasswordScreen from './screens/ForgotPasswordScreen';
import VerifyEmailScreen from './screens/VerifyEmailScreen';

// App screens
import MainNavigator from './MainNavigator';

function AuthNavigator() {
  const { user, isLoading, isFirstLaunch } = useAuth();

  if (isLoading) {
    return <SplashScreen />;
  }

  return (
    <NavigationContainer>
      <Stack.Navigator screenOptions={{ headerShown: false }}>
        {user ? (
          // User is signed in
          <Stack.Screen name="Main" component={MainNavigator} />
        ) : (
          // No user, show auth screens
          <>
            {isFirstLaunch && (
              <Stack.Screen name="Onboarding" component={OnboardingScreen} />
            )}
            <Stack.Screen 
              name="SignIn" 
              component={SignInScreen}
              options={{
                animationTypeForReplace: !user ? 'pop' : 'push',
              }}
            />
            <Stack.Screen name="SignUp" component={SignUpScreen} />
            <Stack.Screen name="ForgotPassword" component={ForgotPasswordScreen} />
            <Stack.Screen name="VerifyEmail" component={VerifyEmailScreen} />
          </>
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
}

// Onboarding flow
const OnboardingStack = createStackNavigator();

function OnboardingNavigator() {
  return (
    <OnboardingStack.Navigator
      screenOptions={{
        headerShown: false,
        cardStyleInterpolator: CardStyleInterpolators.forHorizontalIOS,
      }}
    >
      <OnboardingStack.Screen name="Welcome" component={WelcomeScreen} />
      <OnboardingStack.Screen name="Features" component={FeaturesScreen} />
      <OnboardingStack.Screen name="Permissions" component={PermissionsScreen} />
      <OnboardingStack.Screen name="GetStarted" component={GetStartedScreen} />
    </OnboardingStack.Navigator>
  );
}</code></pre>

            <h2>Tab + Stack Pattern</h2>
            <pre><code class="language-javascript">// Common pattern: Tabs with nested stacks
const Tab = createBottomTabNavigator();
const HomeStack = createStackNavigator();
const SearchStack = createStackNavigator();
const ProfileStack = createStackNavigator();

// Home stack with details
function HomeStackNavigator() {
  return (
    <HomeStack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <HomeStack.Screen name="HomeScreen" component={HomeScreen} />
      <HomeStack.Screen name="PostDetails" component={PostDetailsScreen} />
      <HomeStack.Screen name="UserProfile" component={UserProfileScreen} />
      <HomeStack.Screen name="Comments" component={CommentsScreen} />
      <HomeStack.Screen 
        name="CreatePost" 
        component={CreatePostScreen}
        options={{
          presentation: 'modal',
        }}
      />
    </HomeStack.Navigator>
  );
}

// Search stack with results
function SearchStackNavigator() {
  return (
    <SearchStack.Navigator>
      <SearchStack.Screen 
        name="SearchScreen" 
        component={SearchScreen}
        options={{ headerShown: false }}
      />
      <SearchStack.Screen 
        name="SearchResults" 
        component={SearchResultsScreen}
        options={({ route }) => ({
          title: \`Results for "\${route.params.query}"\`,
        })}
      />
      <SearchStack.Screen 
        name="Filter" 
        component={FilterScreen}
        options={{
          presentation: 'modal',
          headerTitle: 'Filter Results',
        }}
      />
    </SearchStack.Navigator>
  );
}

// Main tab navigator
function MainTabs() {
  return (
    <Tab.Navigator
      screenOptions={{
        tabBarShowLabel: false,
        headerShown: true,
      }}
    >
      <Tab.Screen 
        name="HomeTab" 
        component={HomeStackNavigator}
        options={{
          tabBarIcon: ({ focused }) => (
            <Icon name="home" size={24} color={focused ? '#0066ff' : '#666'} />
          ),
          headerShown: false,
        }}
      />
      <Tab.Screen 
        name="SearchTab" 
        component={SearchStackNavigator}
        options={{
          tabBarIcon: ({ focused }) => (
            <Icon name="search" size={24} color={focused ? '#0066ff' : '#666'} />
          ),
          headerShown: false,
        }}
      />
      <Tab.Screen 
        name="ProfileTab" 
        component={ProfileStackNavigator}
        options={{
          tabBarIcon: ({ focused }) => (
            <Icon name="person" size={24} color={focused ? '#0066ff' : '#666'} />
          ),
          headerShown: false,
        }}
      />
    </Tab.Navigator>
  );
}</code></pre>

            <h2>Modal Patterns</h2>
            <pre><code class="language-javascript">// Root navigator with modals
const RootStack = createStackNavigator();

function RootNavigator() {
  return (
    <RootStack.Navigator
      screenOptions={{
        headerShown: false,
        presentation: 'modal',
      }}
    >
      <RootStack.Group>
        <RootStack.Screen 
          name="Main" 
          component={MainTabs}
          options={{ presentation: 'card' }}
        />
      </RootStack.Group>
      
      {/* Global Modals */}
      <RootStack.Group screenOptions={{ presentation: 'modal' }}>
        <RootStack.Screen name="CreatePost" component={CreatePostScreen} />
        <RootStack.Screen name="EditProfile" component={EditProfileScreen} />
        <RootStack.Screen name="Settings" component={SettingsScreen} />
        <RootStack.Screen name="QRScanner" component={QRScannerScreen} />
      </RootStack.Group>
      
      {/* Full Screen Modals */}
      <RootStack.Group screenOptions={{ presentation: 'fullScreenModal' }}>
        <RootStack.Screen name="Camera" component={CameraScreen} />
        <RootStack.Screen name="VideoPlayer" component={VideoPlayerScreen} />
        <RootStack.Screen name="ImageViewer" component={ImageViewerScreen} />
      </RootStack.Group>
      
      {/* Transparent Modals */}
      <RootStack.Group 
        screenOptions={{ 
          presentation: 'transparentModal',
          cardStyle: { backgroundColor: 'transparent' },
          cardOverlayEnabled: true,
        }}
      >
        <RootStack.Screen name="Alert" component={AlertModal} />
        <RootStack.Screen name="ActionSheet" component={ActionSheetModal} />
        <RootStack.Screen name="Tooltip" component={TooltipModal} />
      </RootStack.Group>
    </RootStack.Navigator>
  );
}

// Custom modal with gesture handling
function DraggableModal({ navigation }) {
  const translateY = useSharedValue(0);
  const gestureHandler = useAnimatedGestureHandler({
    onStart: (_, ctx) => {
      ctx.startY = translateY.value;
    },
    onActive: (event, ctx) => {
      translateY.value = ctx.startY + event.translationY;
    },
    onEnd: () => {
      if (translateY.value > 100) {
        runOnJS(navigation.goBack)();
      } else {
        translateY.value = withSpring(0);
      }
    },
  });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateY: translateY.value }],
  }));

  return (
    <View style={styles.modalContainer}>
      <PanGestureHandler onGestureEvent={gestureHandler}>
        <Animated.View style={[styles.modalContent, animatedStyle]}>
          <View style={styles.dragIndicator} />
          {/* Modal content */}
        </Animated.View>
      </PanGestureHandler>
    </View>
  );
}</code></pre>

            <h2>Deep Navigation Patterns</h2>
            <pre><code class="language-javascript">// Navigate to deeply nested screens
function navigateToNestedScreen(navigation) {
  // Navigate to specific tab and then to nested screen
  navigation.navigate('ProfileTab', {
    screen: 'ProfileStack',
    params: {
      screen: 'Settings',
      params: {
        screen: 'AccountSettings',
        params: {
          userId: '123',
        },
      },
    },
  });
}

// Navigate with reset
function navigateWithReset(navigation) {
  navigation.reset({
    index: 0,
    routes: [
      {
        name: 'Main',
        state: {
          routes: [
            {
              name: 'HomeTab',
              state: {
                routes: [
                  { name: 'HomeScreen' },
                  { 
                    name: 'PostDetails',
                    params: { postId: '123' },
                  },
                ],
              },
            },
          ],
        },
      },
    ],
  });
}

// Common actions service
class NavigationService {
  static navigationRef = createNavigationContainerRef();

  static navigate(name, params) {
    if (this.navigationRef.isReady()) {
      this.navigationRef.navigate(name, params);
    }
  }

  static goBack() {
    if (this.navigationRef.isReady() && this.navigationRef.canGoBack()) {
      this.navigationRef.goBack();
    }
  }

  static reset(routes) {
    if (this.navigationRef.isReady()) {
      this.navigationRef.reset({
        index: 0,
        routes,
      });
    }
  }

  static navigateToChat(userId) {
    this.navigate('Main', {
      screen: 'ChatTab',
      params: {
        screen: 'ChatDetail',
        params: { userId },
      },
    });
  }
}

// Usage in App
<NavigationContainer ref={NavigationService.navigationRef}>
  {/* navigators */}
</NavigationContainer></code></pre>

            <h2>Wizard/Step Navigation</h2>
            <pre><code class="language-javascript">// Multi-step form navigation
const StepStack = createStackNavigator();

function WizardNavigator() {
  const [currentStep, setCurrentStep] = useState(0);
  const [formData, setFormData] = useState({});

  const steps = [
    { name: 'PersonalInfo', component: PersonalInfoStep },
    { name: 'ContactInfo', component: ContactInfoStep },
    { name: 'Preferences', component: PreferencesStep },
    { name: 'Review', component: ReviewStep },
  ];

  return (
    <FormContext.Provider value={{ formData, setFormData }}>
      <StepStack.Navigator
        screenOptions={{
          headerShown: true,
          headerLeft: ({ canGoBack }) =>
            canGoBack ? (
              <TouchableOpacity onPress={() => navigation.goBack()}>
                <Icon name="arrow-back" size={24} />
              </TouchableOpacity>
            ) : null,
          cardStyleInterpolator: CardStyleInterpolators.forHorizontalIOS,
        }}
      >
        {steps.map((step, index) => (
          <StepStack.Screen
            key={step.name}
            name={step.name}
            component={step.component}
            options={{
              title: \`Step \${index + 1} of \${steps.length}\`,
              headerRight: () => (
                <View style={styles.progressBar}>
                  <View 
                    style={[
                      styles.progress,
                      { width: \`\${((index + 1) / steps.length) * 100}%\` }
                    ]}
                  />
                </View>
              ),
            }}
            listeners={{
              beforeRemove: (e) => {
                if (index === 0) return; // Allow going back on first step
                
                // Prevent going back without confirmation
                e.preventDefault();
                
                Alert.alert(
                  'Discard progress?',
                  'Are you sure you want to go back? Your progress will be lost.',
                  [
                    { text: 'Stay', style: 'cancel' },
                    { 
                      text: 'Go Back', 
                      style: 'destructive',
                      onPress: () => navigation.dispatch(e.data.action),
                    },
                  ]
                );
              },
            }}
          />
        ))}
      </StepStack.Navigator>
    </FormContext.Provider>
  );
}</code></pre>

            <h2>Search Pattern</h2>
            <pre><code class="language-javascript">// Search flow with suggestions and history
function SearchNavigator() {
  const [searchHistory, setSearchHistory] = useState([]);
  const [recentSearches, setRecentSearches] = useState([]);

  return (
    <SearchStack.Navigator>
      <SearchStack.Screen 
        name="SearchHome"
        options={{
          header: ({ navigation }) => (
            <SearchHeader
              onSearch={(query) => {
                addToHistory(query);
                navigation.navigate('SearchResults', { query });
              }}
              suggestions={recentSearches}
            />
          ),
        }}
      >
        {(props) => (
          <SearchHomeScreen
            {...props}
            recentSearches={recentSearches}
            onSelectRecent={(query) => {
              props.navigation.navigate('SearchResults', { query });
            }}
          />
        )}
      </SearchStack.Screen>
      
      <SearchStack.Screen 
        name="SearchResults"
        component={SearchResultsScreen}
        options={({ route, navigation }) => ({
          headerTitle: () => (
            <SearchBar
              defaultValue={route.params.query}
              onSubmit={(newQuery) => {
                navigation.setParams({ query: newQuery });
              }}
            />
          ),
          headerRight: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('SearchFilter')}
            >
              <Icon name="filter-list" size={24} />
            </TouchableOpacity>
          ),
        })}
      />
      
      <SearchStack.Screen 
        name="SearchFilter"
        component={SearchFilterScreen}
        options={{
          presentation: 'modal',
          headerTitle: 'Filter Results',
          headerRight: () => (
            <TouchableOpacity onPress={() => navigation.goBack()}>
              <Text>Apply</Text>
            </TouchableOpacity>
          ),
        }}
      />
    </SearchStack.Navigator>
  );
}</code></pre>

            <h2>Error Boundary Navigation</h2>
            <pre><code class="language-javascript">// Error boundary for navigation
class NavigationErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Log error to crash reporting service
    crashlytics().recordError(error);
  }

  render() {
    if (this.state.hasError) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorTitle}>Oops! Something went wrong</Text>
          <Text style={styles.errorMessage}>
            We're having trouble loading this screen
          </Text>
          <Button
            title="Go to Home"
            onPress={() => {
              this.setState({ hasError: false });
              NavigationService.reset([{ name: 'Home' }]);
            }}
          />
        </View>
      );
    }

    return this.props.children;
  }
}

// Wrap navigation with error boundary
function App() {
  return (
    <NavigationErrorBoundary>
      <NavigationContainer>
        <RootNavigator />
      </NavigationContainer>
    </NavigationErrorBoundary>
  );
}</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Keep authentication flow separate from main app flow</li>
                    <li>Use proper modal presentations for overlays</li>
                    <li>Implement navigation service for navigation outside components</li>
                    <li>Handle deep linking properly with nested navigators</li>
                    <li>Test navigation flows on both platforms</li>
                    <li>Implement proper error boundaries</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the best way to handle authentication navigation?",
            options: [
                "Use conditional rendering in NavigationContainer",
                "Navigate between auth and app screens",
                "Always show login screen first",
                "Use separate apps"
            ],
            correct: 0
        },
        {
            question: "How do you navigate to deeply nested screens?",
            options: [
                "Navigate multiple times",
                "Use nested params with screen names",
                "Can't navigate to nested screens",
                "Use global variables"
            ],
            correct: 1
        },
        {
            question: "What's the purpose of NavigationService?",
            options: [
                "To style navigation",
                "To navigate from outside React components",
                "To handle errors",
                "To create navigators"
            ],
            correct: 1
        }
    ],
    project: {
        title: "E-commerce App Navigation",
        description: "Build a complete e-commerce app with complex navigation patterns",
        requirements: [
            "Authentication flow with onboarding",
            "Tab navigation with nested stacks",
            "Product search with filters",
            "Multi-step checkout process",
            "Order tracking with deep linking",
            "User profile with settings",
            "Modal patterns for quick actions",
            "Error handling and recovery"
        ],
        hints: [
            "Use conditional navigation for auth",
            "Implement wizard pattern for checkout",
            "Create reusable navigation components",
            "Handle all edge cases properly"
        ]
    }
},
'deep-linking': {
    content: `
        <div class="content-section">
            <h1>Deep Linking</h1>
            
            <div class="info-box">
                <p>Deep linking allows users to navigate directly to specific content within your app using URLs. This is essential for features like push notifications, email links, and sharing content between apps.</p>
            </div>

            <h2>Basic Deep Linking Setup</h2>
            <pre><code class="language-javascript">// App.js
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { Linking } from 'react-native';

const Stack = createStackNavigator();

const linking = {
  prefixes: ['myapp://', 'https://myapp.com', 'https://www.myapp.com'],
  
  // Configure deep link structure
  config: {
    screens: {
      Home: {
        path: 'home',
      },
      Profile: {
        path: 'user/:userId',
        parse: {
          userId: (userId) => userId,
        },
      },
      Post: {
        path: 'post/:postId',
        parse: {
          postId: (postId) => parseInt(postId, 10),
        },
      },
      Settings: {
        path: 'settings',
        screens: {
          Account: 'account',
          Privacy: 'privacy',
          Notifications: 'notifications/:section?',
        },
      },
      NotFound: '*', // Fallback screen
    },
  },
  
  // Custom function to get the initial URL
  async getInitialURL() {
    // Check if app was opened from a deep link
    const url = await Linking.getInitialURL();
    
    if (url != null) {
      return url;
    }
    
    // Check if there is an initial notification
    const message = await messaging().getInitialNotification();
    
    return message?.data?.link;
  },
  
  // Custom function to subscribe to incoming links
  subscribe(listener) {
    // Listen to incoming deep links
    const linkingSubscription = Linking.addEventListener('url', ({ url }) => {
      listener(url);
    });
    
    // Listen to push notifications
    const unsubscribe = messaging().onNotificationOpenedApp((message) => {
      const url = message?.data?.link;
      
      if (url) {
        listener(url);
      }
    });
    
    return () => {
      linkingSubscription.remove();
      unsubscribe();
    };
  },
};

function App() {
  return (
    <NavigationContainer linking={linking}>
      <Stack.Navigator>
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="Profile" component={ProfileScreen} />
        <Stack.Screen name="Post" component={PostScreen} />
        <Stack.Screen name="Settings" component={SettingsNavigator} />
        <Stack.Screen name="NotFound" component={NotFoundScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}</code></pre>

            <h2>iOS Configuration</h2>
            <pre><code class="language-xml"><!-- Info.plist -->
<key>CFBundleURLTypes</key>
<array>
  <dict>
    <key>CFBundleURLSchemes</key>
    <array>
      <string>myapp</string>
    </array>
    <key>CFBundleURLName</key>
    <string>com.mycompany.myapp</string>
  </dict>
</array>

<!-- For Universal Links (HTTPS) -->
<key>com.apple.developer.associated-domains</key>
<array>
  <string>applinks:myapp.com</string>
  <string>applinks:www.myapp.com</string>
</array></code></pre>

            <pre><code class="language-objectivec">// AppDelegate.m
#import <React/RCTLinkingManager.h>

// Add this to handle deep links
- (BOOL)application:(UIApplication *)application
   openURL:(NSURL *)url
   options:(NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options
{
  return [RCTLinkingManager application:application openURL:url options:options];
}

// For Universal Links
- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity
 restorationHandler:(nonnull void (^)(NSArray<id<UIUserActivityRestoring>> * _Nullable))restorationHandler
{
  return [RCTLinkingManager application:application
                   continueUserActivity:userActivity
                     restorationHandler:restorationHandler];
}</code></pre>

            <h2>Android Configuration</h2>
            <pre><code class="language-xml"><!-- AndroidManifest.xml -->
<activity
  android:name=".MainActivity"
  android:launchMode="singleTask">
  
  <!-- Deep linking -->
  <intent-filter>
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />
    <!-- Custom scheme -->
    <data android:scheme="myapp" />
  </intent-filter>
  
  <!-- App Links (HTTPS) -->
  <intent-filter android:autoVerify="true">
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />
    <data android:scheme="https" 
          android:host="myapp.com" />
    <data android:scheme="https" 
          android:host="www.myapp.com" />
  </intent-filter>
</activity></code></pre>

            <h2>Advanced Deep Linking</h2>
            <pre><code class="language-javascript">// Complex deep linking configuration
const linking = {
  prefixes: ['myapp://', 'https://myapp.com'],
  
  config: {
    initialRouteName: 'Home',
    screens: {
      // Simple screen
      Home: 'home',
      
      // With required parameter
      Profile: {
        path: 'user/:userId',
        parse: {
          userId: String,
        },
        stringify: {
          userId: (userId) => userId,
        },
      },
      
      // With optional parameters
      Product: {
        path: 'product/:productId/:section?',
        parse: {
          productId: Number,
          section: String,
        },
      },
      
      // With query parameters
      Search: {
        path: 'search',
        parse: {
          query: String,
          category: String,
          sort: (sort) => sort || 'relevance',
        },
      },
      
      // Nested navigators
      Main: {
        screens: {
          Feed: {
            screens: {
              Popular: 'feed/popular',
              Recent: 'feed/recent',
              Following: 'feed/following',
            },
          },
          Messages: {
            screens: {
              ChatList: 'messages',
              ChatDetail: {
                path: 'messages/:chatId',
                parse: {
                  chatId: String,
                },
              },
            },
          },
        },
      },
      
      // Auth flow
      Auth: {
        screens: {
          SignIn: 'signin',
          SignUp: 'signup',
          ResetPassword: {
            path: 'reset-password/:token',
            parse: {
              token: String,
            },
          },
          VerifyEmail: {
            path: 'verify-email/:code',
            parse: {
              code: String,
            },
          },
        },
      },
    },
  },
  
  // Custom state parsing
  getStateFromPath: (path, options) => {
    // Custom logic for complex paths
    if (path.includes('special-promo')) {
      return {
        routes: [
          {
            name: 'Home',
            state: {
              routes: [
                { name: 'Promo' },
              ],
            },
          },
        ],
      };
    }
    
    // Use default for other paths
    return getStateFromPath(path, options);
  },
  
  // Custom path generation
  getPathFromState: (state, options) => {
    // Custom logic for generating paths
    return getPathFromState(state, options);
  },
};</code></pre>

            <h2>Handling Deep Links in Components</h2>
            <pre><code class="language-javascript">// Hook to handle deep links
import { useLinking } from '@react-navigation/native';

function useDeepLinkHandler() {
  const navigation = useNavigation();
  const [isReady, setIsReady] = useState(false);
  
  useEffect(() => {
    const handleDeepLink = (url) => {
      if (!url) return;
      
      // Parse the URL
      const route = url.replace(/.*?:\/\//g, '');
      const [path, queryString] = route.split('?');
      const params = queryString
        ? Object.fromEntries(new URLSearchParams(queryString))
        : {};
      
      // Handle specific deep links
      if (path.startsWith('invite/')) {
        const inviteCode = path.replace('invite/', '');
        handleInviteLink(inviteCode);
      } else if (path.startsWith('promo/')) {
        const promoCode = path.replace('promo/', '');
        handlePromoLink(promoCode);
      }
      
      // Log analytics
      analytics().logEvent('deep_link_opened', {
        url,
        path,
        params,
      });
    };
    
    // Get initial URL
    Linking.getInitialURL().then((url) => {
      if (url) {
        handleDeepLink(url);
      }
      setIsReady(true);
    });
    
    // Listen for new URLs
    const subscription = Linking.addEventListener('url', ({ url }) => {
      handleDeepLink(url);
    });
    
    return () => subscription.remove();
  }, []);
  
  return isReady;
}

// Component handling deep link params
function ProductScreen({ route, navigation }) {
  const { productId, section } = route.params || {};
  const [product, setProduct] = useState(null);
  
  useEffect(() => {
    if (productId) {
      loadProduct(productId);
    }
  }, [productId]);
  
  useEffect(() => {
    if (section) {
      // Navigate to specific section
      scrollToSection(section);
    }
  }, [section]);
  
  const handleShare = () => {
    const url = \`https://myapp.com/product/\${productId}\`;
    
    Share.share({
      title: product.name,
      message: \`Check out this product: \${product.name}\`,
      url,
    });
  };
  
  return (
    <ScrollView>
      {/* Product content */}
      <Button title="Share" onPress={handleShare} />
    </ScrollView>
  );
}</code></pre>

            <h2>Universal Links / App Links</h2>
            <pre><code class="language-javascript">// Server configuration for Universal Links (iOS)
// apple-app-site-association file (serve at https://myapp.com/.well-known/apple-app-site-association)
{
  "applinks": {
    "apps": [],
    "details": [
      {
        "appID": "TEAMID.com.mycompany.myapp",
        "paths": [
          "/product/*",
          "/user/*",
          "/post/*",
          "NOT /api/*",
          "NOT /admin/*"
        ]
      }
    ]
  }
}

// Server configuration for App Links (Android)
// assetlinks.json file (serve at https://myapp.com/.well-known/assetlinks.json)
[
  {
    "relation": ["delegate_permission/common.handle_all_urls"],
    "target": {
      "namespace": "android_app",
      "package_name": "com.mycompany.myapp",
      "sha256_cert_fingerprints": [
        "FA:C6:17:45:DC:09:03:78:6F:B9:ED:E6:2A:96:2B:39:9F:73:48:F0:BB:6F:89:9B:83:32:66:75:91:03:3B:9C"
      ]
    }
  }
]</code></pre>

            <h2>Testing Deep Links</h2>
            <pre><code class="language-bash"># iOS Simulator
xcrun simctl openurl booted myapp://product/123

# Android Emulator
adb shell am start -W -a android.intent.action.VIEW -d "myapp://product/123" com.mycompany.myapp

# Test Universal Links (iOS)
xcrun simctl openurl booted https://myapp.com/product/123

# Test App Links (Android)
adb shell am start -W -a android.intent.action.VIEW -d "https://myapp.com/product/123" com.mycompany.myapp

# React Native CLI
npx uri-scheme open myapp://product/123 --ios
npx uri-scheme open myapp://product/123 --android</code></pre>

            <h2>Dynamic Links with Firebase</h2>
            <pre><code class="language-javascript">// Using Firebase Dynamic Links
import dynamicLinks from '@react-native-firebase/dynamic-links';

// Create a dynamic link
async function createDynamicLink(productId) {
  const link = await dynamicLinks().buildShortLink({
    link: \`https://myapp.com/product/\${productId}\`,
    domainUriPrefix: 'https://myapp.page.link',
    ios: {
      bundleId: 'com.mycompany.myapp',
      appStoreId: '123456789',
      fallbackUrl: 'https://myapp.com',
    },
    android: {
      packageName: 'com.mycompany.myapp',
      fallbackUrl: 'https://myapp.com',
    },
    social: {
      title: 'Check out this product!',
      descriptionText: 'Amazing product on MyApp',
      imageUrl: \`https://myapp.com/images/product/\${productId}.jpg\`,
    },
    analytics: {
      campaign: 'product-share',
      medium: 'social',
      source: 'in-app',
    },
  });
  
  return link;
}

// Handle incoming dynamic links
function useDynamicLinks() {
  useEffect(() => {
    // Handle link when app is in background
    const unsubscribe = dynamicLinks().onLink(handleDynamicLink);
    
    // Handle link when app is closed
    dynamicLinks()
      .getInitialLink()
      .then(handleDynamicLink);
    
    return unsubscribe;
  }, []);
  
  const handleDynamicLink = (link) => {
    if (!link) return;
    
    // Parse and navigate
    const url = link.url;
    // Handle navigation based on URL
  };
}</code></pre>

            <h2>Branch.io Integration</h2>
            <pre><code class="language-javascript">// Using Branch for deep linking
import branch from 'react-native-branch';

// Subscribe to deep links
branch.subscribe(({ error, params, uri }) => {
  if (error) {
    console.error('Branch error:', error);
    return;
  }
  
  if (params['+clicked_branch_link']) {
    // Handle Branch link data
    const { productId, campaignId, referrer } = params;
    
    // Navigate to appropriate screen
    NavigationService.navigate('Product', { productId });
    
    // Track analytics
    analytics().logEvent('branch_link_opened', {
      productId,
      campaignId,
      referrer,
    });
  }
});

// Create Branch deep link
async function createBranchLink(product) {
  const branchUniversalObject = await branch.createBranchUniversalObject(
    \`product/\${product.id}\`,
    {
      title: product.name,
      contentDescription: product.description,
      contentImageUrl: product.image,
      contentMetadata: {
        customMetadata: {
          productId: product.id,
          price: product.price,
        },
      },
    }
  );
  
  const linkProperties = {
    feature: 'share',
    channel: 'facebook',
    campaign: 'product-sharing',
  };
  
  const controlParams = {
    $desktop_url: \`https://myapp.com/product/\${product.id}\`,
    $ios_url: \`https://apps.apple.com/app/id123456789\`,
    $android_url: \`https://play.google.com/store/apps/details?id=com.mycompany.myapp\`,
  };
  
  const { url } = await branchUniversalObject.generateShortUrl(
    linkProperties,
    controlParams
  );
  
  return url;
}</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Always validate deep link parameters</li>
                    <li>Handle authentication state before navigation</li>
                    <li>Implement fallback screens for invalid links</li>
                    <li>Test deep links on both platforms thoroughly</li>
                    <li>Use analytics to track deep link performance</li>
                    <li>Implement proper error handling for malformed URLs</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's required for Universal Links on iOS?",
            options: [
                "Only URL scheme configuration",
                "Apple App Site Association file on server",
                "Just Info.plist configuration",
                "Nothing special"
            ],
            correct: 1
        },
        {
            question: "How do you test deep links in development?",
            options: [
                "Only on real devices",
                "Using uri-scheme CLI or platform commands",
                "Can't test in development",
                "Only through push notifications"
            ],
            correct: 1
        },
        {
            question: "What's the benefit of using Firebase Dynamic Links?",
            options: [
                "They're faster",
                "They work across app installs and provide analytics",
                "They're required for deep linking",
                "They only work on Android"
            ],
            correct: 1
        }
    ],
    project: {
        title: "Content Sharing App",
        description: "Build an app with comprehensive deep linking for content sharing",
        requirements: [
            "Configure deep linking for both platforms",
            "Implement Universal/App Links",
            "Handle authentication in deep links",
            "Create shareable links for content",
            "Track deep link analytics",
            "Handle app install attribution",
            "Implement referral system with deep links",
            "Test all deep link scenarios"
        ],
        hints: [
            "Use Firebase Dynamic Links for better analytics",
            "Implement proper URL validation",
            "Handle edge cases like expired content",
            "Test with app in different states"
        ]
    }
},
'navigation-params': {
    content: `
        <div class="content-section">
            <h1>Navigation Performance</h1>
            
            <div class="info-box">
                <p>Optimizing navigation performance is crucial for creating smooth, responsive apps. Learn techniques to improve navigation speed, reduce memory usage, and enhance the overall user experience.</p>
            </div>

            <h2>Screen Optimization</h2>
            <pre><code class="language-javascript">// Lazy loading screens
import React, { lazy, Suspense } from 'react';
import { ActivityIndicator, View } from 'react-native';

// Instead of direct imports
// import ProfileScreen from './screens/ProfileScreen';

// Use lazy loading
const ProfileScreen = lazy(() => import('./screens/ProfileScreen'));
const SettingsScreen = lazy(() => import('./screens/SettingsScreen'));
const HeavyScreen = lazy(() => 
  import(/* webpackChunkName: "heavy" */ './screens/HeavyScreen')
);

// Loading component
const ScreenLoader = () => (
  <View style={styles.loaderContainer}>
    <ActivityIndicator size="large" color="#0066ff" />
  </View>
);

// In navigator
<Stack.Screen 
  name="Profile" 
  component={ProfileScreen}
  options={{
    lazy: true,
    // Custom loading component
    loadingComponent: ScreenLoader,
  }}
/>

// Or wrap with Suspense
function ProfileScreenWrapper(props) {
  return (
    <Suspense fallback={<ScreenLoader />}>
      <ProfileScreen {...props} />
    </Suspense>
  );
}</code></pre>

            <h2>Memory Management</h2>
            <pre><code class="language-javascript">// Unmount screens when not focused
<Stack.Navigator
  screenOptions={{
    unmountOnBlur: true, // Unmount screen when it loses focus
    detachInactiveScreens: true, // Detach inactive screens
  }}
>
  <Stack.Screen name="Home" component={HomeScreen} />
  <Stack.Screen 
    name="HeavyList" 
    component={HeavyListScreen}
    options={{
      // Keep mounted for specific screens if needed
      unmountOnBlur: false,
    }}
  />
</Stack.Navigator>

// Clean up resources on blur
function HeavyScreen() {
  const [data, setData] = useState([]);
  const [images, setImages] = useState([]);
  
  useFocusEffect(
    useCallback(() => {
      // Load data when screen focuses
      loadHeavyData().then(setData);
      loadImages().then(setImages);
      
      return () => {
        // Clean up when screen loses focus
        setData([]);
        setImages([]);
        // Cancel any ongoing requests
        cancelRequests();
        // Clear caches if needed
        ImageCache.clear();
      };
    }, [])
  );
  
  return <View>{/* Screen content */}</View>;
}

// Memory-efficient list screen
function OptimizedListScreen() {
  const [data, setData] = useState([]);
  
  return (
    <FlatList
      data={data}
      renderItem={({ item }) => <ListItem item={item} />}
      keyExtractor={(item) => item.id}
      
      // Performance optimizations
      removeClippedSubviews={true} // Unmount items outside viewport
      maxToRenderPerBatch={10} // Number of items to render per batch
      initialNumToRender={10} // Initial render amount
      windowSize={10} // Number of screens to keep in memory
      
      // Reduce memory usage
      getItemLayout={(data, index) => ({
        length: ITEM_HEIGHT,
        offset: ITEM_HEIGHT * index,
        index,
      })}
    />
  );
}</code></pre>

            <h2>Navigation State Optimization</h2>
            <pre><code class="language-javascript">// Optimize navigation state persistence
import AsyncStorage from '@react-native-async-storage/async-storage';

const PERSISTENCE_KEY = 'NAVIGATION_STATE';

function App() {
  const [isReady, setIsReady] = useState(false);
  const [initialState, setInitialState] = useState();

  useEffect(() => {
    const restoreState = async () => {
      try {
        const savedStateString = await AsyncStorage.getItem(PERSISTENCE_KEY);
        const state = savedStateString ? JSON.parse(savedStateString) : undefined;

        // Validate and clean state
        if (state) {
          // Remove heavy data from navigation state
          const cleanState = removeHeavyData(state);
          setInitialState(cleanState);
        }
      } finally {
        setIsReady(true);
      }
    };

    restoreState();
  }, []);

  if (!isReady) {
    return <SplashScreen />;
  }

  return (
    <NavigationContainer
      initialState={initialState}
      onStateChange={(state) => {
        // Debounce state persistence
        saveStateDebounced(state);
      }}
    >
      <RootNavigator />
    </NavigationContainer>
  );
}

// Debounced state saving
const saveStateDebounced = debounce(async (state) => {
  try {
    // Clean state before saving
    const cleanState = removeHeavyData(state);
    await AsyncStorage.setItem(PERSISTENCE_KEY, JSON.stringify(cleanState));
  } catch (error) {
    console.error('Failed to save navigation state');
  }
}, 1000);

// Remove heavy data from navigation state
function removeHeavyData(state) {
  if (!state) return state;
  
  return {
    ...state,
    routes: state.routes.map(route => ({
      ...route,
      params: cleanParams(route.params),
      state: route.state ? removeHeavyData(route.state) : undefined,
    })),
  };
}

function cleanParams(params) {
  if (!params) return params;
  
  // Remove large objects, keep only IDs
  const { largeData, images, ...cleanedParams } = params;
  
  return cleanedParams;
}</code></pre>

            <h2>Gesture and Animation Performance</h2>
            <pre><code class="language-javascript">// Optimize navigation animations
import {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  runOnJS,
} from 'react-native-reanimated';

// Custom optimized transition
const OptimizedTransition = {
  cardStyleInterpolator: ({ current, layouts }) => {
    return {
      cardStyle: {
        transform: [
          {
            translateX: current.progress.interpolate({
              inputRange: [0, 1],
              outputRange: [layouts.screen.width, 0],
              // Use native driver
              extrapolate: 'clamp',
            }),
          },
        ],
      },
    };
  },
  // Reduce gesture response area for better performance
  gestureResponseDistance: {
    horizontal: 50,
  },
  // Speed up animations
  transitionSpec: {
    open: {
      animation: 'spring',
      config: {
        stiffness: 1000,
        damping: 500,
        mass: 3,
        overshootClamping: true,
        restDisplacementThreshold: 0.01,
        restSpeedThreshold: 0.01,
      },
    },
    close: {
      animation: 'timing',
      config: {
        duration: 200,
      },
    },
  },
};

// Disable animations for low-end devices
import { isLowEndDevice } from 'react-native-device-info';

<Stack.Navigator
  screenOptions={{
    animationEnabled: !isLowEndDevice(),
    ...(isLowEndDevice() && {
      cardStyleInterpolator: CardStyleInterpolators.forNoAnimation,
    }),
  }}
>
  {/* screens */}
</Stack.Navigator></code></pre>

            <h2>Tab Navigation Optimization</h2>
            <pre><code class="language-javascript">// Lazy loading tabs
<Tab.Navigator
  screenOptions={{
    lazy: true, // Load tabs only when first visited
    unmountOnBlur: false, // Keep tabs mounted (default)
  }}
  // Or use lazy with custom placeholder
  lazy={({ route }) => {
    // Custom lazy loading logic
    return route.name !== 'Home'; // Always load Home, lazy load others
  }}
  // Custom placeholder while loading
  tabBarOptions={{
    lazyPlaceholder: ({ route }) => (
      <View style={styles.lazyPlaceholder}>
        <ActivityIndicator />
        <Text>Loading {route.name}...</Text>
      </View>
    ),
  }}
>
  <Tab.Screen name="Home" component={HomeScreen} />
  <Tab.Screen 
    name="Search" 
    component={SearchScreen}
    options={{
      lazy: true,
    }}
  />
  <Tab.Screen 
    name="Heavy" 
    component={HeavyScreen}
    options={{
      lazy: true,
      unmountOnBlur: true, // Unmount heavy screen when not visible
    }}
  />
</Tab.Navigator>

// Optimize tab bar rendering
const OptimizedTabBar = React.memo(({ state, descriptors, navigation }) => {
  // Memoize expensive computations
  const routes = useMemo(() => state.routes, [state.routes]);
  
  return (
    <View style={styles.tabBar}>
      {routes.map((route, index) => {
        const isFocused = state.index === index;
        
        return (
          <TabBarItem
            key={route.key}
            route={route}
            isFocused={isFocused}
            navigation={navigation}
            descriptor={descriptors[route.key]}
          />
        );
      })}
    </View>
  );
});

// Memoized tab bar item
const TabBarItem = React.memo(({ route, isFocused, navigation, descriptor }) => {
  const onPress = useCallback(() => {
    const event = navigation.emit({
      type: 'tabPress',
      target: route.key,
      canPreventDefault: true,
    });

    if (!isFocused && !event.defaultPrevented) {
      navigation.navigate(route.name);
    }
  }, [navigation, route, isFocused]);

  return (
    <TouchableOpacity onPress={onPress} style={styles.tabItem}>
      {/* Tab content */}
    </TouchableOpacity>
  );
});</code></pre>

            <h2>Navigation Metrics and Monitoring</h2>
            <pre><code class="language-javascript">// Performance monitoring for navigation
import performance from 'react-native-performance';

// Navigation performance tracker
class NavigationPerformanceTracker {
  constructor() {
    this.transitions = new Map();
  }

  startTransition(from, to) {
    const key = \`\${from}->\${to}\`;
    this.transitions.set(key, {
      startTime: performance.now(),
      from,
      to,
    });
  }

  endTransition(from, to) {
    const key = \`\${from}->\${to}\`;
    const transition = this.transitions.get(key);
    
    if (transition) {
      const duration = performance.now() - transition.startTime;
      this.transitions.delete(key);
      
      // Log metrics
      analytics().logEvent('navigation_performance', {
        from,
        to,
        duration,
        slow: duration > 500, // Flag slow transitions
      });
      
      // Send to monitoring service
      if (duration > 1000) {
        crashlytics().log(\`Slow navigation: \${from} -> \${to} took \${duration}ms\`);
      }
    }
  }
}

const tracker = new NavigationPerformanceTracker();

// Use in navigation container
<NavigationContainer
  onStateChange={(state) => {
    const currentRoute = getCurrentRouteName(state);
    
    if (previousRoute && currentRoute && previousRoute !== currentRoute) {
      tracker.endTransition(previousRoute, currentRoute);
    }
    
    tracker.startTransition(currentRoute, '');
    previousRoute = currentRoute;
  }}
>
  {/* navigators */}
</NavigationContainer>

// Screen render performance
function useScreenPerformance(screenName) {
  useEffect(() => {
    const startTime = performance.now();
    
    return () => {
      const renderTime = performance.now() - startTime;
      
      analytics().logEvent('screen_render_time', {
        screen: screenName,
        duration: renderTime,
      });
    };
  }, [screenName]);
}</code></pre>

            <h2>Bundle Splitting and Code Splitting</h2>
            <pre><code class="language-javascript">// Split bundles by feature
// metro.config.js
module.exports = {
  serializer: {
    customSerializer: createModuleIdFactory(),
  },
  resolver: {
    // Group files into chunks
    experimentalImportBundleSupport: true,
  },
};

// Dynamic imports for features
const loadFeature = async (featureName) => {
  switch (featureName) {
    case 'camera':
      return import(/* webpackChunkName: "camera" */ './features/Camera');
    case 'maps':
      return import(/* webpackChunkName: "maps" */ './features/Maps');
    case 'video':
      return import(/* webpackChunkName: "video" */ './features/Video');
    default:
      throw new Error(\`Unknown feature: \${featureName}\`);
  }
};

// Feature-based navigator
function FeatureNavigator({ feature }) {
  const [Component, setComponent] = useState(null);
  
  useEffect(() => {
    loadFeature(feature)
      .then(module => setComponent(() => module.default))
      .catch(error => {
        console.error('Failed to load feature:', error);
        setComponent(() => ErrorScreen);
      });
  }, [feature]);
  
  if (!Component) {
    return <LoadingScreen />;
  }
  
  return <Component />;
}

// RAM bundles for faster startup
// react-native.config.js
module.exports = {
  project: {
    android: {
      packager: {
        ramBundle: true,
      },
    },
    ios: {
      packager: {
        ramBundle: true,
      },
    },
  },
};</code></pre>

            <h2>Best Practices Summary</h2>
            <pre><code class="language-javascript">// Navigation performance checklist
const NavigationPerformanceChecklist = {
  // 1. Lazy load heavy screens
  lazyLoading: {
    enabled: true,
    screens: ['Profile', 'Settings', 'HeavyFeature'],
  },
  
  // 2. Optimize images in navigation
  imageOptimization: {
    useThumbails: true,
    lazyLoadImages: true,
    cacheImages: true,
  },
  
  // 3. Minimize navigation state
  stateOptimization: {
    avoidLargeParams: true,
    cleanStateOnPersist: true,
    limitStackDepth: 10,
  },
  
  // 4. Animation performance
  animations: {
    useNativeDriver: true,
    reduceComplexity: true,
    disableOnLowEnd: true,
  },
  
  // 5. Memory management
  memoryManagement: {
    unmountHeavyScreens: true,
    clearCachesOnBlur: true,
    limitTabHistory: true,
  },
  
  // 6. Monitoring
  monitoring: {
    trackTransitions: true,
    measureRenderTime: true,
    reportSlowScreens: true,
  },
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Always lazy load heavy screens and features</li>
                    <li>Monitor navigation performance in production</li>
                    <li>Use native driver for animations when possible</li>
                    <li>Clean up resources when screens lose focus</li>
                    <li>Optimize bundle size with code splitting</li>
                    <li>Test on low-end devices regularly</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the benefit of lazy loading screens?",
            options: [
                "Better animations",
                "Reduced initial bundle size and memory usage",
                "Easier development",
                "Better deep linking"
            ],
            correct: 1
        },
        {
            question: "When should you use unmountOnBlur?",
            options: [
                "Always",
                "Never",
                "For memory-intensive screens",
                "Only for modals"
            ],
            correct: 2
        },
        {
            question: "What does removeClippedSubviews do in FlatList?",
            options: [
                "Removes items from data",
                "Unmounts items outside viewport",
                "Clips the list view",
                "Removes separators"
            ],
            correct: 1
        }
    ],
    project: {
        title: "Performance-Optimized News App",
        description: "Build a news app with optimized navigation for smooth performance",
        requirements: [
            "Implement lazy loading for all screens",
            "Optimize list views with large datasets",
            "Add performance monitoring",
            "Implement code splitting by feature",
            "Handle low-end devices gracefully",
            "Cache navigation state efficiently",
            "Track and report slow transitions",
            "Optimize images in navigation"
        ],
        hints: [
            "Use React.memo and useMemo wisely",
            "Implement virtual scrolling for long lists",
            "Monitor bundle size regularly",
            "Test on various devices and network conditions"
        ]
    }
},
'animated-api': {
    content: `
        <div class="content-section">
            <h1>Animated API Basics</h1>
            
            <div class="info-box">
                <p>React Native's Animated API provides a powerful and performant way to create fluid, interactive animations. It allows you to animate component properties with fine-grained control over the animation lifecycle.</p>
            </div>

            <h2>Core Concepts</h2>
            <pre><code class="language-javascript">import { Animated } from 'react-native';

// Create animated values
const animatedValue = new Animated.Value(0); // Single value
const animatedXY = new Animated.ValueXY({ x: 0, y: 0 }); // X,Y values

// Animated components
Animated.View
Animated.Text
Animated.ScrollView
Animated.Image
Animated.FlatList
Animated.SectionList

// Create custom animated component
const AnimatedTouchableOpacity = Animated.createAnimatedComponent(TouchableOpacity);</code></pre>

            <h2>Basic Animation Example</h2>
            <pre><code class="language-javascript">import React, { useRef, useEffect } from 'react';
import { Animated, View, Button, StyleSheet } from 'react-native';

const FadeInView = ({ children, duration = 1000 }) => {
  const fadeAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: duration,
      useNativeDriver: true, // Enable native driver for better performance
    }).start();
  }, [fadeAnim, duration]);

  return (
    <Animated.View
      style={{
        ...styles.container,
        opacity: fadeAnim, // Bind opacity to animated value
      }}
    >
      {children}
    </Animated.View>
  );
};

// Usage
export default function App() {
  return (
    <View style={styles.container}>
      <FadeInView>
        <Text style={styles.text}>Fading in!</Text>
      </FadeInView>
    </View>
  );
}</code></pre>

            <h2>Animation Types</h2>
            <pre><code class="language-javascript">// 1. Timing Animation - animate over time with easing
const animateWithTiming = () => {
  Animated.timing(animatedValue, {
    toValue: 100,
    duration: 1000,
    easing: Easing.ease, // Built-in easing functions
    delay: 500, // Start after delay
    useNativeDriver: false, // Required for layout properties
  }).start((finished) => {
    console.log('Animation finished:', finished);
  });
};

// 2. Spring Animation - physics-based spring animation
const animateWithSpring = () => {
  Animated.spring(animatedValue, {
    toValue: 100,
    friction: 7, // Controls "bounciness"
    tension: 40, // Controls speed
    speed: 12, // Alternative to friction/tension
    bounciness: 8, // Alternative to friction/tension
    useNativeDriver: true,
  }).start();
};

// 3. Decay Animation - gradually slows to a stop
const animateWithDecay = () => {
  Animated.decay(animatedValue, {
    velocity: 0.5, // Initial velocity
    deceleration: 0.997, // Rate of deceleration
    useNativeDriver: true,
  }).start();
};</code></pre>

            <h2>Interpolation</h2>
            <pre><code class="language-javascript">// Interpolation maps input ranges to output ranges
const AnimatedBox = () => {
  const animatedValue = useRef(new Animated.Value(0)).current;

  // Basic interpolation
  const opacity = animatedValue.interpolate({
    inputRange: [0, 50, 100],
    outputRange: [0, 1, 0.5],
  });

  // Color interpolation
  const backgroundColor = animatedValue.interpolate({
    inputRange: [0, 50, 100],
    outputRange: ['rgb(255, 0, 0)', 'rgb(0, 255, 0)', 'rgb(0, 0, 255)'],
  });

  // Rotation interpolation
  const rotation = animatedValue.interpolate({
    inputRange: [0, 100],
    outputRange: ['0deg', '360deg'],
  });

  // Scale with extrapolation
  const scale = animatedValue.interpolate({
    inputRange: [0, 50, 100],
    outputRange: [1, 1.5, 1],
    extrapolate: 'clamp', // 'extend' | 'clamp' | 'identity'
  });

  const animate = () => {
    Animated.timing(animatedValue, {
      toValue: 100,
      duration: 2000,
      useNativeDriver: false, // Can't use native driver with color
    }).start();
  };

  return (
    <View style={styles.container}>
      <Animated.View
        style={[
          styles.box,
          {
            opacity,
            backgroundColor,
            transform: [
              { rotate: rotation },
              { scale: scale },
            ],
          },
        ]}
      />
      <Button title="Animate" onPress={animate} />
    </View>
  );
};</code></pre>

            <h2>Combining Animations</h2>
            <pre><code class="language-javascript">// Parallel - run animations at the same time
const parallelAnimation = () => {
  Animated.parallel([
    Animated.timing(animatedX, {
      toValue: 100,
      duration: 1000,
      useNativeDriver: true,
    }),
    Animated.spring(animatedY, {
      toValue: 100,
      friction: 7,
      useNativeDriver: true,
    }),
  ]).start();
};

// Sequence - run animations one after another
const sequenceAnimation = () => {
  Animated.sequence([
    Animated.timing(animatedValue, {
      toValue: 100,
      duration: 500,
      useNativeDriver: true,
    }),
    Animated.delay(200), // Pause between animations
    Animated.spring(animatedValue, {
      toValue: 0,
      friction: 7,
      useNativeDriver: true,
    }),
  ]).start();
};

// Stagger - start animations with delays
const staggerAnimation = () => {
  Animated.stagger(100, [
    Animated.timing(anim1, {
      toValue: 1,
      duration: 500,
      useNativeDriver: true,
    }),
    Animated.timing(anim2, {
      toValue: 1,
      duration: 500,
      useNativeDriver: true,
    }),
    Animated.timing(anim3, {
      toValue: 1,
      duration: 500,
      useNativeDriver: true,
    }),
  ]).start();
};

// Loop animation
const loopAnimation = () => {
  Animated.loop(
    Animated.sequence([
      Animated.timing(animatedValue, {
        toValue: 1,
        duration: 1000,
        useNativeDriver: true,
      }),
      Animated.timing(animatedValue, {
        toValue: 0,
        duration: 1000,
        useNativeDriver: true,
      }),
    ]),
    {
      iterations: -1, // Infinite loop
    }
  ).start();
};</code></pre>

            <h2>Animated Events</h2>
            <pre><code class="language-javascript">// Bind animations to scroll events
const AnimatedScrollView = () => {
  const scrollY = useRef(new Animated.Value(0)).current;

  // Interpolate scroll value
  const headerOpacity = scrollY.interpolate({
    inputRange: [0, 100],
    outputRange: [1, 0],
    extrapolate: 'clamp',
  });

  const headerTranslateY = scrollY.interpolate({
    inputRange: [0, 100],
    outputRange: [0, -100],
    extrapolate: 'clamp',
  });

  return (
    <View style={styles.container}>
      {/* Animated header */}
      <Animated.View
        style={[
          styles.header,
          {
            opacity: headerOpacity,
            transform: [{ translateY: headerTranslateY }],
          },
        ]}
      >
        <Text style={styles.headerText}>Header</Text>
      </Animated.View>

      {/* Animated scroll view */}
      <Animated.ScrollView
        scrollEventThrottle={16} // For smooth animation
        onScroll={Animated.event(
          [{ nativeEvent: { contentOffset: { y: scrollY } } }],
          { useNativeDriver: true } // Use native driver for better performance
        )}
      >
        {/* Content */}
        {Array(50).fill(0).map((_, i) => (
          <View key={i} style={styles.item}>
            <Text>Item {i}</Text>
          </View>
        ))}
      </Animated.ScrollView>
    </View>
  );
};

// Pan gesture animation
const DraggableBox = () => {
  const pan = useRef(new Animated.ValueXY()).current;

  const panResponder = useRef(
    PanResponder.create({
      onMoveShouldSetPanResponder: () => true,
      onPanResponderGrant: () => {
        pan.setOffset({
          x: pan.x._value,
          y: pan.y._value,
        });
      },
      onPanResponderMove: Animated.event(
        [null, { dx: pan.x, dy: pan.y }],
        { useNativeDriver: false }
      ),
      onPanResponderRelease: () => {
        pan.flattenOffset();
        // Spring back to center
        Animated.spring(pan, {
          toValue: { x: 0, y: 0 },
          friction: 5,
          useNativeDriver: false,
        }).start();
      },
    })
  ).current;

  return (
    <View style={styles.container}>
      <Animated.View
        style={[
          styles.box,
          {
            transform: [
              { translateX: pan.x },
              { translateY: pan.y },
            ],
          },
        ]}
        {...panResponder.panHandlers}
      />
    </View>
  );
};</code></pre>

            <h2>Performance Optimization</h2>
            <pre><code class="language-javascript">// Use native driver when possible
const performantAnimation = () => {
  // ✅ Good - uses native driver
  Animated.timing(animatedValue, {
    toValue: 1,
    duration: 300,
    useNativeDriver: true, // Runs on UI thread
  }).start();

  // ❌ Bad - can't use native driver for layout properties
  Animated.timing(widthValue, {
    toValue: 200,
    duration: 300,
    useNativeDriver: false, // Runs on JS thread
  }).start();
};

// Optimize with setNativeProps
class OptimizedComponent extends React.Component {
  setNativeProps = (props) => {
    this._component.setNativeProps(props);
  };

  render() {
    return (
      <View ref={component => this._component = component}>
        {this.props.children}
      </View>
    );
  }
}

// Use Animated.Value listeners sparingly
const animatedValue = new Animated.Value(0);

// ❌ Avoid - causes re-renders
animatedValue.addListener(({ value }) => {
  setState({ currentValue: value });
});

// ✅ Better - use interpolation
const opacity = animatedValue.interpolate({
  inputRange: [0, 1],
  outputRange: [0, 1],
});</code></pre>

            <h2>Common Animation Patterns</h2>
            <pre><code class="language-javascript">// Fade in/out
const FadeInOut = ({ visible, children }) => {
  const opacity = useRef(new Animated.Value(visible ? 1 : 0)).current;

  useEffect(() => {
    Animated.timing(opacity, {
      toValue: visible ? 1 : 0,
      duration: 300,
      useNativeDriver: true,
    }).start();
  }, [visible, opacity]);

  return (
    <Animated.View style={{ opacity }}>
      {children}
    </Animated.View>
  );
};

// Scale button on press
const ScaleButton = ({ onPress, children }) => {
  const scale = useRef(new Animated.Value(1)).current;

  const handlePressIn = () => {
    Animated.spring(scale, {
      toValue: 0.95,
      useNativeDriver: true,
    }).start();
  };

  const handlePressOut = () => {
    Animated.spring(scale, {
      toValue: 1,
      friction: 3,
      tension: 40,
      useNativeDriver: true,
    }).start();
  };

  return (
    <Animated.View style={{ transform: [{ scale }] }}>
      <TouchableWithoutFeedback
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        onPress={onPress}
      >
        <View style={styles.button}>
          {children}
        </View>
      </TouchableWithoutFeedback>
    </Animated.View>
  );
};

// Sliding menu
const SlideInMenu = ({ visible }) => {
  const slideAnim = useRef(new Animated.Value(-300)).current;

  useEffect(() => {
    Animated.timing(slideAnim, {
      toValue: visible ? 0 : -300,
      duration: 300,
      useNativeDriver: true,
    }).start();
  }, [visible, slideAnim]);

  return (
    <Animated.View
      style={[
        styles.menu,
        {
          transform: [{ translateX: slideAnim }],
        },
      ]}
    >
      {/* Menu content */}
    </Animated.View>
  );
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Always use useNativeDriver when possible for better performance</li>
                    <li>Avoid animating layout properties (width, height, padding)</li>
                    <li>Use transform properties instead of position properties</li>
                    <li>Set appropriate scrollEventThrottle for smooth scroll animations</li>
                    <li>Clean up animations and listeners to prevent memory leaks</li>
                    <li>Test animations on low-end devices</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "Which properties can use useNativeDriver?",
            options: [
                "All properties",
                "Transform and opacity only",
                "Layout properties only",
                "Color properties only"
            ],
            correct: 1
        },
        {
            question: "What does interpolation do in animations?",
            options: [
                "Makes animations faster",
                "Maps input values to output values",
                "Combines multiple animations",
                "Loops animations"
            ],
            correct: 1
        },
        {
            question: "Which animation type is best for natural motion?",
            options: [
                "Timing with linear easing",
                "Decay",
                "Spring",
                "Loop"
            ],
            correct: 2
        }
    ],
    project: {
        title: "Animated Onboarding Flow",
        description: "Create an engaging onboarding experience with various animations",
        requirements: [
            "Fade in welcome text",
            "Slide in feature cards with stagger effect",
            "Parallax scrolling effect",
            "Animated progress indicator",
            "Scale and fade buttons on press",
            "Swipe gestures between screens",
            "Spring animations for interactive elements"
        ],
        hints: [
            "Use sequence for step-by-step animations",
            "Implement stagger for list items",
            "Combine multiple animation types",
            "Pay attention to timing and easing"
        ]
    }
},
'layout-animations': {
    content: `
        <div class="content-section">
            <h1>LayoutAnimation</h1>
            
            <div class="info-box">
                <p>LayoutAnimation provides an easy way to animate layout changes globally. It automatically animates views to their new positions when the layout changes, perfect for list reordering, adding/removing items, and expanding/collapsing content.</p>
            </div>

            <h2>Basic Setup</h2>
            <pre><code class="language-javascript">import {
  LayoutAnimation,
  Platform,
  UIManager,
  View,
  Text,
  TouchableOpacity,
} from 'react-native';

// Enable LayoutAnimation on Android
if (Platform.OS === 'android') {
  if (UIManager.setLayoutAnimationEnabledExperimental) {
    UIManager.setLayoutAnimationEnabledExperimental(true);
  }
}</code></pre>

            <h2>Preset Animations</h2>
            <pre><code class="language-javascript">// Built-in presets
const BasicLayoutAnimation = () => {
  const [expanded, setExpanded] = useState(false);
  const [items, setItems] = useState(['Item 1', 'Item 2', 'Item 3']);

  const toggleExpand = () => {
    // Configure animation before state change
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setExpanded(!expanded);
  };

  const addItem = () => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.spring);
    setItems([...items, \`Item \${items.length + 1}\`]);
  };

  const removeItem = (index) => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.linear);
    setItems(items.filter((_, i) => i !== index));
  };

  return (
    <View style={styles.container}>
      <TouchableOpacity onPress={toggleExpand} style={styles.header}>
        <Text>Toggle Content</Text>
      </TouchableOpacity>
      
      {expanded && (
        <View style={styles.content}>
          <Text>Expanded content with animation!</Text>
        </View>
      )}

      <TouchableOpacity onPress={addItem} style={styles.button}>
        <Text>Add Item</Text>
      </TouchableOpacity>

      {items.map((item, index) => (
        <TouchableOpacity
          key={item}
          onPress={() => removeItem(index)}
          style={styles.item}
        >
          <Text>{item}</Text>
        </TouchableOpacity>
      ))}
    </View>
  );
};</code></pre>

            <h2>Custom Animations</h2>
            <pre><code class="language-javascript">// Custom animation configuration
const customAnimation = {
  duration: 300,
  create: {
    type: LayoutAnimation.Types.linear,
    property: LayoutAnimation.Properties.opacity,
  },
  update: {
    type: LayoutAnimation.Types.easeInEaseOut,
    springDamping: 0.7,
  },
  delete: {
    type: LayoutAnimation.Types.linear,
    property: LayoutAnimation.Properties.opacity,
    duration: 200,
  },
};

// Apply custom animation
const animateCustom = () => {
  LayoutAnimation.configureNext(customAnimation);
  // Make state changes
};

// More detailed custom animation
const detailedAnimation = () => {
  LayoutAnimation.configureNext(
    {
      duration: 500,
      create: {
        type: LayoutAnimation.Types.spring,
        property: LayoutAnimation.Properties.scaleXY,
        springDamping: 0.7,
      },
      update: {
        type: LayoutAnimation.Types.spring,
        springDamping: 0.7,
      },
      delete: {
        type: LayoutAnimation.Types.linear,
        property: LayoutAnimation.Properties.opacity,
      },
    },
    () => console.log('Animation completed'), // Completion callback
    () => console.log('Animation failed') // Failure callback
  );
};</code></pre>

            <h2>Expandable List Example</h2>
            <pre><code class="language-javascript">const ExpandableListItem = ({ item, onPress }) => {
  const [expanded, setExpanded] = useState(false);

  const toggleExpanded = () => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setExpanded(!expanded);
    onPress?.();
  };

  return (
    <View style={styles.listItem}>
      <TouchableOpacity onPress={toggleExpanded} style={styles.listHeader}>
        <Text style={styles.listTitle}>{item.title}</Text>
        <Text style={styles.arrow}>{expanded ? '▼' : '▶'}</Text>
      </TouchableOpacity>
      
      {expanded && (
        <View style={styles.listContent}>
          <Text>{item.description}</Text>
          {item.details && (
            <View style={styles.details}>
              {item.details.map((detail, index) => (
                <Text key={index} style={styles.detailText}>
                  • {detail}
                </Text>
              ))}
            </View>
          )}
        </View>
      )}
    </View>
  );
};

const ExpandableList = () => {
  const [selectedId, setSelectedId] = useState(null);

  const data = [
    {
      id: '1',
      title: 'First Item',
      description: 'This is the first item description',
      details: ['Detail 1', 'Detail 2', 'Detail 3'],
    },
    {
      id: '2',
      title: 'Second Item',
      description: 'This is the second item description',
      details: ['Detail A', 'Detail B'],
    },
  ];

  const handlePress = (id) => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setSelectedId(selectedId === id ? null : id);
  };

  return (
    <FlatList
      data={data}
      keyExtractor={(item) => item.id}
      renderItem={({ item }) => (
        <ExpandableListItem
          item={item}
          onPress={() => handlePress(item.id)}
        />
      )}
    />
  );
};</code></pre>

            <h2>Grid Layout Animation</h2>
            <pre><code class="language-javascript">const AnimatedGrid = () => {
  const [numColumns, setNumColumns] = useState(2);
  const [items, setItems] = useState(
    Array(12).fill(0).map((_, i) => ({ id: i, color: getRandomColor() }))
  );

  const changeLayout = (columns) => {
    LayoutAnimation.configureNext(
      LayoutAnimation.create(
        300,
        LayoutAnimation.Types.easeInEaseOut,
        LayoutAnimation.Properties.opacity
      )
    );
    setNumColumns(columns);
  };

  const shuffleItems = () => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.spring);
    setItems([...items].sort(() => Math.random() - 0.5));
  };

  const addItem = () => {
    LayoutAnimation.spring();
    setItems([...items, { 
      id: items.length, 
      color: getRandomColor() 
    }]);
  };

  const removeItem = (id) => {
    LayoutAnimation.configureNext({
      duration: 200,
      delete: {
        type: LayoutAnimation.Types.easeOut,
        property: LayoutAnimation.Properties.scaleXY,
      },
    });
    setItems(items.filter(item => item.id !== id));
  };

  return (
    <View style={styles.container}>
      <View style={styles.controls}>
        <Button title="2 Columns" onPress={() => changeLayout(2)} />
        <Button title="3 Columns" onPress={() => changeLayout(3)} />
        <Button title="4 Columns" onPress={() => changeLayout(4)} />
        <Button title="Shuffle" onPress={shuffleItems} />
        <Button title="Add" onPress={addItem} />
      </View>

      <FlatList
        data={items}
        numColumns={numColumns}
        key={numColumns} // Force re-render on column change
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => (
          <TouchableOpacity
            onPress={() => removeItem(item.id)}
            style={[
              styles.gridItem,
              { 
                backgroundColor: item.color,
                width: \`\${100 / numColumns}%\`,
              }
            ]}
          >
            <Text style={styles.gridText}>{item.id}</Text>
          </TouchableOpacity>
        )}
      />
    </View>
  );
};</code></pre>

            <h2>Form Animation</h2>
            <pre><code class="language-javascript">const AnimatedForm = () => {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    subscribe: false,
  });
  const [errors, setErrors] = useState({});
  const [showOptional, setShowOptional] = useState(false);

  const toggleOptionalFields = () => {
    LayoutAnimation.configureNext(
      LayoutAnimation.create(
        300,
        LayoutAnimation.Types.easeInEaseOut,
        LayoutAnimation.Properties.scaleY
      )
    );
    setShowOptional(!showOptional);
  };

  const showError = (field) => {
    LayoutAnimation.spring();
    setErrors({ ...errors, [field]: true });
  };

  const hideError = (field) => {
    LayoutAnimation.easeInEaseOut();
    const newErrors = { ...errors };
    delete newErrors[field];
    setErrors(newErrors);
  };

  return (
    <ScrollView style={styles.form}>
      <View style={styles.formGroup}>
        <Text style={styles.label}>Name</Text>
        <TextInput
          style={[styles.input, errors.name && styles.inputError]}
          value={formData.name}
          onChangeText={(text) => {
            setFormData({ ...formData, name: text });
            if (errors.name) hideError('name');
          }}
          onBlur={() => {
            if (!formData.name) showError('name');
          }}
        />
        {errors.name && (
          <Text style={styles.errorText}>Name is required</Text>
        )}
      </View>

      <View style={styles.formGroup}>
        <Text style={styles.label}>Email</Text>
        <TextInput
          style={[styles.input, errors.email && styles.inputError]}
          value={formData.email}
          onChangeText={(text) => {
            setFormData({ ...formData, email: text });
            if (errors.email) hideError('email');
          }}
          keyboardType="email-address"
        />
      </View>

      <TouchableOpacity
        onPress={toggleOptionalFields}
        style={styles.optionalToggle}
      >
        <Text>
          {showOptional ? 'Hide' : 'Show'} Optional Fields
        </Text>
      </TouchableOpacity>

      {showOptional && (
        <View style={styles.optionalFields}>
          <View style={styles.formGroup}>
            <Text style={styles.label}>Phone</Text>
            <TextInput
              style={styles.input}
              keyboardType="phone-pad"
            />
          </View>
          <View style={styles.formGroup}>
            <Text style={styles.label}>Address</Text>
            <TextInput
              style={[styles.input, styles.textArea]}
              multiline
              numberOfLines={3}
            />
          </View>
        </View>
      )}

      <View style={styles.formGroup}>
        <TouchableOpacity
          onPress={() => {
            LayoutAnimation.spring();
            setFormData({ 
              ...formData, 
              subscribe: !formData.subscribe 
            });
          }}
          style={styles.checkbox}
        >
          <View style={[
            styles.checkboxBox,
            formData.subscribe && styles.checkboxChecked
          ]}>
            {formData.subscribe && <Text>✓</Text>}
          </View>
          <Text>Subscribe to newsletter</Text>
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
};</code></pre>

            <h2>Comparison with Animated API</h2>
            <pre><code class="language-javascript">// When to use LayoutAnimation vs Animated API

// LayoutAnimation - Good for:
// ✅ Global layout changes
// ✅ Adding/removing items from lists
// ✅ Expanding/collapsing content
// ✅ Simple transitions
// ✅ Multiple elements animating together

const UseLayoutAnimation = () => {
  const [items, setItems] = useState([1, 2, 3]);

  const addItem = () => {
    LayoutAnimation.spring();
    setItems([...items, items.length + 1]);
  };

  return (
    <View>
      {items.map(item => (
        <View key={item} style={styles.item}>
          <Text>Item {item}</Text>
        </View>
      ))}
      <Button title="Add Item" onPress={addItem} />
    </View>
  );
};

// Animated API - Good for:
// ✅ Fine-grained control
// ✅ Gesture-based animations
// ✅ Complex interpolations
// ✅ Performance-critical animations
// ✅ Continuous animations

const UseAnimatedAPI = () => {
  const pan = useRef(new Animated.ValueXY()).current;
  const opacity = useRef(new Animated.Value(1)).current;

  // Complex gesture handling
  const panResponder = PanResponder.create({
    onMoveShouldSetPanResponder: () => true,
    onPanResponderMove: Animated.event(
      [null, { dx: pan.x, dy: pan.y }],
      { useNativeDriver: false }
    ),
    onPanResponderRelease: () => {
      Animated.spring(pan, {
        toValue: { x: 0, y: 0 },
        useNativeDriver: true,
      }).start();
    },
  });

  return (
    <Animated.View
      style={{
        transform: [
          { translateX: pan.x },
          { translateY: pan.y },
        ],
        opacity,
      }}
      {...panResponder.panHandlers}
    >
      <Text>Drag me!</Text>
    </Animated.View>
  );
};</code></pre>

            <h2>Performance Considerations</h2>
            <pre><code class="language-javascript">// Batch animations for better performance
const BatchedAnimations = () => {
  const [items, setItems] = useState([]);

  const addMultipleItems = () => {
    // Single LayoutAnimation for multiple changes
    LayoutAnimation.configureNext(LayoutAnimation.Presets.spring);
    
    const newItems = Array(5).fill(0).map((_, i) => ({
      id: Date.now() + i,
      text: \`Item \${items.length + i + 1}\`,
    }));
    
    setItems([...items, ...newItems]);
  };

  return (
    <View>
      <FlatList
        data={items}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => (
          <View style={styles.item}>
            <Text>{item.text}</Text>
          </View>
        )}
      />
      <Button title="Add 5 Items" onPress={addMultipleItems} />
    </View>
  );
};

// Avoid excessive animations
const OptimizedComponent = () => {
  const [data, setData] = useState([]);
  const animationInProgress = useRef(false);

  const updateData = (newData) => {
    if (animationInProgress.current) return;
    
    animationInProgress.current = true;
    LayoutAnimation.configureNext(
      LayoutAnimation.Presets.easeInEaseOut,
      () => {
        animationInProgress.current = false;
      }
    );
    
    setData(newData);
  };

  return <View>{/* Component content */}</View>;
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Enable LayoutAnimation on Android at app startup</li>
                    <li>Call configureNext before state changes</li>
                    <li>Use presets for common animations</li>
                    <li>Be careful with FlatList - use unique keys</li>
                    <li>Test on both platforms as behavior may differ</li>
                    <li>Consider Animated API for complex animations</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "When should you call LayoutAnimation.configureNext()?",
            options: [
                "After state changes",
                "Before state changes",
                "In useEffect",
                "In component constructor"
            ],
            correct: 1
        },
        {
            question: "What's required to use LayoutAnimation on Android?",
            options: [
                "Nothing special",
                "Import from react-native-reanimated",
                "Call UIManager.setLayoutAnimationEnabledExperimental(true)",
                "Use Animated API instead"
            ],
            correct: 2
        },
        {
            question: "LayoutAnimation is best for:",
            options: [
                "Gesture animations",
                "Continuous animations",
                "Layout changes like adding/removing items",
                "Complex interpolations"
            ],
            correct: 2
        }
    ],
    project: {
        title: "Expandable FAQ Section",
        description: "Build an animated FAQ section with smooth expand/collapse animations",
        requirements: [
            "Accordion-style FAQ list",
            "Smooth expand/collapse animations",
            "Animated arrow indicators",
            "Search with animated filtering",
            "Add/remove FAQ items dynamically",
            "Stagger animation when loading",
            "Highlight searched terms with animation"
        ],
        hints: [
            "Use LayoutAnimation for expand/collapse",
            "Implement search with animated filtering",
            "Add visual feedback for interactions",
            "Consider accessibility"
        ]
    }
},
'reanimated2': {
    content: `
        <div class="content-section">
            <h1>Reanimated 2</h1>
            
            <div class="info-box">
                <p>React Native Reanimated 2 is a powerful animation library that provides a more flexible and performant way to create animations. It runs animations on the UI thread and provides hooks-based API for modern React development.</p>
            </div>

            <h2>Installation</h2>
            <pre><code class="language-bash"># Install Reanimated 2
npm install react-native-reanimated

# iOS setup
cd ios && pod install

# Add Reanimated babel plugin to babel.config.js
module.exports = {
  plugins: [
    'react-native-reanimated/plugin', // Must be last
  ],
};</code></pre>

            <h2>Basic Concepts</h2>
            <pre><code class="language-javascript">import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  withDelay,
  withSequence,
  withRepeat,
} from 'react-native-reanimated';

// Shared Values - can be accessed from both JS and UI thread
const BasicExample = () => {
  const translateX = useSharedValue(0);
  const scale = useSharedValue(1);

  // Animated styles
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: translateX.value },
        { scale: scale.value },
      ],
    };
  });

  const handlePress = () => {
    // Animations run on UI thread
    translateX.value = withSpring(translateX.value + 50);
    scale.value = withSequence(
      withTiming(1.2, { duration: 100 }),
      withSpring(1)
    );
  };

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, animatedStyle]} />
      <Button title="Animate" onPress={handlePress} />
    </View>
  );
};</code></pre>

            <h2>Animation Functions</h2>
            <pre><code class="language-javascript">// withTiming - linear animation over time
const timingAnimation = () => {
  'worklet';
  animatedValue.value = withTiming(100, {
    duration: 500,
    easing: Easing.inOut(Easing.ease),
  });
};

// withSpring - spring physics animation
const springAnimation = () => {
  'worklet';
  animatedValue.value = withSpring(100, {
    damping: 15,
    mass: 1,
    stiffness: 100,
    overshootClamping: false,
    restDisplacementThreshold: 0.01,
    restSpeedThreshold: 2,
  });
};

// withDelay - delay before animation
const delayedAnimation = () => {
  'worklet';
  animatedValue.value = withDelay(500, withSpring(100));
};

// withSequence - run animations in sequence
const sequenceAnimation = () => {
  'worklet';
  animatedValue.value = withSequence(
    withTiming(100, { duration: 300 }),
    withTiming(0, { duration: 300 }),
    withSpring(50)
  );
};

// withRepeat - repeat animation
const repeatAnimation = () => {
  'worklet';
  animatedValue.value = withRepeat(
    withTiming(100, { duration: 1000 }),
    -1, // number of repetitions (-1 for infinite)
    true // reverse animation
  );
};</code></pre>

            <h2>Gesture Animations</h2>
            <pre><code class="language-javascript">import {
  GestureDetector,
  Gesture,
  GestureHandlerRootView,
} from 'react-native-gesture-handler';

const DraggableBox = () => {
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const scale = useSharedValue(1);
  const savedTranslateX = useSharedValue(0);
  const savedTranslateY = useSharedValue(0);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { scale: scale.value },
    ],
  }));

  const panGesture = Gesture.Pan()
    .onStart(() => {
      savedTranslateX.value = translateX.value;
      savedTranslateY.value = translateY.value;
      scale.value = withSpring(1.1);
    })
    .onUpdate((event) => {
      translateX.value = savedTranslateX.value + event.translationX;
      translateY.value = savedTranslateY.value + event.translationY;
    })
    .onEnd(() => {
      scale.value = withSpring(1);
      // Spring back to center
      translateX.value = withSpring(0);
      translateY.value = withSpring(0);
    });

  const tapGesture = Gesture.Tap()
    .numberOfTaps(2)
    .onEnd(() => {
      scale.value = withSequence(
        withSpring(1.5),
        withSpring(1)
      );
    });

  const composedGesture = Gesture.Simultaneous(panGesture, tapGesture);

  return (
    <GestureHandlerRootView style={styles.container}>
      <GestureDetector gesture={composedGesture}>
        <Animated.View style={[styles.box, animatedStyle]} />
      </GestureDetector>
    </GestureHandlerRootView>
  );
};</code></pre>

            <h2>Interpolation and Extrapolation</h2>
            <pre><code class="language-javascript">import {
  interpolate,
  Extrapolate,
  interpolateColor,
  useDerivedValue,
} from 'react-native-reanimated';

const InterpolationExample = () => {
  const progress = useSharedValue(0);

  // Derived values - compute new values from shared values
  const scale = useDerivedValue(() => {
    return interpolate(
      progress.value,
      [0, 0.5, 1],
      [1, 1.5, 1],
      Extrapolate.CLAMP
    );
  });

  const rotation = useDerivedValue(() => {
    return interpolate(
      progress.value,
      [0, 1],
      [0, 360],
      Extrapolate.EXTEND
    );
  });

  const backgroundColor = useDerivedValue(() => {
    return interpolateColor(
      progress.value,
      [0, 0.5, 1],
      ['#FF0000', '#00FF00', '#0000FF']
    );
  });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { scale: scale.value },
      { rotate: \`\${rotation.value}deg\` },
    ],
    backgroundColor: backgroundColor.value,
  }));

  const animate = () => {
    progress.value = withTiming(1, {
      duration: 2000,
      easing: Easing.bezier(0.25, 0.1, 0.25, 1),
    });
  };

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, animatedStyle]} />
      <Button title="Animate" onPress={animate} />
    </View>
  );
};</code></pre>

            <h2>Scroll Animations</h2>
            <pre><code class="language-javascript">import {
  useAnimatedScrollHandler,
  useAnimatedRef,
  scrollTo,
  useScrollViewOffset,
} from 'react-native-reanimated';

const ScrollAnimation = () => {
  const scrollOffset = useSharedValue(0);
  const scrollRef = useAnimatedRef();

  const scrollHandler = useAnimatedScrollHandler({
    onScroll: (event) => {
      scrollOffset.value = event.contentOffset.y;
    },
    onBeginDrag: () => {
      console.log('Started scrolling');
    },
    onEndDrag: () => {
      console.log('Ended scrolling');
    },
  });

  // Header animation based on scroll
  const headerStyle = useAnimatedStyle(() => {
    const height = interpolate(
      scrollOffset.value,
      [0, 100],
      [100, 60],
      Extrapolate.CLAMP
    );

    const opacity = interpolate(
      scrollOffset.value,
      [0, 100],
      [1, 0],
      Extrapolate.CLAMP
    );

    return {
      height,
      opacity,
    };
  });

  // Parallax effect
  const ParallaxImage = ({ source, rate = 0.5 }) => {
    const animatedStyle = useAnimatedStyle(() => ({
      transform: [
        {
          translateY: scrollOffset.value * rate,
        },
      ],
    }));

    return (
      <Animated.Image
        source={source}
        style={[styles.parallaxImage, animatedStyle]}
      />
    );
  };

  // Scroll to top button
  const scrollToTop = () => {
    scrollTo(scrollRef, 0, 0, true);
  };

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.header, headerStyle]}>
        <Text style={styles.headerText}>Header</Text>
      </Animated.View>

      <Animated.ScrollView
        ref={scrollRef}
        onScroll={scrollHandler}
        scrollEventThrottle={16}
      >
        <ParallaxImage source={require('./header.jpg')} rate={0.3} />
        
        {Array(50).fill(0).map((_, i) => (
          <View key={i} style={styles.item}>
            <Text>Item {i}</Text>
          </View>
        ))}
      </Animated.ScrollView>

      <TouchableOpacity style={styles.fab} onPress={scrollToTop}>
        <Text>↑</Text>
      </TouchableOpacity>
    </View>
  );
};</code></pre>

            <h2>Complex Animation Example</h2>
            <pre><code class="language-javascript">// Card flip animation
const FlipCard = () => {
  const flipAnimation = useSharedValue(0);

  const frontAnimatedStyle = useAnimatedStyle(() => {
    const rotateY = interpolate(
      flipAnimation.value,
      [0, 1],
      [0, 180]
    );

    return {
      transform: [
        { perspective: 1000 },
        { rotateY: \`\${rotateY}deg\` },
      ],
      backfaceVisibility: 'hidden',
    };
  });

  const backAnimatedStyle = useAnimatedStyle(() => {
    const rotateY = interpolate(
      flipAnimation.value,
      [0, 1],
      [180, 360]
    );

    return {
      transform: [
        { perspective: 1000 },
        { rotateY: \`\${rotateY}deg\` },
      ],
      backfaceVisibility: 'hidden',
    };
  });

  const flip = () => {
    flipAnimation.value = withTiming(
      flipAnimation.value === 0 ? 1 : 0,
      { duration: 600 }
    );
  };

  return (
    <TouchableOpacity onPress={flip} style={styles.cardContainer}>
      <Animated.View style={[styles.card, styles.front, frontAnimatedStyle]}>
        <Text>Front Side</Text>
      </Animated.View>
      <Animated.View style={[styles.card, styles.back, backAnimatedStyle]}>
        <Text>Back Side</Text>
      </Animated.View>
    </TouchableOpacity>
  );
};

// Circular progress animation
const CircularProgress = ({ progress }) => {
  const animatedProgress = useSharedValue(0);

  useEffect(() => {
    animatedProgress.value = withTiming(progress, {
      duration: 1000,
      easing: Easing.bezier(0.25, 0.1, 0.25, 1),
    });
  }, [progress]);

  const animatedProps = useAnimatedProps(() => {
    const strokeDashoffset = interpolate(
      animatedProgress.value,
      [0, 100],
      [circumference, 0]
    );

    return {
      strokeDashoffset,
    };
  });

  const AnimatedCircle = Animated.createAnimatedComponent(Circle);
  const circumference = 2 * Math.PI * 45;

  return (
    <Svg width={100} height={100}>
      <AnimatedCircle
        cx={50}
        cy={50}
        r={45}
        stroke="#3498db"
        strokeWidth={5}
        fill="none"
        strokeDasharray={circumference}
        animatedProps={animatedProps}
        strokeLinecap="round"
        transform="rotate(-90 50 50)"
      />
    </Svg>
  );
};</code></pre>

            <h2>Performance Tips</h2>
            <pre><code class="language-javascript">// Use worklets for better performance
const animatedStyle = useAnimatedStyle(() => {
  'worklet'; // This function runs on UI thread
  
  return {
    transform: [
      { translateX: sharedValue.value },
    ],
  };
});

// Run JS functions from worklets
import { runOnJS } from 'react-native-reanimated';

const gesture = Gesture.Pan()
  .onEnd(() => {
    'worklet';
    if (translateX.value > 100) {
      runOnJS(handleSwipeRight)();
    }
  });

// Use cancelAnimation to stop animations
const startAnimation = () => {
  animatedValue.value = withRepeat(
    withTiming(100, { duration: 1000 }),
    -1
  );
};

const stopAnimation = () => {
  cancelAnimation(animatedValue);
};

// Optimize re-renders with React.memo
const AnimatedComponent = React.memo(({ sharedValue }) => {
  const animatedStyle = useAnimatedStyle(() => ({
    opacity: sharedValue.value,
  }));

  return <Animated.View style={animatedStyle} />;
});</code></pre>

            <h2>Layout Animations with Reanimated</h2>
            <pre><code class="language-javascript">import {
  Layout,
  FadeIn,
  FadeOut,
  SlideInRight,
  SlideOutLeft,
  ZoomIn,
  BounceIn,
} from 'react-native-reanimated';

const LayoutAnimationExample = () => {
  const [items, setItems] = useState([1, 2, 3]);

  const addItem = () => {
    setItems([...items, items.length + 1]);
  };

  const removeItem = (id) => {
    setItems(items.filter(item => item !== id));
  };

  return (
    <View style={styles.container}>
      {items.map((item) => (
        <Animated.View
          key={item}
          entering={SlideInRight.duration(300).springify()}
          exiting={SlideOutLeft.duration(300)}
          layout={Layout.springify()}
          style={styles.item}
        >
          <Text>Item {item}</Text>
          <Button title="Remove" onPress={() => removeItem(item)} />
        </Animated.View>
      ))}
      
      <Button title="Add Item" onPress={addItem} />
    </View>
  );
};

// Custom entering/exiting animations
const CustomAnimations = () => {
  const entering = () => {
    'worklet';
    const animations = {
      opacity: withTiming(1, { duration: 300 }),
      transform: [
        { scale: withSpring(1, { from: 0 }) },
        { rotate: withTiming('0deg', { from: '180deg' }) },
      ],
    };
    const initialValues = {
      opacity: 0,
      transform: [{ scale: 0 }, { rotate: '180deg' }],
    };
    return {
      animations,
      initialValues,
    };
  };

  return (
    <Animated.View entering={entering} style={styles.box}>
      <Text>Custom Animation</Text>
    </Animated.View>
  );
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Always use 'worklet' directive for UI thread functions</li>
                    <li>Prefer Reanimated 2 over Animated API for complex animations</li>
                    <li>Use shared values instead of state for animated values</li>
                    <li>Leverage layout animations for list changes</li>
                    <li>Test gesture animations on real devices</li>
                    <li>Use runOnJS sparingly to avoid performance issues</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What does the 'worklet' directive do?",
            options: [
                "Makes the function async",
                "Runs the function on the UI thread",
                "Optimizes memory usage",
                "Enables debugging"
            ],
            correct: 1
        },
        {
            question: "How do you create an animated value in Reanimated 2?",
            options: [
                "new Animated.Value()",
                "useState()",
                "useSharedValue()",
                "createAnimatedValue()"
            ],
            correct: 2
        },
        {
            question: "Which is NOT a Reanimated 2 animation function?",
            options: [
                "withTiming",
                "withSpring",
                "withAnimation",
                "withDelay"
            ],
            correct: 2
        }
    ],
    project: {
        title: "Instagram Stories Clone",
        description: "Build an Instagram Stories-like interface with Reanimated 2",
        requirements: [
            "Progress bar animation for story duration",
            "Swipe gestures to navigate stories",
            "Tap to pause/resume animations",
            "Pinch to zoom on images",
            "Smooth transitions between stories",
            "Reply animation sliding up from bottom",
            "Story preview with scaling animation"
        ],
        hints: [
            "Use gesture handlers for swipe detection",
            "Implement progress with withTiming",
            "Combine multiple gestures with Gesture.Simultaneous",
            "Use interpolation for smooth transitions"
        ]
    }
},
'gesture-handler': {
    content: `
        <div class="content-section">
            <h1>Gesture Animations</h1>
            
            <div class="info-box">
                <p>Learn how to create interactive animations that respond to user gestures. We'll explore PanResponder, React Native Gesture Handler, and how to create smooth, responsive gesture-based animations.</p>
            </div>

            <h2>PanResponder Basics</h2>
            <pre><code class="language-javascript">import React, { useRef } from 'react';
import {
  Animated,
  PanResponder,
  View,
  StyleSheet,
} from 'react-native';

const BasicPanResponder = () => {
  const pan = useRef(new Animated.ValueXY()).current;

  const panResponder = useRef(
    PanResponder.create({
      // Ask to be the responder
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,

      // Touch started
      onPanResponderGrant: () => {
        pan.setOffset({
          x: pan.x._value,
          y: pan.y._value,
        });
        pan.setValue({ x: 0, y: 0 });
      },

      // Touch moving
      onPanResponderMove: Animated.event(
        [null, { dx: pan.x, dy: pan.y }],
        { useNativeDriver: false }
      ),

      // Touch released
      onPanResponderRelease: () => {
        pan.flattenOffset();
        
        // Spring back to center
        Animated.spring(pan, {
          toValue: { x: 0, y: 0 },
          friction: 5,
          useNativeDriver: false,
        }).start();
      },
    })
  ).current;

  return (
    <View style={styles.container}>
      <Animated.View
        style={[
          styles.box,
          {
            transform: [
              { translateX: pan.x },
              { translateY: pan.y },
            ],
          },
        ]}
        {...panResponder.panHandlers}
      />
    </View>
  );
};</code></pre>

            <h2>Swipeable Cards</h2>
            <pre><code class="language-javascript">const SwipeableCard = ({ onSwipeLeft, onSwipeRight, children }) => {
  const position = useRef(new Animated.ValueXY()).current;
  const [index, setIndex] = useState(0);

  const rotate = position.x.interpolate({
    inputRange: [-SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2],
    outputRange: ['-10deg', '0deg', '10deg'],
    extrapolate: 'clamp',
  });

  const rotateAndTranslate = {
    transform: [
      {
        rotate: rotate,
      },
      ...position.getTranslateTransform(),
    ],
  };

  const likeOpacity = position.x.interpolate({
    inputRange: [-SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2],
    outputRange: [0, 0, 1],
    extrapolate: 'clamp',
  });

  const nopeOpacity = position.x.interpolate({
    inputRange: [-SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2],
    outputRange: [1, 0, 0],
    extrapolate: 'clamp',
  });

  const panResponder = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onPanResponderMove: (evt, gestureState) => {
        position.setValue({ x: gestureState.dx, y: gestureState.dy });
      },
      onPanResponderRelease: (evt, gestureState) => {
        if (gestureState.dx > 120) {
          // Swipe right
          Animated.spring(position, {
            toValue: { x: SCREEN_WIDTH + 100, y: gestureState.dy },
            useNativeDriver: false,
          }).start(() => {
            onSwipeRight();
            position.setValue({ x: 0, y: 0 });
          });
        } else if (gestureState.dx < -120) {
          // Swipe left
          Animated.spring(position, {
            toValue: { x: -SCREEN_WIDTH - 100, y: gestureState.dy },
            useNativeDriver: false,
          }).start(() => {
            onSwipeLeft();
            position.setValue({ x: 0, y: 0 });
          });
        } else {
          // Spring back
          Animated.spring(position, {
            toValue: { x: 0, y: 0 },
            friction: 4,
            useNativeDriver: false,
          }).start();
        }
      },
    })
  ).current;

  return (
    <Animated.View
      {...panResponder.panHandlers}
      style={[styles.card, rotateAndTranslate]}
    >
      <Animated.View
        style={[
          styles.likeLabel,
          { opacity: likeOpacity },
        ]}
      >
        <Text style={styles.likeText}>LIKE</Text>
      </Animated.View>

      <Animated.View
        style={[
          styles.nopeLabel,
          { opacity: nopeOpacity },
        ]}
      >
        <Text style={styles.nopeText}>NOPE</Text>
      </Animated.View>

      {children}
    </Animated.View>
  );
};</code></pre>

            <h2>React Native Gesture Handler</h2>
            <pre><code class="language-javascript">import {
  GestureHandlerRootView,
  GestureDetector,
  Gesture,
  PanGestureHandler,
  PinchGestureHandler,
  RotationGestureHandler,
  State,
} from 'react-native-gesture-handler';
import Animated, {
  useAnimatedGestureHandler,
  useSharedValue,
  useAnimatedStyle,
  withSpring,
} from 'react-native-reanimated';

// Modern gesture handling with Reanimated 2
const ModernGestureExample = () => {
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const scale = useSharedValue(1);
  const rotation = useSharedValue(0);

  const panGesture = Gesture.Pan()
    .onStart(() => {
      // Save initial position
    })
    .onUpdate((event) => {
      translateX.value = event.translationX;
      translateY.value = event.translationY;
    })
    .onEnd(() => {
      translateX.value = withSpring(0);
      translateY.value = withSpring(0);
    });

  const pinchGesture = Gesture.Pinch()
    .onUpdate((event) => {
      scale.value = event.scale;
    })
    .onEnd(() => {
      scale.value = withSpring(1);
    });

  const rotationGesture = Gesture.Rotation()
    .onUpdate((event) => {
      rotation.value = event.rotation;
    })
    .onEnd(() => {
      rotation.value = withSpring(0);
    });

  const composed = Gesture.Simultaneous(
    panGesture,
    Gesture.Simultaneous(pinchGesture, rotationGesture)
  );

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { scale: scale.value },
      { rotateZ: \`\${rotation.value}rad\` },
    ],
  }));

  return (
    <GestureHandlerRootView style={styles.container}>
      <GestureDetector gesture={composed}>
        <Animated.View style={[styles.box, animatedStyle]} />
      </GestureDetector>
    </GestureHandlerRootView>
  );
};</code></pre>

            <h2>Pull to Refresh</h2>
            <pre><code class="language-javascript">const PullToRefresh = ({ onRefresh, children }) => {
  const translateY = useSharedValue(0);
  const refreshing = useSharedValue(false);
  const progress = useSharedValue(0);

  const REFRESH_THRESHOLD = 80;

  const panGesture = Gesture.Pan()
    .onUpdate((event) => {
      if (event.translationY > 0 && !refreshing.value) {
        translateY.value = event.translationY * 0.5; // Resistance
        progress.value = Math.min(event.translationY / REFRESH_THRESHOLD, 1);
      }
    })
    .onEnd(() => {
      if (translateY.value > REFRESH_THRESHOLD) {
        // Trigger refresh
        refreshing.value = true;
        translateY.value = withSpring(60);
        runOnJS(handleRefresh)();
      } else {
        // Snap back
        translateY.value = withSpring(0);
        progress.value = withSpring(0);
      }
    });

  const handleRefresh = async () => {
    await onRefresh();
    refreshing.value = false;
    translateY.value = withSpring(0);
    progress.value = withSpring(0);
  };

  const containerStyle = useAnimatedStyle(() => ({
    transform: [{ translateY: translateY.value }],
  }));

  const loaderStyle = useAnimatedStyle(() => ({
    opacity: progress.value,
    transform: [
      { scale: progress.value },
      { rotate: \`\${progress.value * 360}deg\` },
    ],
  }));

  return (
    <GestureDetector gesture={panGesture}>
      <Animated.View style={[styles.container, containerStyle]}>
        <Animated.View style={[styles.refreshLoader, loaderStyle]}>
          <ActivityIndicator color="#0066ff" />
        </Animated.View>
        {children}
      </Animated.View>
    </GestureDetector>
  );
};</code></pre>

            <h2>Drawer Animation</h2>
            <pre><code class="language-javascript">const AnimatedDrawer = ({ children, drawerContent }) => {
  const translateX = useSharedValue(-DRAWER_WIDTH);
  const gestureX = useSharedValue(0);

  const openDrawer = () => {
    translateX.value = withSpring(0);
  };

  const closeDrawer = () => {
    translateX.value = withSpring(-DRAWER_WIDTH);
  };

  const panGesture = Gesture.Pan()
    .onStart(() => {
      gestureX.value = translateX.value;
    })
    .onUpdate((event) => {
      const newValue = gestureX.value + event.translationX;
      translateX.value = Math.max(-DRAWER_WIDTH, Math.min(0, newValue));
    })
    .onEnd((event) => {
      const shouldOpen = 
        translateX.value > -DRAWER_WIDTH / 2 || 
        event.velocityX > 500;
      
      if (shouldOpen) {
        translateX.value = withSpring(0);
      } else {
        translateX.value = withSpring(-DRAWER_WIDTH);
      }
    });

  const drawerStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: translateX.value }],
  }));

  const backdropStyle = useAnimatedStyle(() => ({
    opacity: interpolate(
      translateX.value,
      [-DRAWER_WIDTH, 0],
      [0, 0.5],
      Extrapolate.CLAMP
    ),
    pointerEvents: translateX.value === -DRAWER_WIDTH ? 'none' : 'auto',
  }));

  const contentStyle = useAnimatedStyle(() => ({
    transform: [
      {
        translateX: interpolate(
          translateX.value,
          [-DRAWER_WIDTH, 0],
          [0, DRAWER_WIDTH * 0.3],
          Extrapolate.CLAMP
        ),
      },
    ],
  }));

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.content, contentStyle]}>
        {children}
        <TouchableOpacity onPress={openDrawer} style={styles.menuButton}>
          <Text>☰</Text>
        </TouchableOpacity>
      </Animated.View>

      <GestureDetector gesture={panGesture}>
        <Animated.View style={[styles.drawer, drawerStyle]}>
          {drawerContent}
        </Animated.View>
      </GestureDetector>

      <Animated.View
        style={[styles.backdrop, backdropStyle]}
        onTouchEnd={closeDrawer}
      />
    </View>
  );
};</code></pre>

            <h2>Long Press Animation</h2>
            <pre><code class="language-javascript">const LongPressButton = ({ onLongPress, children }) => {
  const scale = useSharedValue(1);
  const opacity = useSharedValue(0);
  const progress = useSharedValue(0);

  const longPressGesture = Gesture.LongPress()
    .minDuration(800)
    .onBegin(() => {
      scale.value = withSpring(0.95);
      opacity.value = withTiming(1, { duration: 300 });
      progress.value = withTiming(1, { duration: 800 });
    })
    .onFinalize((event, success) => {
      scale.value = withSpring(1);
      opacity.value = withTiming(0);
      progress.value = withTiming(0);
      
      if (success) {
        runOnJS(onLongPress)();
      }
    });

  const tapGesture = Gesture.Tap()
    .onEnd(() => {
      scale.value = withSequence(
        withSpring(0.9),
        withSpring(1)
      );
    });

  const composed = Gesture.Race(longPressGesture, tapGesture);

  const buttonStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  const progressStyle = useAnimatedStyle(() => ({
    width: \`\${progress.value * 100}%\`,
    opacity: opacity.value,
  }));

  return (
    <GestureDetector gesture={composed}>
      <Animated.View style={[styles.button, buttonStyle]}>
        <Animated.View style={[styles.progressBar, progressStyle]} />
        {children}
      </Animated.View>
    </GestureDetector>
  );
};</code></pre>

            <h2>Pinch to Zoom</h2>
            <pre><code class="language-javascript">const PinchToZoom = ({ children }) => {
  const scale = useSharedValue(1);
  const savedScale = useSharedValue(1);
  const focalX = useSharedValue(0);
  const focalY = useSharedValue(0);
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);

  const pinchGesture = Gesture.Pinch()
    .onStart((event) => {
      savedScale.value = scale.value;
      focalX.value = event.focalX;
      focalY.value = event.focalY;
    })
    .onUpdate((event) => {
      scale.value = savedScale.value * event.scale;
      
      // Adjust position based on focal point
      const adjustX = (event.focalX - focalX.value) * (1 - event.scale);
      const adjustY = (event.focalY - focalY.value) * (1 - event.scale);
      
      translateX.value = adjustX;
      translateY.value = adjustY;
    })
    .onEnd(() => {
      // Limit scale
      if (scale.value < 1) {
        scale.value = withSpring(1);
        translateX.value = withSpring(0);
        translateY.value = withSpring(0);
      } else if (scale.value > 3) {
        scale.value = withSpring(3);
      }
    });

  const doubleTap = Gesture.Tap()
    .numberOfTaps(2)
    .onEnd(() => {
      if (scale.value > 1) {
        scale.value = withSpring(1);
        translateX.value = withSpring(0);
        translateY.value = withSpring(0);
      } else {
        scale.value = withSpring(2);
      }
    });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { scale: scale.value },
    ],
  }));

  return (
    <GestureDetector gesture={Gesture.Simultaneous(pinchGesture, doubleTap)}>
      <Animated.View style={[styles.zoomContainer, animatedStyle]}>
        {children}
      </Animated.View>
    </GestureDetector>
  );
};</code></pre>

            <h2>Complex Gesture Combinations</h2>
            <pre><code class="language-javascript">// Photo viewer with pan, pinch, and rotation
const PhotoViewer = ({ source }) => {
  const scale = useSharedValue(1);
  const rotation = useSharedValue(0);
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  
  const savedScale = useSharedValue(1);
  const savedRotation = useSharedValue(0);
  const savedTranslateX = useSharedValue(0);
  const savedTranslateY = useSharedValue(0);

  const panGesture = Gesture.Pan()
    .averageTouches(true)
    .onStart(() => {
      savedTranslateX.value = translateX.value;
      savedTranslateY.value = translateY.value;
    })
    .onUpdate((event) => {
      translateX.value = savedTranslateX.value + event.translationX;
      translateY.value = savedTranslateY.value + event.translationY;
    });

  const pinchGesture = Gesture.Pinch()
    .onStart(() => {
      savedScale.value = scale.value;
    })
    .onUpdate((event) => {
      scale.value = savedScale.value * event.scale;
    });

  const rotationGesture = Gesture.Rotation()
    .onStart(() => {
      savedRotation.value = rotation.value;
    })
    .onUpdate((event) => {
      rotation.value = savedRotation.value + event.rotation;
    });

  const doubleTap = Gesture.Tap()
    .numberOfTaps(2)
    .onEnd(() => {
      scale.value = withSpring(1);
      rotation.value = withSpring(0);
      translateX.value = withSpring(0);
      translateY.value = withSpring(0);
    });

  const singleTap = Gesture.Tap()
    .onEnd(() => {
      runOnJS(toggleControls)();
    });

  const composed = Gesture.Race(
    doubleTap,
    Gesture.Simultaneous(
      singleTap,
      panGesture,
      pinchGesture,
      rotationGesture
    )
  );

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { scale: scale.value },
      { rotateZ: \`\${rotation.value}rad\` },
    ],
  }));

  return (
    <GestureHandlerRootView style={styles.fullScreen}>
      <GestureDetector gesture={composed}>
        <Animated.Image
          source={source}
          style={[styles.image, animatedStyle]}
          resizeMode="contain"
        />
      </GestureDetector>
    </GestureHandlerRootView>
  );
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Use React Native Gesture Handler for better performance</li>
                    <li>Combine gestures with Gesture.Simultaneous or Gesture.Race</li>
                    <li>Always test gestures on real devices</li>
                    <li>Provide visual feedback for gesture states</li>
                    <li>Consider gesture accessibility</li>
                    <li>Handle gesture conflicts carefully</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the main advantage of React Native Gesture Handler over PanResponder?",
            options: [
                "Easier syntax",
                "Better performance with native thread execution",
                "More gesture types",
                "Built-in animations"
            ],
            correct: 1
        },
        {
            question: "How do you combine multiple gestures?",
            options: [
                "Use multiple GestureDetectors",
                "Use Gesture.Simultaneous or Gesture.Race",
                "Not possible",
                "Use setState"
            ],
            correct: 1
        },
        {
            question: "What does 'worklet' mean in gesture handlers?",
            options: [
                "It's a type of gesture",
                "Function runs on UI thread",
                "It's for debugging",
                "It makes gestures faster"
            ],
            correct: 1
        }
    ],
    project: {
        title: "Photo Gallery with Gestures",
        description: "Build a photo gallery app with advanced gesture controls",
        requirements: [
            "Swipe between photos",
            "Pinch to zoom images",
            "Double tap to zoom",
            "Pan zoomed images",
            "Long press to show options",
            "Pull down to close gallery",
            "Rotation gesture support"
        ],
        hints: [
            "Use Gesture Handler for smooth performance",
            "Implement bounds checking for pan",
            "Add spring animations for natural feel",
            "Consider implementing gesture tutorials"
        ]
    }
},
'lottie': {
    content: `
        <div class="content-section">
            <h1>Lottie Animations</h1>
            
            <div class="info-box">
                <p>Lottie is a library that renders After Effects animations in real-time, allowing you to use complex animations as easily as static images. It's perfect for adding professional animations without impacting app performance.</p>
            </div>

            <h2>Installation and Setup</h2>
            <pre><code class="language-bash"># Install Lottie React Native
npm install lottie-react-native

# iOS Setup
cd ios && pod install

# For React Native 0.60+, autolinking handles the rest</code></pre>

            <h2>Basic Lottie Animation</h2>
            <pre><code class="language-javascript">import React, { useRef, useEffect } from 'react';
import LottieView from 'lottie-react-native';
import { View, Button, StyleSheet } from 'react-native';

const BasicLottieAnimation = () => {
  const animationRef = useRef(null);

  useEffect(() => {
    // Auto-play animation
    animationRef.current?.play();
  }, []);

  return (
    <View style={styles.container}>
      <LottieView
        ref={animationRef}
        source={require('./animations/loading.json')}
        style={styles.animation}
        autoPlay
        loop
      />
      
      <View style={styles.controls}>
        <Button 
          title="Play" 
          onPress={() => animationRef.current?.play()} 
        />
        <Button 
          title="Pause" 
          onPress={() => animationRef.current?.pause()} 
        />
        <Button 
          title="Reset" 
          onPress={() => animationRef.current?.reset()} 
        />
      </View>
    </View>
  );
};</code></pre>

            <h2>Advanced Lottie Controls</h2>
            <pre><code class="language-javascript">const AdvancedLottieControls = () => {
  const animationRef = useRef(null);
  const [progress, setProgress] = useState(0);
  const [speed, setSpeed] = useState(1);
  const [isPlaying, setIsPlaying] = useState(false);

  const handleProgressChange = (value) => {
    setProgress(value);
    animationRef.current?.play(value * 100, 100);
  };

  const handleSpeedChange = (value) => {
    setSpeed(value);
    animationRef.current?.play();
  };

  return (
    <View style={styles.container}>
      <LottieView
        ref={animationRef}
        source={require('./animations/success.json')}
        style={styles.animation}
        speed={speed}
        onAnimationFinish={() => setIsPlaying(false)}
        progress={progress}
      />

      <View style={styles.controls}>
        <Text>Progress: {Math.round(progress * 100)}%</Text>
        <Slider
          style={styles.slider}
          minimumValue={0}
          maximumValue={1}
          value={progress}
          onValueChange={handleProgressChange}
        />

        <Text>Speed: {speed}x</Text>
        <Slider
          style={styles.slider}
          minimumValue={0.5}
          maximumValue={3}
          value={speed}
          onValueChange={handleSpeedChange}
        />

        <Button
          title={isPlaying ? 'Pause' : 'Play'}
          onPress={() => {
            if (isPlaying) {
              animationRef.current?.pause();
            } else {
              animationRef.current?.play();
            }
            setIsPlaying(!isPlaying);
          }}
        />

        <Button
          title="Play Segment"
          onPress={() => {
            // Play frames 30 to 60
            animationRef.current?.play(30, 60);
          }}
        />
      </View>
    </View>
  );
};</code></pre>

            <h2>Interactive Lottie Animations</h2>
            <pre><code class="language-javascript">import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  runOnJS,
} from 'react-native-reanimated';

const AnimatedLottieView = Animated.createAnimatedComponent(LottieView);

const InteractiveLottie = () => {
  const progress = useSharedValue(0);
  const [currentFrame, setCurrentFrame] = useState(0);

  const animatedProps = useAnimatedProps(() => ({
    progress: progress.value,
  }));

  // Control animation with pan gesture
  const panGesture = Gesture.Pan()
    .onUpdate((event) => {
      const newProgress = Math.max(0, Math.min(1, 
        progress.value + event.translationX / 300
      ));
      progress.value = newProgress;
      runOnJS(setCurrentFrame)(Math.round(newProgress * 100));
    });

  // Control animation with scroll
  const ScrollControlledLottie = () => {
    const scrollY = useSharedValue(0);

    const scrollHandler = useAnimatedScrollHandler({
      onScroll: (event) => {
        scrollY.value = event.contentOffset.y;
        // Map scroll position to animation progress
        progress.value = Math.min(1, scrollY.value / 500);
      },
    });

    return (
      <>
        <AnimatedLottieView
          source={require('./animations/scroll-animation.json')}
          style={styles.fixedAnimation}
          animatedProps={animatedProps}
        />
        <Animated.ScrollView
          onScroll={scrollHandler}
          scrollEventThrottle={16}
        >
          <View style={{ height: 1000 }}>
            <Text>Scroll to control animation</Text>
          </View>
        </Animated.ScrollView>
      </>
    );
  };

  return (
    <GestureDetector gesture={panGesture}>
      <View style={styles.container}>
        <AnimatedLottieView
          source={require('./animations/slider.json')}
          style={styles.animation}
          animatedProps={animatedProps}
        />
        <Text>Frame: {currentFrame}/100</Text>
        <Text>Swipe horizontally to control</Text>
      </View>
    </GestureDetector>
  );
};</code></pre>

            <h2>Loading States with Lottie</h2>
            <pre><code class="language-javascript">const LoadingScreen = ({ loading, onAnimationFinish }) => {
  const fadeAnim = useRef(new Animated.Value(1)).current;

  useEffect(() => {
    if (!loading) {
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }).start(onAnimationFinish);
    }
  }, [loading]);

  if (!loading && fadeAnim._value === 0) return null;

  return (
    <Animated.View 
      style={[
        styles.loadingContainer,
        { opacity: fadeAnim }
      ]}
    >
      <LottieView
        source={require('./animations/loading-dots.json')}
        autoPlay
        loop
        style={styles.loadingAnimation}
      />
      <Text style={styles.loadingText}>Loading...</Text>
    </Animated.View>
  );
};

// Success/Error animations
const StatusAnimation = ({ type, onComplete }) => {
  const animations = {
    success: require('./animations/success-check.json'),
    error: require('./animations/error-cross.json'),
    warning: require('./animations/warning.json'),
  };

  return (
    <Modal visible={true} transparent animationType="fade">
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          <LottieView
            source={animations[type]}
            autoPlay
            loop={false}
            style={styles.statusAnimation}
            onAnimationFinish={onComplete}
          />
          <Text style={styles.statusText}>
            {type === 'success' && 'Success!'}
            {type === 'error' && 'Error!'}
            {type === 'warning' && 'Warning!'}
          </Text>
        </View>
      </View>
    </Modal>
  );
};</code></pre>

            <h2>Onboarding with Lottie</h2>
            <pre><code class="language-javascript">const OnboardingScreen = ({ navigation }) => {
  const [currentPage, setCurrentPage] = useState(0);
  const animationRefs = useRef([]);

  const pages = [
    {
      animation: require('./animations/welcome.json'),
      title: 'Welcome',
      description: 'Welcome to our amazing app!',
    },
    {
      animation: require('./animations/features.json'),
      title: 'Features',
      description: 'Discover what you can do',
    },
    {
      animation: require('./animations/get-started.json'),
      title: 'Get Started',
      description: 'Let\\'s begin your journey',
    },
  ];

  const handlePageChange = (index) => {
    setCurrentPage(index);
    // Reset and play animation for current page
    animationRefs.current[index]?.reset();
    animationRefs.current[index]?.play();
  };

  return (
    <View style={styles.container}>
      <PagerView
        style={styles.pager}
        initialPage={0}
        onPageSelected={(e) => handlePageChange(e.nativeEvent.position)}
      >
        {pages.map((page, index) => (
          <View key={index} style={styles.page}>
            <LottieView
              ref={(ref) => (animationRefs.current[index] = ref)}
              source={page.animation}
              autoPlay={index === 0}
              loop={false}
              style={styles.onboardingAnimation}
            />
            <Text style={styles.title}>{page.title}</Text>
            <Text style={styles.description}>{page.description}</Text>
          </View>
        ))}
      </PagerView>

      <View style={styles.pagination}>
        {pages.map((_, index) => (
          <View
            key={index}
            style={[
              styles.dot,
              currentPage === index && styles.activeDot,
            ]}
          />
        ))}
      </View>

      {currentPage === pages.length - 1 && (
        <TouchableOpacity
          style={styles.getStartedButton}
          onPress={() => navigation.replace('Home')}
        >
          <Text style={styles.buttonText}>Get Started</Text>
        </TouchableOpacity>
      )}
    </View>
  );
};</code></pre>

            <h2>Button Animations</h2>
            <pre><code class="language-javascript">const AnimatedButton = ({ onPress, children }) => {
  const animationRef = useRef(null);
  const [isLiked, setIsLiked] = useState(false);

  const handlePress = () => {
    if (!isLiked) {
      animationRef.current?.play(0, 60); // Play like animation
    } else {
      animationRef.current?.play(60, 0); // Reverse animation
    }
    setIsLiked(!isLiked);
    onPress?.();
  };

  return (
    <TouchableOpacity onPress={handlePress} style={styles.button}>
      <LottieView
        ref={animationRef}
        source={require('./animations/heart.json')}
        style={styles.buttonAnimation}
        loop={false}
        speed={2}
      />
      <Text style={styles.buttonText}>{children}</Text>
    </TouchableOpacity>
  );
};

// Microinteractions
const MicroInteractionButton = ({ onPress, type = 'submit' }) => {
  const animationRef = useRef(null);

  const animations = {
    submit: require('./animations/submit-button.json'),
    delete: require('./animations/delete-button.json'),
    download: require('./animations/download-button.json'),
  };

  const handlePressIn = () => {
    animationRef.current?.play(0, 30); // Play first half
  };

  const handlePressOut = () => {
    animationRef.current?.play(30, 60); // Play second half
    onPress?.();
  };

  return (
    <TouchableWithoutFeedback
      onPressIn={handlePressIn}
      onPressOut={handlePressOut}
    >
      <View style={styles.microButton}>
        <LottieView
          ref={animationRef}
          source={animations[type]}
          style={styles.microAnimation}
          loop={false}
          progress={0}
        />
      </View>
    </TouchableWithoutFeedback>
  );
};</code></pre>

            <h2>Performance Optimization</h2>
            <pre><code class="language-javascript">// Optimize Lottie animations
const OptimizedLottie = ({ source, ...props }) => {
  const [isVisible, setIsVisible] = useState(true);
  const animationRef = useRef(null);

  // Pause animation when app goes to background
  useEffect(() => {
    const subscription = AppState.addEventListener('change', (state) => {
      if (state === 'background') {
        animationRef.current?.pause();
      } else if (state === 'active') {
        animationRef.current?.resume();
      }
    });

    return () => subscription.remove();
  }, []);

  // Lazy load animations
  const LazyLottie = React.lazy(() => {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve({ default: LottieView });
      }, 100);
    });
  });

  // Clean up on unmount
  useEffect(() => {
    return () => {
      animationRef.current?.reset();
    };
  }, []);

  return (
    <React.Suspense fallback={<ActivityIndicator />}>
      <LottieView
        ref={animationRef}
        source={source}
        {...props}
        // Reduce quality for better performance
        renderMode="SOFTWARE"
        // Cache animation
        cacheComposition={true}
        cacheStrategy="strong"
      />
    </React.Suspense>
  );
};

// Preload animations
const preloadAnimations = async () => {
  const animations = [
    require('./animations/loading.json'),
    require('./animations/success.json'),
    require('./animations/error.json'),
  ];

  // Preload all animations
  await Promise.all(
    animations.map(animation => 
      Image.prefetch(animation)
    )
  );
};</code></pre>

            <h2>Custom Lottie Components</h2>
            <pre><code class="language-javascript">// Rating component with Lottie
const AnimatedRating = ({ rating, onChange }) => {
  const stars = [1, 2, 3, 4, 5];
  const animationRefs = useRef([]);

  const handleStarPress = (index) => {
    const newRating = index + 1;
    onChange(newRating);

    // Animate stars
    stars.forEach((_, i) => {
      if (i < newRating) {
        animationRefs.current[i]?.play();
      } else {
        animationRefs.current[i]?.reset();
      }
    });
  };

  return (
    <View style={styles.ratingContainer}>
      {stars.map((star, index) => (
        <TouchableOpacity
          key={index}
          onPress={() => handleStarPress(index)}
        >
          <LottieView
            ref={(ref) => (animationRefs.current[index] = ref)}
            source={require('./animations/star.json')}
            style={styles.star}
            loop={false}
            progress={index < rating ? 1 : 0}
          />
        </TouchableOpacity>
      ))}
    </View>
  );
};

// Pull to refresh with Lottie
const LottiePullToRefresh = ({ onRefresh, children }) => {
  const [refreshing, setRefreshing] = useState(false);
  const animationRef = useRef(null);

  const handleRefresh = async () => {
    setRefreshing(true);
    animationRef.current?.play();
    
    await onRefresh();
    
    setRefreshing(false);
    animationRef.current?.reset();
  };

  return (
    <ScrollView
      refreshControl={
        <RefreshControl
          refreshing={refreshing}
          onRefresh={handleRefresh}
          tintColor="transparent"
        />
      }
    >
      {refreshing && (
        <View style={styles.lottieRefreshContainer}>
          <LottieView
            ref={animationRef}
            source={require('./animations/pull-to-refresh.json')}
            style={styles.refreshAnimation}
            autoPlay
            loop
          />
        </View>
      )}
      {children}
    </ScrollView>
  );
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Optimize animation files - keep them small</li>
                    <li>Use renderMode="SOFTWARE" for better performance</li>
                    <li>Pause animations when not visible</li>
                    <li>Preload frequently used animations</li>
                    <li>Test on low-end devices</li>
                    <li>Consider using remote URLs for large animations</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What format does Lottie use for animations?",
            options: [
                "GIF files",
                "MP4 videos",
                "JSON files exported from After Effects",
                "SVG animations"
            ],
            correct: 2
        },
        {
            question: "How can you control Lottie animation progress?",
            options: [
                "Only through autoPlay",
                "Using the progress prop or play() method",
                "You can't control it",
                "Only with speed prop"
            ],
            correct: 1
        },
        {
            question: "What's the best way to optimize Lottie performance?",
            options: [
                "Use larger animation files",
                "Always loop animations",
                "Use renderMode='SOFTWARE' and pause when not visible",
                "Disable caching"
            ],
            correct: 2
        }
    ],
    project: {
        title: "Interactive Story App",
        description: "Build a story app with rich Lottie animations",
        requirements: [
            "Animated splash screen",
            "Interactive onboarding flow",
            "Story pages with Lottie illustrations",
            "Gesture-controlled animations",
            "Loading states between pages",
            "Success/error feedback animations",
            "Pull-to-refresh with custom animation"
        ],
        hints: [
            "Use LottieFiles.com for free animations",
            "Implement preloading for smooth transitions",
            "Sync animations with story narration",
            "Add interactive elements to engage users"
        ]
    }
},
'shared-element': {
    content: `
        <div class="content-section">
            <h1>Shared Element Transitions</h1>
            
            <div class="info-box">
                <p>Shared element transitions create seamless animations between screens by animating common elements. This creates a smooth, continuous experience as users navigate through your app.</p>
            </div>

            <h2>React Navigation Shared Element</h2>
            <pre><code class="language-bash"># Installation
npm install react-navigation-shared-element
npm install react-native-shared-element

# iOS setup
cd ios && pod install</code></pre>

            <h2>Basic Setup</h2>
            <pre><code class="language-javascript">import { createSharedElementStackNavigator } from 'react-navigation-shared-element';
import { NavigationContainer } from '@react-navigation/native';
import { SharedElement } from 'react-navigation-shared-element';

const Stack = createSharedElementStackNavigator();

// List screen
const ListScreen = ({ navigation }) => {
  const items = [
    { id: '1', title: 'Item 1', image: require('./img1.jpg') },
    { id: '2', title: 'Item 2', image: require('./img2.jpg') },
  ];

  return (
    <FlatList
      data={items}
      keyExtractor={(item) => item.id}
      renderItem={({ item }) => (
        <TouchableOpacity
          onPress={() => navigation.navigate('Detail', { item })}
          style={styles.listItem}
        >
          <SharedElement id={\`item.\${item.id}.image\`}>
            <Image source={item.image} style={styles.listImage} />
          </SharedElement>
          <SharedElement id={\`item.\${item.id}.title\`}>
            <Text style={styles.listTitle}>{item.title}</Text>
          </SharedElement>
        </TouchableOpacity>
      )}
    />
  );
};

// Detail screen
const DetailScreen = ({ route }) => {
  const { item } = route.params;

  return (
    <View style={styles.container}>
      <SharedElement id={\`item.\${item.id}.image\`}>
        <Image source={item.image} style={styles.detailImage} />
      </SharedElement>
      <SharedElement id={\`item.\${item.id}.title\`}>
        <Text style={styles.detailTitle}>{item.title}</Text>
      </SharedElement>
    </View>
  );
};

// Configure shared elements
DetailScreen.sharedElements = (route) => {
  const { item } = route.params;
  return [
    {
      id: \`item.\${item.id}.image\`,
      animation: 'move',
      resize: 'stretch',
    },
    {
      id: \`item.\${item.id}.title\`,
      animation: 'fade',
    },
  ];
};

// Navigator setup
function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="List" component={ListScreen} />
        <Stack.Screen 
          name="Detail" 
          component={DetailScreen}
          options={{
            cardStyleInterpolator: ({ current }) => ({
              cardStyle: {
                opacity: current.progress,
              },
            }),
          }}
        />
      </Stack.Navigator>
    </NavigationContainer>
  );
}</code></pre>

            <h2>Advanced Shared Element Configurations</h2>
            <pre><code class="language-javascript">// Complex shared element configuration
const PhotoDetailScreen = ({ route, navigation }) => {
  const { photo, photos, currentIndex } = route.params;
  const opacity = useSharedValue(1);

  return (
    <View style={styles.container}>
      {/* Background fade */}
      <SharedElement id="background" style={StyleSheet.absoluteFill}>
        <View style={styles.background} />
      </SharedElement>

      {/* Main image with gestures */}
      <PinchGestureHandler>
        <Animated.View>
          <SharedElement id={\`photo.\${photo.id}\`}>
            <Image source={photo.source} style={styles.fullImage} />
          </SharedElement>
        </Animated.View>
      </PinchGestureHandler>

      {/* UI Elements */}
      <Animated.View style={[styles.header, { opacity }]}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Icon name="close" size={24} color="white" />
        </TouchableOpacity>
      </Animated.View>

      {/* Additional info with stagger animation */}
      <SharedElement id={\`photo.\${photo.id}.info\`}>
        <View style={styles.infoContainer}>
          <Text style={styles.photoTitle}>{photo.title}</Text>
          <Text style={styles.photoDescription}>{photo.description}</Text>
        </View>
      </SharedElement>
    </View>
  );
};

PhotoDetailScreen.sharedElements = (route, otherRoute, showing) => {
  const { photo } = route.params;
  
  // Different animations for showing/hiding
  if (showing) {
    return [
      {
        id: 'background',
        animation: 'fade',
        resize: 'none',
      },
      {
        id: \`photo.\${photo.id}\`,
        animation: 'move',
        resize: 'stretch',
        align: 'center-center',
      },
      {
        id: \`photo.\${photo.id}.info\`,
        animation: 'fade-in',
        resize: 'none',
      },
    ];
  }
  
  return [
    {
      id: \`photo.\${photo.id}\`,
      animation: 'move',
      resize: 'auto',
    },
  ];
};</code></pre>

            <h2>Custom Shared Element Transitions</h2>
            <pre><code class="language-javascript">import SharedElement from 'react-native-shared-element';

// Manual shared element transition
const ManualTransition = () => {
  const [showDetail, setShowDetail] = useState(false);
  const transition = useSharedValue(0);

  const handlePress = () => {
    setShowDetail(true);
    transition.value = withSpring(1);
  };

  const handleClose = () => {
    transition.value = withTiming(0, { duration: 300 }, () => {
      runOnJS(setShowDetail)(false);
    });
  };

  const listStyle = useAnimatedStyle(() => ({
    opacity: interpolate(transition.value, [0, 1], [1, 0]),
    transform: [
      {
        scale: interpolate(transition.value, [0, 1], [1, 0.9]),
      },
    ],
  }));

  const detailStyle = useAnimatedStyle(() => ({
    opacity: transition.value,
  }));

  return (
    <View style={styles.container}>
      {/* List View */}
      <Animated.View style={[styles.listContainer, listStyle]}>
        <TouchableOpacity onPress={handlePress}>
          <SharedElement id="hero-image">
            <Image source={require('./hero.jpg')} style={styles.thumbnail} />
          </SharedElement>
        </TouchableOpacity>
      </Animated.View>

      {/* Detail View */}
      {showDetail && (
        <Animated.View style={[styles.detailContainer, detailStyle]}>
          <SharedElement id="hero-image">
            <Image source={require('./hero.jpg')} style={styles.fullImage} />
          </SharedElement>
          <TouchableOpacity onPress={handleClose} style={styles.closeButton}>
            <Text>Close</Text>
          </TouchableOpacity>
        </Animated.View>
      )}
    </View>
  );
};</code></pre>

            <h2>Gallery with Shared Elements</h2>
            <pre><code class="language-javascript">// Photo gallery with shared element transitions
const PhotoGallery = () => {
  const [selectedId, setSelectedId] = useState(null);
  
  const photos = [
    { id: '1', uri: 'https://...', title: 'Sunset' },
    { id: '2', uri: 'https://...', title: 'Mountain' },
    // ...
  ];

  const renderPhoto = ({ item, index }) => {
    const isSelected = selectedId === item.id;
    
    return (
      <TouchableOpacity
        activeOpacity={0.9}
        onPress={() => setSelectedId(isSelected ? null : item.id)}
        style={[
          styles.photoContainer,
          isSelected && styles.selectedPhoto,
        ]}
      >
        <SharedElement id={\`photo-\${item.id}\`}>
          <Animated.Image
            source={{ uri: item.uri }}
            style={[
              styles.photo,
              isSelected && styles.expandedPhoto,
            ]}
            resizeMode={isSelected ? 'contain' : 'cover'}
          />
        </SharedElement>
        
        {!isSelected && (
          <SharedElement id={\`title-\${item.id}\`}>
            <Text style={styles.photoTitle}>{item.title}</Text>
          </SharedElement>
        )}
      </TouchableOpacity>
    );
  };

  return (
    <FlatList
      data={photos}
      renderItem={renderPhoto}
      keyExtractor={(item) => item.id}
      numColumns={2}
      contentContainerStyle={styles.gallery}
    />
  );
};</code></pre>

            <h2>Hero Animation Pattern</h2>
            <pre><code class="language-javascript">// Hero animation with multiple shared elements
const ProductCard = ({ product, onPress }) => {
  return (
    <TouchableOpacity onPress={onPress} style={styles.card}>
      <SharedElement id={\`product.\${product.id}.image\`}>
        <Image source={{ uri: product.image }} style={styles.cardImage} />
      </SharedElement>
      
      <View style={styles.cardContent}>
        <SharedElement id={\`product.\${product.id}.title\`}>
          <Text style={styles.cardTitle}>{product.title}</Text>
        </SharedElement>
        
        <SharedElement id={\`product.\${product.id}.price\`}>
          <Text style={styles.cardPrice}>\${product.price}</Text>
        </SharedElement>
      </View>
      
      {/* Non-shared elements */}
      <Text style={styles.cardDescription} numberOfLines={2}>
        {product.description}
      </Text>
    </TouchableOpacity>
  );
};

const ProductDetail = ({ route, navigation }) => {
  const { product } = route.params;
  const translateY = useSharedValue(50);
  const opacity = useSharedValue(0);

  useEffect(() => {
    // Animate non-shared elements after transition
    translateY.value = withDelay(300, withSpring(0));
    opacity.value = withDelay(300, withTiming(1));
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateY: translateY.value }],
    opacity: opacity.value,
  }));

  return (
    <ScrollView style={styles.container}>
      <SharedElement id={\`product.\${product.id}.image\`}>
        <Image source={{ uri: product.image }} style={styles.heroImage} />
      </SharedElement>
      
      <View style={styles.content}>
        <View style={styles.header}>
          <SharedElement id={\`product.\${product.id}.title\`}>
            <Text style={styles.title}>{product.title}</Text>
          </SharedElement>
          
          <SharedElement id={\`product.\${product.id}.price\`}>
            <Text style={styles.price}>\${product.price}</Text>
          </SharedElement>
        </View>
        
        <Animated.View style={animatedStyle}>
          <Text style={styles.description}>{product.description}</Text>
          
          <View style={styles.features}>
            {product.features.map((feature, index) => (
              <Animated.View
                key={index}
                entering={FadeIn.delay(400 + index * 100)}
              >
                <Text style={styles.feature}>• {feature}</Text>
              </Animated.View>
            ))}
          </View>
          
          <TouchableOpacity style={styles.buyButton}>
            <Text style={styles.buyButtonText}>Add to Cart</Text>
          </TouchableOpacity>
        </Animated.View>
      </View>
    </ScrollView>
  );
};</code></pre>

            <h2>Shared Element with Tab Navigation</h2>
            <pre><code class="language-javascript">// Shared elements across tab navigation
const TabNavigatorWithSharedElements = () => {
  const [activeTab, setActiveTab] = useState('home');
  const transition = useSharedValue(0);

  const tabs = [
    { id: 'home', icon: 'home', label: 'Home' },
    { id: 'search', icon: 'search', label: 'Search' },
    { id: 'profile', icon: 'person', label: 'Profile' },
  ];

  const handleTabPress = (tabId) => {
    transition.value = withSpring(tabs.findIndex(t => t.id === tabId));
    setActiveTab(tabId);
  };

  const indicatorStyle = useAnimatedStyle(() => ({
    transform: [
      {
        translateX: interpolate(
          transition.value,
          [0, 1, 2],
          [0, SCREEN_WIDTH / 3, (SCREEN_WIDTH / 3) * 2]
        ),
      },
    ],
  }));

  return (
    <View style={styles.container}>
      {/* Content with shared elements */}
      <View style={styles.content}>
        {activeTab === 'home' && <HomeContent />}
        {activeTab === 'search' && <SearchContent />}
        {activeTab === 'profile' && <ProfileContent />}
      </View>

      {/* Custom tab bar with shared element indicator */}
      <View style={styles.tabBar}>
        <Animated.View style={[styles.indicator, indicatorStyle]} />
        
        {tabs.map((tab) => (
          <TouchableOpacity
            key={tab.id}
            onPress={() => handleTabPress(tab.id)}
            style={styles.tab}
          >
            <SharedElement id={\`tab-icon-\${tab.id}\`}>
              <Icon
                name={tab.icon}
                size={24}
                color={activeTab === tab.id ? '#0066ff' : '#666'}
              />
            </SharedElement>
            <Text
              style={[
                styles.tabLabel,
                activeTab === tab.id && styles.activeTabLabel,
              ]}
            >
              {tab.label}
            </Text>
          </TouchableOpacity>
        ))}
      </View>
    </View>
  );
};</code></pre>

            <h2>Performance Optimization</h2>
            <pre><code class="language-javascript">// Optimize shared element transitions
const OptimizedSharedElement = ({ id, children, style }) => {
  const [nodeHandle, setNodeHandle] = useState(null);
  const viewRef = useRef(null);

  useEffect(() => {
    // Register shared element node
    if (viewRef.current) {
      setNodeHandle(findNodeHandle(viewRef.current));
    }
  }, []);

  // Memoize children to prevent unnecessary re-renders
  const memoizedChildren = useMemo(() => children, [children]);

  return (
    <SharedElement id={id} style={style}>
      <View ref={viewRef} collapsable={false}>
        {memoizedChildren}
      </View>
    </SharedElement>
  );
};

// Preload images for smooth transitions
const PreloadedImageGallery = ({ images }) => {
  useEffect(() => {
    // Preload all images
    images.forEach(image => {
      Image.prefetch(image.uri);
    });
  }, [images]);

  return (
    <FlatList
      data={images}
      renderItem={({ item }) => (
        <OptimizedSharedElement id={\`image-\${item.id}\`}>
          <FastImage
            source={{ uri: item.uri }}
            style={styles.galleryImage}
            resizeMode={FastImage.resizeMode.cover}
          />
        </OptimizedSharedElement>
      )}
      keyExtractor={(item) => item.id}
      removeClippedSubviews={true}
      maxToRenderPerBatch={10}
      windowSize={10}
    />
  );
};

// Cleanup shared elements
const CleanupExample = () => {
  useEffect(() => {
    return () => {
      // Cleanup shared element nodes
      SharedElement.cancelAnimation();
    };
  }, []);

  return <View>{/* Component content */}</View>;
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Use unique IDs for shared elements</li>
                    <li>Keep shared element hierarchies simple</li>
                    <li>Preload images for smooth transitions</li>
                    <li>Test on both iOS and Android</li>
                    <li>Handle edge cases like fast navigation</li>
                    <li>Optimize image sizes for performance</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What is required for shared element transitions to work?",
            options: [
                "Same component type only",
                "Matching shared element IDs between screens",
                "Same style properties",
                "Navigation animation"
            ],
            correct: 1
        },
        {
            question: "Which animation types are available for shared elements?",
            options: [
                "move only",
                "fade only",
                "move, fade, fade-in, fade-out",
                "scale only"
            ],
            correct: 2
        },
        {
            question: "How do you configure shared elements for a screen?",
            options: [
                "In the component render",
                "Using sharedElements static property",
                "In navigation options",
                "With useState"
            ],
            correct: 1
        }
    ],
    project: {
        title: "Photo Gallery App",
        description: "Build a photo gallery with smooth shared element transitions",
        requirements: [
            "Grid view of photo thumbnails",
            "Shared element transition to full screen",
            "Pinch to zoom in detail view",
            "Swipe between photos in detail view",
            "Hero animation for photo metadata",
            "Smooth back transition",
            "Loading states with placeholders"
        ],
        hints: [
            "Use unique IDs for each photo",
            "Implement gesture handlers in detail view",
            "Preload adjacent photos",
            "Handle orientation changes"
        ]
    }
},
'animation-practices': {
    content: `
        <div class="content-section">
            <h1>Animation Best Practices</h1>
            
            <div class="info-box">
                <p>Learn the best practices for creating performant, accessible, and delightful animations in React Native. These guidelines will help you build animations that enhance user experience without compromising performance.</p>
            </div>

            <h2>Performance Guidelines</h2>
            <pre><code class="language-javascript">// 1. Always use useNativeDriver when possible
// ✅ Good - runs on UI thread
Animated.timing(animatedValue, {
  toValue: 100,
  duration: 300,
  useNativeDriver: true, // For transform and opacity
}).start();

// ❌ Bad - runs on JS thread
Animated.timing(widthValue, {
  toValue: 200,
  duration: 300,
  useNativeDriver: false, // Required for layout properties
}).start();

// 2. Use transform instead of position properties
// ❌ Bad - animating position
const badStyle = {
  left: animatedValue,
  top: animatedValue,
};

// ✅ Good - animating transform
const goodStyle = {
  transform: [
    { translateX: animatedValue },
    { translateY: animatedValue },
  ],
};

// 3. Optimize image animations
const OptimizedImageAnimation = () => {
  const opacity = useSharedValue(0);

  useEffect(() => {
    // Preload image before animating
    Image.prefetch(imageUrl).then(() => {
      opacity.value = withTiming(1, { duration: 300 });
    });
  }, []);

  return (
    <Animated.Image
      source={{ uri: imageUrl }}
      style={[styles.image, { opacity }]}
      // Reduce quality for animations
      resizeMode="cover"
      fadeDuration={0} // Disable default fade
    />
  );
};</code></pre>

            <h2>Animation Timing and Easing</h2>
            <pre><code class="language-javascript">import { Easing } from 'react-native-reanimated';

// Duration guidelines
const DURATIONS = {
  instant: 100,      // Immediate feedback
  fast: 200,         // Quick interactions
  normal: 300,       // Standard animations
  slow: 500,         // Emphasis animations
  verySlow: 1000,    // Special effects
};

// Common easing functions
const EASINGS = {
  // Standard easings
  easeIn: Easing.bezier(0.42, 0, 1, 1),
  easeOut: Easing.bezier(0, 0, 0.58, 1),
  easeInOut: Easing.bezier(0.42, 0, 0.58, 1),
  
  // Material Design easings
  standard: Easing.bezier(0.4, 0.0, 0.2, 1),
  deceleration: Easing.bezier(0.0, 0.0, 0.2, 1),
  acceleration: Easing.bezier(0.4, 0.0, 1, 1),
  
  // Custom easings
  bounce: Easing.bezier(0.68, -0.55, 0.265, 1.55),
  smooth: Easing.bezier(0.25, 0.1, 0.25, 1),
};

// Usage example
const animateWithProperTiming = () => {
  // Entrance animation
  opacity.value = withTiming(1, {
    duration: DURATIONS.normal,
    easing: EASINGS.deceleration,
  });

  // Exit animation
  opacity.value = withTiming(0, {
    duration: DURATIONS.fast,
    easing: EASINGS.acceleration,
  });

  // Micro-interaction
  scale.value = withSequence(
    withTiming(1.1, {
      duration: DURATIONS.instant,
      easing: EASINGS.easeOut,
    }),
    withSpring(1, {
      damping: 15,
      stiffness: 150,
    })
  );
};</code></pre>

            <h2>Accessibility in Animations</h2>
            <pre><code class="language-javascript">import { AccessibilityInfo } from 'react-native';

// Respect reduced motion preferences
const useReducedMotion = () => {
  const [reduceMotion, setReduceMotion] = useState(false);

  useEffect(() => {
    AccessibilityInfo.isReduceMotionEnabled().then(setReduceMotion);
    
    const subscription = AccessibilityInfo.addEventListener(
      'reduceMotionChanged',
      setReduceMotion
    );

    return () => subscription.remove();
  }, []);

  return reduceMotion;
};

// Accessible animated component
const AccessibleAnimation = ({ children }) => {
  const reduceMotion = useReducedMotion();
  const animatedValue = useRef(new Animated.Value(0)).current;

  const animate = () => {
    if (reduceMotion) {
      // Simple fade for reduced motion
      Animated.timing(animatedValue, {
        toValue: 1,
        duration: 200,
        useNativeDriver: true,
      }).start();
    } else {
      // Full animation
      Animated.spring(animatedValue, {
        toValue: 1,
        friction: 4,
        tension: 40,
        useNativeDriver: true,
      }).start();
    }
  };

  return (
    <Animated.View
      style={{
        opacity: animatedValue,
        transform: [
          {
            scale: reduceMotion
              ? 1
              : animatedValue.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0.8, 1],
                }),
          },
        ],
      }}
      // Accessibility props
      accessible={true}
      accessibilityRole="button"
      accessibilityLabel="Animated content"
      accessibilityHint="Double tap to interact"
    >
      {children}
    </Animated.View>
  );
};

// Skip animations for screen readers
const ScreenReaderAwareAnimation = () => {
  const [screenReaderEnabled, setScreenReaderEnabled] = useState(false);

  useEffect(() => {
    AccessibilityInfo.isScreenReaderEnabled().then(setScreenReaderEnabled);
  }, []);

  if (screenReaderEnabled) {
    // Return static content for screen readers
    return <StaticContent />;
  }

  return <AnimatedContent />;
};</code></pre>

            <h2>Memory Management</h2>
            <pre><code class="language-javascript">// Clean up animations properly
const MemoryEfficientAnimation = () => {
  const animatedValue = useRef(new Animated.Value(0)).current;
  const animationRef = useRef(null);

  useEffect(() => {
    // Start animation
    animationRef.current = Animated.loop(
      Animated.timing(animatedValue, {
        toValue: 1,
        duration: 2000,
        useNativeDriver: true,
      })
    );
    animationRef.current.start();

    // Cleanup
    return () => {
      // Stop animation
      animationRef.current?.stop();
      
      // Remove listeners
      animatedValue.removeAllListeners();
      
      // Reset value
      animatedValue.setValue(0);
    };
  }, []);

  return <Animated.View style={{ opacity: animatedValue }} />;
};

// Reanimated cleanup
const ReanimatedCleanup = () => {
  const progress = useSharedValue(0);
  const isActive = useSharedValue(true);

  useEffect(() => {
    return () => {
      // Cancel animations
      cancelAnimation(progress);
      isActive.value = false;
    };
  }, []);

  const animate = () => {
    'worklet';
    if (isActive.value) {
      progress.value = withRepeat(
        withTiming(1, { duration: 1000 }),
        -1,
        true
      );
    }
  };

  return <View>{/* Component content */}</View>;
};</code></pre>

            <h2>Gesture and Animation Coordination</h2>
            <pre><code class="language-javascript">// Coordinate gestures with animations
const CoordinatedGestureAnimation = () => {
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const scale = useSharedValue(1);
  const gestureActive = useSharedValue(false);

  const gesture = Gesture.Pan()
    .onStart(() => {
      gestureActive.value = true;
      scale.value = withSpring(1.1);
    })
    .onUpdate((event) => {
      translateX.value = event.translationX;
      translateY.value = event.translationY;
    })
    .onEnd(() => {
      gestureActive.value = false;
      
      // Smooth return animation
      translateX.value = withSpring(0, {
        damping: 15,
        stiffness: 100,
      });
      translateY.value = withSpring(0, {
        damping: 15,
        stiffness: 100,
      });
      scale.value = withSpring(1);
    });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { scale: scale.value },
    ],
    // Add shadow during gesture
    shadowOpacity: withTiming(gestureActive.value ? 0.3 : 0.1),
    elevation: withTiming(gestureActive.value ? 8 : 2),
  }));

  return (
    <GestureDetector gesture={gesture}>
      <Animated.View style={[styles.card, animatedStyle]} />
    </GestureDetector>
  );
};</code></pre>

            <h2>State-Driven Animations</h2>
            <pre><code class="language-javascript">// Centralized animation state management
const useAnimationState = () => {
  const [animationState, setAnimationState] = useState('idle');
  const progress = useSharedValue(0);

  const animations = {
    idle: () => {
      progress.value = withTiming(0);
    },
    loading: () => {
      progress.value = withRepeat(
        withSequence(
          withTiming(1, { duration: 1000 }),
          withTiming(0, { duration: 1000 })
        ),
        -1
      );
    },
    success: () => {
      progress.value = withSequence(
        withSpring(1.2),
        withSpring(1)
      );
    },
    error: () => {
      progress.value = withSequence(
        withTiming(1, { duration: 100 }),
        withRepeat(
          withSequence(
            withTiming(1.1, { duration: 50 }),
            withTiming(0.9, { duration: 50 })
          ),
          3,
          true
        )
      );
    },
  };

  useEffect(() => {
    animations[animationState]?.();
  }, [animationState]);

  return {
    animationState,
    setAnimationState,
    progress,
  };
};

// Usage
const AnimatedButton = () => {
  const { animationState, setAnimationState, progress } = useAnimationState();

  const animatedStyle = useAnimatedStyle(() => ({
    opacity: interpolate(
      progress.value,
      [0, 1],
      [0.6, 1]
    ),
    transform: [
      {
        scale: interpolate(
          progress.value,
          [0, 0.5, 1],
          [1, 1.2, 1]
        ),
      },
    ],
  }));

  const handlePress = async () => {
    setAnimationState('loading');
    
    try {
      await performAction();
      setAnimationState('success');
    } catch (error) {
      setAnimationState('error');
    } finally {
      setTimeout(() => setAnimationState('idle'), 2000);
    }
  };

  return (
    <Animated.View style={animatedStyle}>
      <TouchableOpacity onPress={handlePress}>
        <Text>{getButtonText(animationState)}</Text>
      </TouchableOpacity>
    </Animated.View>
  );
};</code></pre>

            <h2>Testing Animations</h2>
            <pre><code class="language-javascript">// Mock animations for testing
jest.mock('react-native-reanimated', () => {
  const Reanimated = require('react-native-reanimated/mock');

  // Mock additional functions
  Reanimated.default.call = () => {};
  Reanimated.default.block = () => {};
  Reanimated.default.Value = jest.fn(() => ({ value: 0 }));

  return Reanimated;
});

// Test animation behavior
describe('AnimatedComponent', () => {
  it('should animate on mount', () => {
    const { getByTestId } = render(<AnimatedComponent />);
    const element = getByTestId('animated-view');
    
    // Check initial state
    expect(element.props.style.opacity).toBe(0);
    
    // Fast-forward animations
    act(() => {
      jest.advanceTimersByTime(1000);
    });
    
    // Check final state
    expect(element.props.style.opacity).toBe(1);
  });

  it('should respect reduced motion', () => {
    // Mock reduced motion
    AccessibilityInfo.isReduceMotionEnabled = jest.fn(() => 
      Promise.resolve(true)
    );
    
    const { getByTestId } = render(<AccessibleAnimation />);
    
    // Verify simplified animation is used
    expect(getByTestId('animation').props.duration).toBe(200);
  });
});</code></pre>

            <h2>Common Animation Patterns</h2>
            <pre><code class="language-javascript">// Stagger animations for lists
const StaggeredList = ({ data }) => {
  const STAGGER_DELAY = 50;

  return (
    <View>
      {data.map((item, index) => (
        <Animated.View
          key={item.id}
          entering={FadeInDown.delay(index * STAGGER_DELAY)
            .duration(300)
            .springify()}
          exiting={FadeOutUp}
        >
          <ListItem item={item} />
        </Animated.View>
      ))}
    </View>
  );
};

// Skeleton loading animation
const SkeletonLoader = () => {
  const shimmer = useSharedValue(0);

  useEffect(() => {
    shimmer.value = withRepeat(
      withTiming(1, { duration: 1500 }),
      -1,
      false
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    backgroundColor: interpolateColor(
      shimmer.value,
      [0, 0.5, 1],
      ['#E0E0E0', '#F5F5F5', '#E0E0E0']
    ),
  }));

  return (
    <View style={styles.skeleton}>
      <Animated.View style={[styles.skeletonLine, animatedStyle]} />
      <Animated.View style={[styles.skeletonLine, animatedStyle, { width: '80%' }]} />
      <Animated.View style={[styles.skeletonLine, animatedStyle, { width: '60%' }]} />
    </View>
  );
};

// Parallax scrolling
const ParallaxScroll = ({ children, headerImage }) => {
  const scrollY = useSharedValue(0);

  const headerStyle = useAnimatedStyle(() => ({
    transform: [
      {
        translateY: interpolate(
          scrollY.value,
          [-200, 0, 200],
          [-100, 0, 100 * 0.5],
          Extrapolate.CLAMP
        ),
      },
      {
        scale: interpolate(
          scrollY.value,
          [-200, 0],
          [1.5, 1],
          Extrapolate.CLAMP
        ),
      },
    ],
  }));

  const scrollHandler = useAnimatedScrollHandler({
    onScroll: (event) => {
      scrollY.value = event.contentOffset.y;
    },
  });

  return (
    <View style={styles.container}>
      <Animated.Image
        source={headerImage}
        style={[styles.headerImage, headerStyle]}
      />
      <Animated.ScrollView
        onScroll={scrollHandler}
        scrollEventThrottle={16}
      >
        <View style={styles.scrollContent}>
          {children}
        </View>
      </Animated.ScrollView>
    </View>
  );
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices Summary</h3>
                <ul>
                    <li>Always prioritize performance - use native driver</li>
                    <li>Respect accessibility settings and user preferences</li>
                    <li>Keep animations meaningful and not distracting</li>
                    <li>Test on low-end devices and slow networks</li>
                    <li>Clean up animations to prevent memory leaks</li>
                    <li>Use appropriate timing and easing functions</li>
                    <li>Coordinate animations with gestures smoothly</li>
                    <li>Implement loading and error states properly</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the most important performance tip for animations?",
            options: [
                "Use more keyframes",
                "Always use useNativeDriver when possible",
                "Make animations longer",
                "Use setState for all animations"
            ],
            correct: 1
        },
        {
            question: "How should you handle reduced motion preferences?",
            options: [
                "Ignore them",
                "Disable all animations",
                "Provide simpler alternative animations",
                "Show a warning"
            ],
            correct: 2
        },
        {
            question: "What's the recommended duration for standard animations?",
            options: [
                "100ms",
                "300ms",
                "1000ms",
                "2000ms"
            ],
            correct: 1
        }
    ],
    project: {
        title: "Animated Dashboard",
        description: "Build a data dashboard with performant, accessible animations",
        requirements: [
            "Animated charts and graphs",
            "Skeleton loading states",
            "Gesture-controlled data exploration",
            "Respect accessibility settings",
            "Smooth transitions between views",
            "Error and success animations",
            "Performance monitoring",
            "Staggered list animations"
        ],
        hints: [
            "Use Reanimated 2 for complex animations",
            "Implement proper loading states",
            "Test with accessibility settings enabled",
            "Monitor frame rates during animations"
        ]
    }
},
'fetch-api': {
    content: `
        <div class="content-section">
            <h1>API Integration</h1>
            
            <div class="info-box">
                <p>Learn how to integrate REST APIs, GraphQL, and WebSockets in React Native applications. Master data fetching, error handling, and state management for API calls.</p>
            </div>

            <h2>Fetch API Basics</h2>
            <pre><code class="language-javascript">// Basic fetch example
const fetchData = async () => {
  try {
    const response = await fetch('https://api.example.com/data');
    
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Fetch error:', error);
    throw error;
  }
};

// With headers and options
const fetchWithAuth = async (token) => {
  const response = await fetch('https://api.example.com/user', {
    method: 'GET',
    headers: {
      'Authorization': \`Bearer \${token}\`,
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    },
    // Additional options
    mode: 'cors',
    cache: 'no-cache',
    credentials: 'include',
  });
  
  return response.json();
};</code></pre>

            <h2>API Service Layer</h2>
            <pre><code class="language-javascript">// api/client.js
class ApiClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.token = null;
  }

  setAuthToken(token) {
    this.token = token;
  }

  async request(endpoint, options = {}) {
    const url = \`\${this.baseURL}\${endpoint}\`;
    
    const config = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
    };

    if (this.token) {
      config.headers.Authorization = \`Bearer \${this.token}\`;
    }

    const response = await fetch(url, config);
    
    if (response.status === 401) {
      // Handle token refresh
      await this.refreshToken();
      // Retry request
      return this.request(endpoint, options);
    }

    if (!response.ok) {
      throw new ApiError(response.status, await response.text());
    }

    return response.json();
  }

  async get(endpoint, params = {}) {
    const queryString = new URLSearchParams(params).toString();
    const url = queryString ? \`\${endpoint}?\${queryString}\` : endpoint;
    
    return this.request(url, { method: 'GET' });
  }

  async post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async put(endpoint, data) {
    return this.request(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  async delete(endpoint) {
    return this.request(endpoint, { method: 'DELETE' });
  }

  async upload(endpoint, formData) {
    return this.request(endpoint, {
      method: 'POST',
      headers: {
        // Don't set Content-Type, let browser set it with boundary
      },
      body: formData,
    });
  }
}

// Custom error class
class ApiError extends Error {
  constructor(status, message) {
    super(message);
    this.status = status;
    this.name = 'ApiError';
  }
}

// Export configured instance
export default new ApiClient('https://api.example.com');</code></pre>

            <h2>React Query Integration</h2>
            <pre><code class="language-javascript">// Install: npm install @tanstack/react-query

import {
  QueryClient,
  QueryClientProvider,
  useQuery,
  useMutation,
  useQueryClient,
} from '@tanstack/react-query';

// Configure query client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 3,
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
    },
  },
});

// App wrapper
function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <NavigationContainer>
        {/* Your app */}
      </NavigationContainer>
    </QueryClientProvider>
  );
}

// Custom hooks for API calls
const useUsers = (filters) => {
  return useQuery({
    queryKey: ['users', filters],
    queryFn: () => apiClient.get('/users', filters),
    select: (data) => data.users, // Transform response
  });
};

const useUser = (userId) => {
  return useQuery({
    queryKey: ['user', userId],
    queryFn: () => apiClient.get(\`/users/\${userId}\`),
    enabled: !!userId, // Only fetch if userId exists
  });
};

const useCreateUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (userData) => apiClient.post('/users', userData),
    onSuccess: (data) => {
      // Invalidate and refetch users list
      queryClient.invalidateQueries({ queryKey: ['users'] });
      // Add new user to cache
      queryClient.setQueryData(['user', data.id], data);
    },
    onError: (error) => {
      console.error('Failed to create user:', error);
    },
  });
};

// Usage in components
const UserList = () => {
  const { data: users, isLoading, error, refetch } = useUsers({
    page: 1,
    limit: 20,
  });

  if (isLoading) return <ActivityIndicator />;
  if (error) return <ErrorView error={error} onRetry={refetch} />;

  return (
    <FlatList
      data={users}
      renderItem={({ item }) => <UserItem user={item} />}
      onRefresh={refetch}
      refreshing={isLoading}
    />
  );
};</code></pre>

            <h2>Axios Configuration</h2>
            <pre><code class="language-javascript">// Install: npm install axios

import axios from 'axios';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Create axios instance
const axiosInstance = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor
axiosInstance.interceptors.request.use(
  async (config) => {
    // Add auth token to requests
    const token = await AsyncStorage.getItem('authToken');
    if (token) {
      config.headers.Authorization = \`Bearer \${token}\`;
    }
    
    // Log request in development
    if (__DEV__) {
      console.log('Request:', config.method.toUpperCase(), config.url);
    }
    
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor
axiosInstance.interceptors.response.use(
  (response) => {
    // Log response in development
    if (__DEV__) {
      console.log('Response:', response.status, response.config.url);
    }
    
    return response.data;
  },
  async (error) => {
    const originalRequest = error.config;
    
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        const refreshToken = await AsyncStorage.getItem('refreshToken');
        const response = await axios.post('/auth/refresh', {
          refreshToken,
        });
        
        const { accessToken } = response.data;
        await AsyncStorage.setItem('authToken', accessToken);
        
        // Retry original request
        originalRequest.headers.Authorization = \`Bearer \${accessToken}\`;
        return axiosInstance(originalRequest);
      } catch (refreshError) {
        // Redirect to login
        NavigationService.navigate('Login');
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

// API methods
export const api = {
  // Auth
  login: (credentials) => 
    axiosInstance.post('/auth/login', credentials),
  
  logout: () => 
    axiosInstance.post('/auth/logout'),
  
  // Users
  getUsers: (params) => 
    axiosInstance.get('/users', { params }),
  
  getUser: (id) => 
    axiosInstance.get(\`/users/\${id}\`),
  
  createUser: (data) => 
    axiosInstance.post('/users', data),
  
  updateUser: (id, data) => 
    axiosInstance.put(\`/users/\${id}\`, data),
  
  deleteUser: (id) => 
    axiosInstance.delete(\`/users/\${id}\`),
  
  // Upload
  uploadFile: (file) => {
    const formData = new FormData();
    formData.append('file', {
      uri: file.uri,
      type: file.type,
      name: file.name,
    });
    
    return axiosInstance.post('/upload', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
  },
};</code></pre>

            <h2>GraphQL with Apollo Client</h2>
            <pre><code class="language-javascript">// Install: npm install @apollo/client graphql

import {
  ApolloClient,
  InMemoryCache,
  ApolloProvider,
  useQuery,
  useMutation,
  gql,
} from '@apollo/client';

// Configure Apollo Client
const client = new ApolloClient({
  uri: 'https://api.example.com/graphql',
  cache: new InMemoryCache(),
  headers: {
    authorization: AsyncStorage.getItem('authToken') || '',
  },
});

// GraphQL queries
const GET_USERS = gql\`
  query GetUsers($limit: Int!, $offset: Int!) {
    users(limit: $limit, offset: $offset) {
      id
      name
      email
      avatar
      posts {
        id
        title
      }
    }
  }
\`;

const GET_USER = gql\`
  query GetUser($id: ID!) {
    user(id: $id) {
      id
      name
      email
      avatar
      posts {
        id
        title
        content
        createdAt
      }
    }
  }
\`;

// GraphQL mutations
const CREATE_USER = gql\`
  mutation CreateUser($input: CreateUserInput!) {
    createUser(input: $input) {
      id
      name
      email
    }
  }
\`;

// Usage in components
const UserList = () => {
  const { loading, error, data, refetch } = useQuery(GET_USERS, {
    variables: { limit: 20, offset: 0 },
    fetchPolicy: 'cache-and-network',
  });

  if (loading) return <LoadingView />;
  if (error) return <ErrorView error={error} />;

  return (
    <FlatList
      data={data.users}
      renderItem={({ item }) => <UserItem user={item} />}
      onRefresh={refetch}
      refreshing={loading}
    />
  );
};

const CreateUser = () => {
  const [createUser, { loading, error }] = useMutation(CREATE_USER, {
    update(cache, { data: { createUser } }) {
      // Update cache after mutation
      const existingUsers = cache.readQuery({
        query: GET_USERS,
        variables: { limit: 20, offset: 0 },
      });

      cache.writeQuery({
        query: GET_USERS,
        variables: { limit: 20, offset: 0 },
        data: {
          users: [...existingUsers.users, createUser],
        },
      });
    },
  });

  const handleSubmit = (userData) => {
    createUser({
      variables: { input: userData },
    });
  };

  return <UserForm onSubmit={handleSubmit} loading={loading} />;
};</code></pre>

            <h2>WebSocket Connections</h2>
            <pre><code class="language-javascript">// WebSocket service
class WebSocketService {
  constructor(url) {
    this.url = url;
    this.ws = null;
    this.listeners = new Map();
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectInterval = 1000;
  }

  connect(token) {
    this.ws = new WebSocket(\`\${this.url}?token=\${token}\`);

    this.ws.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
      this.emit('connected');
    };

    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.emit(data.type, data.payload);
      } catch (error) {
        console.error('WebSocket message parse error:', error);
      }
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      this.emit('error', error);
    };

    this.ws.onclose = () => {
      console.log('WebSocket disconnected');
      this.emit('disconnected');
      this.reconnect();
    };
  }

  reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      setTimeout(() => {
        console.log(\`Reconnecting... Attempt \${this.reconnectAttempts}\`);
        this.connect();
      }, this.reconnectInterval * this.reconnectAttempts);
    }
  }

  send(type, payload) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ type, payload }));
    } else {
      console.warn('WebSocket is not connected');
    }
  }

  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }

  off(event, callback) {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }

  emit(event, data) {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      callbacks.forEach(callback => callback(data));
    }
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}

// Usage hook
const useWebSocket = () => {
  const [isConnected, setIsConnected] = useState(false);
  const wsRef = useRef(null);

  useEffect(() => {
    const ws = new WebSocketService('wss://api.example.com/ws');
    wsRef.current = ws;

    ws.on('connected', () => setIsConnected(true));
    ws.on('disconnected', () => setIsConnected(false));

    // Connect with auth token
    AsyncStorage.getItem('authToken').then(token => {
      ws.connect(token);
    });

    return () => {
      ws.disconnect();
    };
  }, []);

  return {
    isConnected,
    send: (type, payload) => wsRef.current?.send(type, payload),
    on: (event, callback) => wsRef.current?.on(event, callback),
    off: (event, callback) => wsRef.current?.off(event, callback),
  };
};</code></pre>

            <h2>Error Handling and Retry Logic</h2>
            <pre><code class="language-javascript">// Retry wrapper with exponential backoff
const retryWithBackoff = async (
  fn,
  maxRetries = 3,
  delay = 1000
) => {
  let lastError;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      
      if (i < maxRetries - 1) {
        await new Promise(resolve => 
          setTimeout(resolve, delay * Math.pow(2, i))
        );
      }
    }
  }
  
  throw lastError;
};

// Usage
const fetchDataWithRetry = () => {
  return retryWithBackoff(
    () => api.getData(),
    3,
    1000
  );
};

// Global error handler
class ErrorHandler {
  static handle(error, context = '') {
    console.error(\`Error in \${context}:\`, error);

    if (error.response) {
      // Server error
      switch (error.response.status) {
        case 400:
          Alert.alert('Bad Request', error.response.data.message);
          break;
        case 401:
          // Handle unauthorized
          NavigationService.navigate('Login');
          break;
        case 403:
          Alert.alert('Forbidden', 'You don\\'t have permission');
          break;
        case 404:
          Alert.alert('Not Found', 'Resource not found');
          break;
        case 500:
          Alert.alert('Server Error', 'Please try again later');
          break;
        default:
          Alert.alert('Error', 'Something went wrong');
      }
    } else if (error.request) {
      // Network error
      Alert.alert('Network Error', 'Please check your connection');
    } else {
      // Other errors
      Alert.alert('Error', error.message);
    }
  }
}</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Always handle loading, error, and success states</li>
                    <li>Implement proper error handling and user feedback</li>
                    <li>Use interceptors for common functionality</li>
                    <li>Cache API responses when appropriate</li>
                    <li>Implement retry logic with exponential backoff</li>
                    <li>Use TypeScript for better type safety</li>
                    <li>Test API calls with mock data</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the main advantage of using React Query?",
            options: [
                "Faster API calls",
                "Automatic caching and background refetching",
                "Better security",
                "Smaller bundle size"
            ],
            correct: 1
        },
        {
            question: "When should you use WebSockets instead of REST?",
            options: [
                "For all API calls",
                "Only for authentication",
                "For real-time bidirectional communication",
                "Never"
            ],
            correct: 2
        },
        {
            question: "What does an axios interceptor do?",
            options: [
                "Blocks API calls",
                "Intercepts and modifies requests/responses",
                "Speeds up requests",
                "Handles WebSocket connections"
            ],
            correct: 1
        }
    ],
    project: {
        title: "Real-time Chat Application",
        description: "Build a chat app with REST API for messages and WebSocket for real-time updates",
        requirements: [
            "User authentication with JWT",
            "Fetch chat history with pagination",
            "Real-time message updates via WebSocket",
            "Image upload support",
            "Offline message queue",
            "Push notifications for new messages",
            "Error handling and retry logic",
            "Message status indicators"
        ],
        hints: [
            "Use React Query for message history",
            "Implement WebSocket reconnection logic",
            "Cache messages locally",
            "Handle network state changes"
        ]
    }
},
'async-storage': {
    content: `
        <div class="content-section">
            <h1>AsyncStorage & MMKV</h1>
            
            <div class="info-box">
                <p>Learn about local storage solutions in React Native. AsyncStorage provides a simple key-value storage system, while MMKV offers a high-performance alternative with encryption support.</p>
            </div>

            <h2>AsyncStorage Basics</h2>
            <pre><code class="language-javascript">import AsyncStorage from '@react-native-async-storage/async-storage';

// Store data
const storeData = async (key, value) => {
  try {
    // For objects, stringify first
    const jsonValue = JSON.stringify(value);
    await AsyncStorage.setItem(key, jsonValue);
  } catch (error) {
    console.error('Error storing data:', error);
  }
};

// Retrieve data
const getData = async (key) => {
  try {
    const jsonValue = await AsyncStorage.getItem(key);
    return jsonValue != null ? JSON.parse(jsonValue) : null;
  } catch (error) {
    console.error('Error retrieving data:', error);
    return null;
  }
};

// Remove data
const removeData = async (key) => {
  try {
    await AsyncStorage.removeItem(key);
  } catch (error) {
    console.error('Error removing data:', error);
  }
};

// Clear all data
const clearAll = async () => {
  try {
    await AsyncStorage.clear();
  } catch (error) {
    console.error('Error clearing storage:', error);
  }
};

// Get all keys
const getAllKeys = async () => {
  try {
    return await AsyncStorage.getAllKeys();
  } catch (error) {
    console.error('Error getting keys:', error);
    return [];
  }
};</code></pre>

            <h2>AsyncStorage Service Layer</h2>
            <pre><code class="language-javascript">// services/StorageService.js
class StorageService {
  // User preferences
  static async saveUserPreferences(preferences) {
    try {
      await AsyncStorage.setItem(
        '@user_preferences',
        JSON.stringify(preferences)
      );
      return true;
    } catch (error) {
      console.error('Save preferences error:', error);
      return false;
    }
  }

  static async getUserPreferences() {
    try {
      const value = await AsyncStorage.getItem('@user_preferences');
      return value ? JSON.parse(value) : null;
    } catch (error) {
      console.error('Get preferences error:', error);
      return null;
    }
  }

  // Auth token management
  static async saveAuthToken(token) {
    try {
      await AsyncStorage.setItem('@auth_token', token);
      return true;
    } catch (error) {
      console.error('Save token error:', error);
      return false;
    }
  }

  static async getAuthToken() {
    try {
      return await AsyncStorage.getItem('@auth_token');
    } catch (error) {
      console.error('Get token error:', error);
      return null;
    }
  }

  static async removeAuthToken() {
    try {
      await AsyncStorage.removeItem('@auth_token');
      return true;
    } catch (error) {
      console.error('Remove token error:', error);
      return false;
    }
  }

  // Cache management
  static async saveToCache(key, data, expiryMinutes = 60) {
    try {
      const item = {
        data,
        timestamp: new Date().getTime(),
        expiry: expiryMinutes * 60 * 1000,
      };
      await AsyncStorage.setItem(
        \`@cache_\${key}\`,
        JSON.stringify(item)
      );
      return true;
    } catch (error) {
      console.error('Cache save error:', error);
      return false;
    }
  }

  static async getFromCache(key) {
    try {
      const value = await AsyncStorage.getItem(\`@cache_\${key}\`);
      if (!value) return null;

      const item = JSON.parse(value);
      const now = new Date().getTime();

      if (now - item.timestamp > item.expiry) {
        // Cache expired
        await AsyncStorage.removeItem(\`@cache_\${key}\`);
        return null;
      }

      return item.data;
    } catch (error) {
      console.error('Cache get error:', error);
      return null;
    }
  }

  // Batch operations
  static async multiSet(keyValuePairs) {
    try {
      const pairs = keyValuePairs.map(([key, value]) => [
        key,
        JSON.stringify(value),
      ]);
      await AsyncStorage.multiSet(pairs);
      return true;
    } catch (error) {
      console.error('Multi set error:', error);
      return false;
    }
  }

  static async multiGet(keys) {
    try {
      const values = await AsyncStorage.multiGet(keys);
      return values.map(([key, value]) => ({
        key,
        value: value ? JSON.parse(value) : null,
      }));
    } catch (error) {
      console.error('Multi get error:', error);
      return [];
    }
  }

  // Storage info
  static async getStorageInfo() {
    try {
      const keys = await AsyncStorage.getAllKeys();
      const values = await AsyncStorage.multiGet(keys);
      
      let totalSize = 0;
      const items = values.map(([key, value]) => {
        const size = value ? value.length : 0;
        totalSize += size;
        return { key, size };
      });

      return {
        itemCount: keys.length,
        totalSize,
        items: items.sort((a, b) => b.size - a.size),
      };
    } catch (error) {
      console.error('Storage info error:', error);
      return null;
    }
  }
}

export default StorageService;</code></pre>

            <h2>Custom Hooks for AsyncStorage</h2>
            <pre><code class="language-javascript">// hooks/useAsyncStorage.js
import { useState, useEffect, useCallback } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

export const useAsyncStorage = (key, initialValue) => {
  const [storedValue, setStoredValue] = useState(initialValue);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Load value on mount
  useEffect(() => {
    loadValue();
  }, [key]);

  const loadValue = async () => {
    try {
      setLoading(true);
      const value = await AsyncStorage.getItem(key);
      if (value !== null) {
        setStoredValue(JSON.parse(value));
      }
    } catch (err) {
      setError(err);
      console.error('Load error:', err);
    } finally {
      setLoading(false);
    }
  };

  const setValue = useCallback(async (value) => {
    try {
      setError(null);
      const valueToStore = value instanceof Function 
        ? value(storedValue) 
        : value;
      
      setStoredValue(valueToStore);
      await AsyncStorage.setItem(key, JSON.stringify(valueToStore));
      return true;
    } catch (err) {
      setError(err);
      console.error('Save error:', err);
      return false;
    }
  }, [key, storedValue]);

  const removeValue = useCallback(async () => {
    try {
      setError(null);
      setStoredValue(initialValue);
      await AsyncStorage.removeItem(key);
      return true;
    } catch (err) {
      setError(err);
      console.error('Remove error:', err);
      return false;
    }
  }, [key, initialValue]);

  return {
    value: storedValue,
    setValue,
    removeValue,
    loading,
    error,
    refresh: loadValue,
  };
};

// Usage example
const SettingsScreen = () => {
  const {
    value: settings,
    setValue: saveSettings,
    loading,
  } = useAsyncStorage('@user_settings', {
    theme: 'light',
    notifications: true,
    language: 'en',
  });

  if (loading) return <LoadingView />;

  const toggleTheme = () => {
    saveSettings({
      ...settings,
      theme: settings.theme === 'light' ? 'dark' : 'light',
    });
  };

  return (
    <View>
      <Switch
        value={settings.theme === 'dark'}
        onValueChange={toggleTheme}
      />
      <Text>Current theme: {settings.theme}</Text>
    </View>
  );
};</code></pre>

            <h2>MMKV Installation and Setup</h2>
            <pre><code class="language-bash"># Install MMKV
npm install react-native-mmkv

# iOS
cd ios && pod install

# MMKV is much faster than AsyncStorage
# Benchmarks: ~30x faster for read/write operations</code></pre>

            <h2>MMKV Basic Usage</h2>
            <pre><code class="language-javascript">import { MMKV } from 'react-native-mmkv';

// Create MMKV instance
const storage = new MMKV();

// Or with encryption
const encryptedStorage = new MMKV({
  id: 'encrypted-storage',
  encryptionKey: 'your-encryption-key',
});

// Store values
storage.set('username', 'john_doe');
storage.set('age', 25);
storage.set('isLoggedIn', true);
storage.set('user', JSON.stringify({ id: 1, name: 'John' }));

// Get values
const username = storage.getString('username');
const age = storage.getNumber('age');
const isLoggedIn = storage.getBoolean('isLoggedIn');
const user = JSON.parse(storage.getString('user') || '{}');

// Check if key exists
if (storage.contains('username')) {
  console.log('Username exists');
}

// Delete value
storage.delete('username');

// Get all keys
const keys = storage.getAllKeys();

// Clear all
storage.clearAll();

// Listeners
const listener = storage.addOnValueChangedListener((key) => {
  console.log(\`Value changed for key: \${key}\`);
});

// Remove listener
listener.remove();</code></pre>

            <h2>MMKV Service Layer</h2>
            <pre><code class="language-javascript">// services/MMKVService.js
import { MMKV } from 'react-native-mmkv';

class MMKVService {
  constructor() {
    // Default storage
    this.storage = new MMKV();
    
    // Encrypted storage for sensitive data
    this.secureStorage = new MMKV({
      id: 'secure-storage',
      encryptionKey: 'your-secure-key',
    });
    
    // Cache storage with different ID
    this.cacheStorage = new MMKV({
      id: 'cache-storage',
    });
  }

  // User preferences
  setUserPreferences(preferences) {
    this.storage.set('user_preferences', JSON.stringify(preferences));
  }

  getUserPreferences() {
    const data = this.storage.getString('user_preferences');
    return data ? JSON.parse(data) : null;
  }

  // Secure token storage
  setAuthToken(token) {
    this.secureStorage.set('auth_token', token);
  }

  getAuthToken() {
    return this.secureStorage.getString('auth_token');
  }

  clearAuthData() {
    this.secureStorage.delete('auth_token');
    this.secureStorage.delete('refresh_token');
  }

  // Cache with expiry
  setCacheItem(key, data, expiryMinutes = 60) {
    const item = {
      data,
      expiry: Date.now() + (expiryMinutes * 60 * 1000),
    };
    this.cacheStorage.set(key, JSON.stringify(item));
  }

  getCacheItem(key) {
    const itemStr = this.cacheStorage.getString(key);
    if (!itemStr) return null;

    const item = JSON.parse(itemStr);
    if (Date.now() > item.expiry) {
      this.cacheStorage.delete(key);
      return null;
    }

    return item.data;
  }

  // Batch operations
  batchSet(items) {
    items.forEach(({ key, value }) => {
      this.storage.set(key, JSON.stringify(value));
    });
  }

  // Migration from AsyncStorage
  async migrateFromAsyncStorage() {
    try {
      const keys = await AsyncStorage.getAllKeys();
      const values = await AsyncStorage.multiGet(keys);

      values.forEach(([key, value]) => {
        if (value) {
          this.storage.set(key, value);
        }
      });

      // Clear AsyncStorage after migration
      await AsyncStorage.clear();
      
      return true;
    } catch (error) {
      console.error('Migration error:', error);
      return false;
    }
  }

  // Storage statistics
  getStorageStats() {
    const keys = this.storage.getAllKeys();
    const secureKeys = this.secureStorage.getAllKeys();
    const cacheKeys = this.cacheStorage.getAllKeys();

    return {
      totalKeys: keys.length + secureKeys.length + cacheKeys.length,
      storageKeys: keys.length,
      secureKeys: secureKeys.length,
      cacheKeys: cacheKeys.length,
    };
  }
}

export default new MMKVService();</code></pre>

            <h2>MMKV Hooks</h2>
            <pre><code class="language-javascript">// hooks/useMMKV.js
import { useState, useEffect, useCallback } from 'react';
import { MMKV } from 'react-native-mmkv';

const storage = new MMKV();

export const useMMKV = (key, initialValue) => {
  const [value, setValue] = useState(() => {
    const storedValue = storage.getString(key);
    return storedValue ? JSON.parse(storedValue) : initialValue;
  });

  const setStoredValue = useCallback((newValue) => {
    try {
      const valueToStore = newValue instanceof Function 
        ? newValue(value) 
        : newValue;
      
      setValue(valueToStore);
      storage.set(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error('MMKV set error:', error);
    }
  }, [key, value]);

  const removeValue = useCallback(() => {
    setValue(initialValue);
    storage.delete(key);
  }, [key, initialValue]);

  // Listen for changes
  useEffect(() => {
    const listener = storage.addOnValueChangedListener((changedKey) => {
      if (changedKey === key) {
        const newValue = storage.getString(key);
        setValue(newValue ? JSON.parse(newValue) : initialValue);
      }
    });

    return () => listener.remove();
  }, [key, initialValue]);

  return [value, setStoredValue, removeValue];
};

// Usage
const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useMMKV('app_theme', 'light');

  const toggleTheme = () => {
    setTheme(current => current === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};</code></pre>

            <h2>Performance Comparison</h2>
            <pre><code class="language-javascript">// Performance benchmark
const runBenchmark = async () => {
  const testData = { 
    id: 1, 
    data: 'x'.repeat(1000), 
    timestamp: Date.now() 
  };
  
  console.log('Starting benchmark...');

  // AsyncStorage benchmark
  const asyncStart = Date.now();
  for (let i = 0; i < 100; i++) {
    await AsyncStorage.setItem(\`test_\${i}\`, JSON.stringify(testData));
  }
  for (let i = 0; i < 100; i++) {
    await AsyncStorage.getItem(\`test_\${i}\`);
  }
  const asyncTime = Date.now() - asyncStart;
  console.log(\`AsyncStorage: \${asyncTime}ms\`);

  // MMKV benchmark
  const mmkvStorage = new MMKV({ id: 'benchmark' });
  const mmkvStart = Date.now();
  for (let i = 0; i < 100; i++) {
    mmkvStorage.set(\`test_\${i}\`, JSON.stringify(testData));
  }
  for (let i = 0; i < 100; i++) {
    mmkvStorage.getString(\`test_\${i}\`);
  }
  const mmkvTime = Date.now() - mmkvStart;
  console.log(\`MMKV: \${mmkvTime}ms\`);

  console.log(\`MMKV is \${(asyncTime / mmkvTime).toFixed(2)}x faster\`);

  // Cleanup
  await AsyncStorage.clear();
  mmkvStorage.clearAll();
};</code></pre>

            <h2>Data Sync and Backup</h2>
            <pre><code class="language-javascript">// Sync local storage with cloud
class StorageSync {
  static async backupToCloud() {
    try {
      // Get all local data
      const keys = storage.getAllKeys();
      const data = {};
      
      keys.forEach(key => {
        const value = storage.getString(key);
        if (value) {
          data[key] = value;
        }
      });

      // Upload to cloud
      const response = await api.post('/backup', {
        data,
        timestamp: Date.now(),
        device: DeviceInfo.getUniqueId(),
      });

      return response.success;
    } catch (error) {
      console.error('Backup error:', error);
      return false;
    }
  }

  static async restoreFromCloud() {
    try {
      const response = await api.get('/backup/latest');
      const { data } = response;

      // Restore to local storage
      Object.entries(data).forEach(([key, value]) => {
        storage.set(key, value);
      });

      return true;
    } catch (error) {
      console.error('Restore error:', error);
      return false;
    }
  }

  static async syncData() {
    const lastSync = storage.getNumber('last_sync') || 0;
    const now = Date.now();

    // Get changed items since last sync
    const changes = this.getChangedItems(lastSync);

    if (changes.length > 0) {
      try {
        await api.post('/sync', { changes });
        storage.set('last_sync', now);
      } catch (error) {
        console.error('Sync error:', error);
      }
    }
  }
}</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Use MMKV for performance-critical storage needs</li>
                    <li>Encrypt sensitive data like tokens and passwords</li>
                    <li>Implement data migration strategies</li>
                    <li>Set up proper error handling for storage operations</li>
                    <li>Clean up expired cache regularly</li>
                    <li>Monitor storage size and implement limits</li>
                    <li>Backup important data to cloud storage</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the main advantage of MMKV over AsyncStorage?",
            options: [
                "Better API design",
                "Much faster read/write performance",
                "Smaller storage size",
                "Cross-platform compatibility"
            ],
            correct: 1
        },
        {
            question: "How should you store sensitive data locally?",
            options: [
                "Plain text in AsyncStorage",
                "In app memory only",
                "Using MMKV with encryption",
                "Don't store sensitive data"
            ],
            correct: 2
        },
        {
            question: "What's the best practice for cache expiration?",
            options: [
                "Never expire cache",
                "Clear all cache daily",
                "Store timestamp and check on retrieval",
                "Use device storage limits"
            ],
            correct: 2
        }
    ],
    project: {
        title: "Offline-First Note Taking App",
        description: "Build a note-taking app with robust offline storage and sync",
        requirements: [
            "Store notes locally with MMKV",
            "Implement search in local notes",
            "Sync with cloud when online",
            "Handle conflicts in sync",
            "Encrypt sensitive notes",
            "Export/import functionality",
            "Storage usage statistics",
            "Data migration from AsyncStorage"
        ],
        hints: [
            "Use MMKV for performance",
            "Implement queue for offline changes",
            "Use timestamps for conflict resolution",
            "Show sync status to users"
        ]
    }
},
'database-solutions': {
    content: `
        <div class="content-section">
            <h1>Database Solutions</h1>
            
            <div class="info-box">
                <p>Explore database options for React Native including SQLite, Realm, and WatermelonDB. Learn when to use each solution and how to implement complex data relationships and queries.</p>
            </div>

            <h2>SQLite Setup</h2>
            <pre><code class="language-bash"># Install SQLite
npm install react-native-sqlite-storage

# iOS
cd ios && pod install

# For TypeScript support
npm install --save-dev @types/react-native-sqlite-storage</code></pre>

            <h2>SQLite Basic Usage</h2>
            <pre><code class="language-javascript">import SQLite from 'react-native-sqlite-storage';

// Enable debugging
SQLite.DEBUG(true);
SQLite.enablePromise(true);

// Database configuration
const database_name = "MyApp.db";
const database_version = "1.0";
const database_displayname = "My Application Database";
const database_size = 200000;

// Open database
const openDatabase = async () => {
  try {
    const db = await SQLite.openDatabase(
      database_name,
      database_version,
      database_displayname,
      database_size
    );
    console.log('Database opened');
    return db;
  } catch (error) {
    console.error('Open database error', error);
    throw error;
  }
};

// Create tables
const createTables = async (db) => {
  const createUserTable = \`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      password TEXT NOT NULL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );
  \`;

  const createPostTable = \`
    CREATE TABLE IF NOT EXISTS posts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id INTEGER NOT NULL,
      title TEXT NOT NULL,
      content TEXT,
      status TEXT DEFAULT 'draft',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
    );
  \`;

  const createIndexes = \`
    CREATE INDEX IF NOT EXISTS idx_posts_user_id ON posts(user_id);
    CREATE INDEX IF NOT EXISTS idx_posts_status ON posts(status);
    CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
  \`;

  try {
    await db.transaction(async (tx) => {
      await tx.executeSql(createUserTable);
      await tx.executeSql(createPostTable);
      
      // Create indexes
      const indexes = createIndexes.split(';').filter(sql => sql.trim());
      for (const index of indexes) {
        await tx.executeSql(index);
      }
    });
    console.log('Tables created successfully');
  } catch (error) {
    console.error('Create tables error:', error);
    throw error;
  }
};</code></pre>

            <h2>SQLite CRUD Operations</h2>
            <pre><code class="language-javascript">class DatabaseService {
  constructor() {
    this.db = null;
  }

  async init() {
    this.db = await openDatabase();
    await createTables(this.db);
  }

  // Create
  async createUser(name, email, password) {
    const query = \`
      INSERT INTO users (name, email, password)
      VALUES (?, ?, ?);
    \`;

    try {
      const [result] = await this.db.executeSql(query, [name, email, password]);
      return {
        id: result.insertId,
        name,
        email,
      };
    } catch (error) {
      console.error('Create user error:', error);
      throw error;
    }
  }

  // Read
  async getUsers(limit = 50, offset = 0) {
    const query = \`
      SELECT id, name, email, created_at, updated_at
      FROM users
      ORDER BY created_at DESC
      LIMIT ? OFFSET ?;
    \`;

    try {
      const [result] = await this.db.executeSql(query, [limit, offset]);
      const users = [];
      
      for (let i = 0; i < result.rows.length; i++) {
        users.push(result.rows.item(i));
      }
      
      return users;
    } catch (error) {
      console.error('Get users error:', error);
      throw error;
    }
  }

  async getUserById(id) {
    const query = \`
      SELECT id, name, email, created_at, updated_at
      FROM users
      WHERE id = ?;
    \`;

    try {
      const [result] = await this.db.executeSql(query, [id]);
      if (result.rows.length > 0) {
        return result.rows.item(0);
      }
      return null;
    } catch (error) {
      console.error('Get user by id error:', error);
      throw error;
    }
  }

  // Update
  async updateUser(id, updates) {
    const fields = Object.keys(updates);
    const values = Object.values(updates);
    
    const setClause = fields.map(field => \`\${field} = ?\`).join(', ');
    const query = \`
      UPDATE users
      SET \${setClause}, updated_at = CURRENT_TIMESTAMP
      WHERE id = ?;
    \`;

    try {
      const [result] = await this.db.executeSql(query, [...values, id]);
      return result.rowsAffected > 0;
    } catch (error) {
      console.error('Update user error:', error);
      throw error;
    }
  }

  // Delete
  async deleteUser(id) {
    const query = 'DELETE FROM users WHERE id = ?;';

    try {
      const [result] = await this.db.executeSql(query, [id]);
      return result.rowsAffected > 0;
    } catch (error) {
      console.error('Delete user error:', error);
      throw error;
    }
  }

  // Complex queries
  async getUsersWithPosts() {
    const query = \`
      SELECT 
        u.id as user_id,
        u.name,
        u.email,
        COUNT(p.id) as post_count,
        MAX(p.created_at) as last_post_date
      FROM users u
      LEFT JOIN posts p ON u.id = p.user_id
      GROUP BY u.id
      ORDER BY post_count DESC;
    \`;

    try {
      const [result] = await this.db.executeSql(query);
      const users = [];
      
      for (let i = 0; i < result.rows.length; i++) {
        users.push(result.rows.item(i));
      }
      
      return users;
    } catch (error) {
      console.error('Get users with posts error:', error);
      throw error;
    }
  }

  // Transactions
  async createUserWithPosts(userData, posts) {
    try {
      await this.db.transaction(async (tx) => {
        // Insert user
        const userResult = await tx.executeSql(
          'INSERT INTO users (name, email, password) VALUES (?, ?, ?);',
          [userData.name, userData.email, userData.password]
        );
        
        const userId = userResult[0].insertId;

        // Insert posts
        for (const post of posts) {
          await tx.executeSql(
            'INSERT INTO posts (user_id, title, content) VALUES (?, ?, ?);',
            [userId, post.title, post.content]
          );
        }
      });
      
      console.log('User with posts created successfully');
      return true;
    } catch (error) {
      console.error('Transaction error:', error);
      throw error;
    }
  }

  // Full-text search
  async searchUsers(searchTerm) {
    const query = \`
      SELECT id, name, email
      FROM users
      WHERE name LIKE ? OR email LIKE ?
      ORDER BY 
        CASE 
          WHEN name LIKE ? THEN 1
          WHEN email LIKE ? THEN 2
          ELSE 3
        END;
    \`;

    const searchPattern = \`%\${searchTerm}%\`;
    
    try {
      const [result] = await this.db.executeSql(
        query, 
        [searchPattern, searchPattern, searchTerm + '%', searchTerm + '%']
      );
      
      const users = [];
      for (let i = 0; i < result.rows.length; i++) {
        users.push(result.rows.item(i));
      }
      
      return users;
    } catch (error) {
      console.error('Search users error:', error);
      throw error;
    }
  }
}</code></pre>

            <h2>Realm Database</h2>
            <pre><code class="language-bash"># Install Realm
npm install realm

# iOS
cd ios && pod install</code></pre>

            <pre><code class="language-javascript">import Realm from 'realm';

// Define schemas
const UserSchema = {
  name: 'User',
  primaryKey: 'id',
  properties: {
    id: 'string',
    name: 'string',
    email: 'string',
    age: { type: 'int', optional: true },
    isActive: { type: 'bool', default: true },
    createdAt: { type: 'date', default: new Date() },
    posts: { type: 'linkingObjects', objectType: 'Post', property: 'author' },
  },
};

const PostSchema = {
  name: 'Post',
  primaryKey: 'id',
  properties: {
    id: 'string',
    title: 'string',
    content: 'string',
    author: 'User',
    tags: 'string[]',
    likes: { type: 'int', default: 0 },
    createdAt: { type: 'date', default: new Date() },
    updatedAt: 'date',
  },
};

// Open Realm
const realm = await Realm.open({
  schema: [UserSchema, PostSchema],
  schemaVersion: 1,
  migration: (oldRealm, newRealm) => {
    // Handle schema migrations
    if (oldRealm.schemaVersion < 1) {
      // Migration logic
    }
  },
});

// CRUD Operations with Realm
class RealmService {
  // Create
  createUser(userData) {
    try {
      realm.write(() => {
        realm.create('User', {
          id: Realm.BSON.ObjectId().toHexString(),
          ...userData,
        });
      });
    } catch (error) {
      console.error('Create user error:', error);
    }
  }

  // Read
  getUsers() {
    return realm.objects('User').sorted('createdAt', true);
  }

  getUserById(id) {
    return realm.objectForPrimaryKey('User', id);
  }

  // Update
  updateUser(id, updates) {
    try {
      realm.write(() => {
        const user = realm.objectForPrimaryKey('User', id);
        if (user) {
          Object.assign(user, updates);
        }
      });
    } catch (error) {
      console.error('Update user error:', error);
    }
  }

  // Delete
  deleteUser(id) {
    try {
      realm.write(() => {
        const user = realm.objectForPrimaryKey('User', id);
        if (user) {
          // Delete associated posts
          realm.delete(user.posts);
          // Delete user
          realm.delete(user);
        }
      });
    } catch (error) {
      console.error('Delete user error:', error);
    }
  }

  // Complex queries
  searchUsers(query) {
    return realm.objects('User')
      .filtered('name CONTAINS[c] $0 OR email CONTAINS[c] $0', query)
      .sorted('name');
  }

  getActiveUsersWithPosts() {
    return realm.objects('User')
      .filtered('isActive = true AND posts.@count > 0')
      .sorted('posts.@count', true);
  }

  // Listeners
  addUserListener(callback) {
    const users = realm.objects('User');
    users.addListener(callback);
    
    return () => users.removeListener(callback);
  }
}</code></pre>

            <h2>WatermelonDB</h2>
            <pre><code class="language-bash"># Install WatermelonDB
npm install @nozbe/watermelondb

# Install dependencies
npm install @nozbe/sqlite react-native-localize

# iOS
cd ios && pod install</code></pre>

            <pre><code class="language-javascript">import { Database } from '@nozbe/watermelondb';
import SQLiteAdapter from '@nozbe/watermelondb/adapters/sqlite';
import { 
  schemaMigrations,
  createTable,
  addColumns
} from '@nozbe/watermelondb/Schema/migrations';

// Schema
import { appSchema, tableSchema } from '@nozbe/watermelondb';

const schema = appSchema({
  version: 1,
  tables: [
    tableSchema({
      name: 'users',
      columns: [
        { name: 'name', type: 'string' },
        { name: 'email', type: 'string', isIndexed: true },
        { name: 'is_active', type: 'boolean' },
        { name: 'created_at', type: 'number' },
        { name: 'updated_at', type: 'number' },
      ],
    }),
    tableSchema({
      name: 'posts',
      columns: [
        { name: 'title', type: 'string' },
        { name: 'content', type: 'string' },
        { name: 'user_id', type: 'string', isIndexed: true },
        { name: 'is_published', type: 'boolean' },
        { name: 'created_at', type: 'number' },
        { name: 'updated_at', type: 'number' },
      ],
    }),
  ],
});

// Models
import { Model } from '@nozbe/watermelondb';
import { field, date, relation } from '@nozbe/watermelondb/decorators';

class User extends Model {
  static table = 'users';
  static associations = {
    posts: { type: 'has_many', foreignKey: 'user_id' },
  };

  @field('name') name;
  @field('email') email;
  @field('is_active') isActive;
  @date('created_at') createdAt;
  @date('updated_at') updatedAt;
  
  @relation('posts', 'user_id') posts;
}

class Post extends Model {
  static table = 'posts';
  static associations = {
    user: { type: 'belongs_to', key: 'user_id' },
  };

  @field('title') title;
  @field('content') content;
  @field('user_id') userId;
  @field('is_published') isPublished;
  @date('created_at') createdAt;
  @date('updated_at') updatedAt;
  
  @relation('users', 'user_id') user;
}

// Database setup
const adapter = new SQLiteAdapter({
  schema,
  dbName: 'myapp',
  migrations: schemaMigrations({
    migrations: [
      // Migration definitions
    ],
  }),
});

const database = new Database({
  adapter,
  modelClasses: [User, Post],
});

// Usage
class WatermelonService {
  async createUser(userData) {
    const usersCollection = database.collections.get('users');
    
    await database.write(async () => {
      await usersCollection.create(user => {
        user.name = userData.name;
        user.email = userData.email;
        user.isActive = true;
      });
    });
  }

  async getUsers() {
    const usersCollection = database.collections.get('users');
    return await usersCollection.query().fetch();
  }

  async getUserWithPosts(userId) {
    const usersCollection = database.collections.get('users');
    const user = await usersCollection.find(userId);
    const posts = await user.posts.fetch();
    
    return { user, posts };
  }

  observeUsers() {
    const usersCollection = database.collections.get('users');
    return usersCollection
      .query()
      .observe()
      .subscribe(users => {
        console.log('Users updated:', users.length);
      });
  }
}</code></pre>

            <h2>Database Comparison</h2>
            <pre><code class="language-javascript">/*
SQLite:
- Pros: Mature, SQL support, small size, good performance
- Cons: Manual schema management, verbose API
- Use when: Need SQL queries, existing SQL knowledge

Realm:
- Pros: Easy API, automatic sync, reactive queries
- Cons: Larger size, learning curve for query syntax
- Use when: Need real-time sync, complex object graphs

WatermelonDB:
- Pros: Built for React Native, lazy loading, excellent performance
- Cons: Newer, smaller community
- Use when: Building large-scale apps with complex data

Comparison:
- Performance: WatermelonDB > SQLite > Realm
- Ease of use: Realm > WatermelonDB > SQLite
- Features: Realm > WatermelonDB > SQLite
- Bundle size: SQLite < WatermelonDB < Realm
*/</code></pre>

            <h2>Database Migration Example</h2>
            <pre><code class="language-javascript">// SQLite migrations
const migrations = [
  {
    version: 1,
    sql: \`
      CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL
      );
    \`,
  },
  {
    version: 2,
    sql: \`
      ALTER TABLE users ADD COLUMN avatar TEXT;
      ALTER TABLE users ADD COLUMN bio TEXT;
    \`,
  },
];

const runMigrations = async (db) => {
  const getCurrentVersion = async () => {
    try {
      const [result] = await db.executeSql(
        'SELECT version FROM schema_version ORDER BY version DESC LIMIT 1;'
      );
      return result.rows.length > 0 ? result.rows.item(0).version : 0;
    } catch {
      // Create version table if it doesn't exist
      await db.executeSql(
        'CREATE TABLE IF NOT EXISTS schema_version (version INTEGER PRIMARY KEY);'
      );
      return 0;
    }
  };

  const currentVersion = await getCurrentVersion();

  for (const migration of migrations) {
    if (migration.version > currentVersion) {
      await db.transaction(async (tx) => {
        await tx.executeSql(migration.sql);
        await tx.executeSql(
          'INSERT INTO schema_version (version) VALUES (?);',
          [migration.version]
        );
      });
      console.log(\`Migration \${migration.version} completed\`);
    }
  }
};</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Choose the right database for your use case</li>
                    <li>Always handle migrations properly</li>
                    <li>Use indexes for frequently queried columns</li>
                    <li>Implement proper error handling</li>
                    <li>Use transactions for related operations</li>
                    <li>Consider data sync and backup strategies</li>
                    <li>Monitor database size and performance</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "Which database is best for large-scale React Native apps?",
            options: [
                "AsyncStorage",
                "SQLite",
                "WatermelonDB",
                "JSON files"
            ],
            correct: 2
        },
        {
            question: "What's the main advantage of Realm?",
            options: [
                "Smallest bundle size",
                "SQL support",
                "Automatic sync and reactive queries",
                "Fastest performance"
            ],
            correct: 2
        },
        {
            question: "When should you use database transactions?",
            options: [
                "For single insert operations",
                "For related operations that should succeed or fail together",
                "Only for delete operations",
                "Never"
            ],
            correct: 1
        }
    ],
    project: {
        title: "Task Management App with Sync",
        description: "Build a task management app with offline database and cloud sync",
        requirements: [
            "User authentication system",
            "Tasks with categories and tags",
            "Offline task creation/editing",
            "Sync with cloud when online",
            "Search and filter tasks",
            "Data export functionality",
            "Handle sync conflicts",
            "Performance monitoring"
        ],
        hints: [
            "Use WatermelonDB for performance",
            "Implement queue for offline changes",
            "Use timestamps for conflict resolution",
            "Show sync status to users"
        ]
    }
},
'state-management-libraries': {
    content: `
        <div class="content-section">
            <h1>State Management Libraries</h1>
            
            <div class="info-box">
                <p>While we covered Redux, Zustand, and MobX in the State & Hooks section, here we'll explore how to integrate these state management solutions with data fetching, caching, and persistence strategies.</p>
            </div>

            <h2>Redux Toolkit Query (RTK Query)</h2>
            <pre><code class="language-javascript">// store/api/apiSlice.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { RootState } from '../store';

// Define API slice with advanced features
export const apiSlice = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({
    baseUrl: 'https://api.example.com',
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).auth.token;
      if (token) {
        headers.set('authorization', \`Bearer \${token}\`);
      }
      return headers;
    },
  }),
  tagTypes: ['User', 'Post', 'Comment'],
  endpoints: (builder) => ({
    // Query with pagination
    getUsers: builder.query({
      query: ({ page = 1, limit = 10, filter }) => ({
        url: '/users',
        params: { page, limit, ...filter },
      }),
      providesTags: (result) =>
        result
          ? [
              ...result.users.map(({ id }) => ({ type: 'User', id })),
              { type: 'User', id: 'LIST' },
            ]
          : [{ type: 'User', id: 'LIST' }],
      transformResponse: (response) => response.data,
      keepUnusedDataFor: 300, // Cache for 5 minutes
    }),

    // Query with relationships
    getUserWithPosts: builder.query({
      query: (userId) => \`/users/\${userId}?include=posts\`,
      providesTags: (result, error, id) => [
        { type: 'User', id },
        { type: 'Post', id: 'LIST' },
      ],
    }),

    // Optimistic updates
    updateUser: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: \`/users/\${id}\`,
        method: 'PATCH',
        body: patch,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'User', id }],
      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {
        // Optimistic update
        const patchResult = dispatch(
          apiSlice.util.updateQueryData('getUser', id, (draft) => {
            Object.assign(draft, patch);
          })
        );
        try {
          await queryFulfilled;
        } catch {
          patchResult.undo();
        }
      },
    }),

    // Infinite scroll
    getInfinitePosts: builder.query({
      query: ({ cursor, limit = 20 }) => ({
        url: '/posts',
        params: { cursor, limit },
      }),
      serializeQueryArgs: ({ endpointName }) => {
        return endpointName;
      },
      merge: (currentCache, newItems) => {
        currentCache.posts.push(...newItems.posts);
        currentCache.nextCursor = newItems.nextCursor;
      },
      forceRefetch({ currentArg, previousArg }) {
        return currentArg?.cursor !== previousArg?.cursor;
      },
    }),

    // Streaming updates
    getMessages: builder.query({
      query: (roomId) => \`/rooms/\${roomId}/messages\`,
      async onCacheEntryAdded(
        arg,
        { updateCachedData, cacheDataLoaded, cacheEntryRemoved }
      ) {
        // Create WebSocket connection
        const ws = new WebSocket(\`wss://api.example.com/rooms/\${arg}\`);

        try {
          await cacheDataLoaded;

          ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            updateCachedData((draft) => {
              draft.messages.push(message);
            });
          };
        } catch {
          // Handle error
        }

        await cacheEntryRemoved;
        ws.close();
      },
    }),
  }),
});

// Export hooks
export const {
  useGetUsersQuery,
  useGetUserWithPostsQuery,
  useUpdateUserMutation,
  useGetInfinitePostsQuery,
  useGetMessagesQuery,
} = apiSlice;

// Prefetch example
export const prefetchUser = (userId) => {
  const dispatch = useAppDispatch();
  dispatch(apiSlice.util.prefetch('getUser', userId));
};</code></pre>

            <h2>Zustand with Persistence</h2>
            <pre><code class="language-javascript">// stores/useDataStore.js
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';

const useDataStore = create(
  persist(
    immer((set, get) => ({
      // State
      users: [],
      posts: [],
      offlineQueue: [],
      syncStatus: 'idle', // idle | syncing | error
      lastSyncTime: null,

      // Actions
      setUsers: (users) => set((state) => {
        state.users = users;
      }),

      addPost: (post) => set((state) => {
        state.posts.push(post);
      }),

      // Offline queue management
      addToOfflineQueue: (action) => set((state) => {
        state.offlineQueue.push({
          id: Date.now(),
          action,
          timestamp: new Date().toISOString(),
          retries: 0,
        });
      }),

      removeFromOfflineQueue: (id) => set((state) => {
        state.offlineQueue = state.offlineQueue.filter(
          item => item.id !== id
        );
      }),

      // Sync logic
      syncData: async () => {
        const state = get();
        if (state.syncStatus === 'syncing') return;

        set((state) => {
          state.syncStatus = 'syncing';
        });

        try {
          const networkState = await NetInfo.fetch();
          if (!networkState.isConnected) {
            throw new Error('No internet connection');
          }

          // Process offline queue
          const queue = [...state.offlineQueue];
          for (const item of queue) {
            try {
              await processQueueItem(item);
              get().removeFromOfflineQueue(item.id);
            } catch (error) {
              if (item.retries < 3) {
                set((state) => {
                  const queueItem = state.offlineQueue.find(
                    q => q.id === item.id
                  );
                  if (queueItem) {
                    queueItem.retries += 1;
                  }
                });
              } else {
                // Max retries reached, remove from queue
                get().removeFromOfflineQueue(item.id);
              }
            }
          }

          // Fetch latest data
          const [users, posts] = await Promise.all([
            api.getUsers(),
            api.getPosts(),
          ]);

          set((state) => {
            state.users = users;
            state.posts = posts;
            state.syncStatus = 'idle';
            state.lastSyncTime = new Date().toISOString();
          });
        } catch (error) {
          set((state) => {
            state.syncStatus = 'error';
          });
        }
      },

      // Selectors
      getActiveUsers: () => {
        return get().users.filter(user => user.isActive);
      },

      getUserPosts: (userId) => {
        return get().posts.filter(post => post.userId === userId);
      },

      // Subscription
      subscribe: () => {
        // Listen for network changes
        const unsubscribe = NetInfo.addEventListener(state => {
          if (state.isConnected && get().offlineQueue.length > 0) {
            get().syncData();
          }
        });

        // Periodic sync
        const interval = setInterval(() => {
          get().syncData();
        }, 5 * 60 * 1000); // Every 5 minutes

        return () => {
          unsubscribe();
          clearInterval(interval);
        };
      },
    })),
    {
      name: 'data-storage',
      storage: createJSONStorage(() => AsyncStorage),
      partialize: (state) => ({
        users: state.users,
        posts: state.posts,
        offlineQueue: state.offlineQueue,
        lastSyncTime: state.lastSyncTime,
      }),
    }
  )
);

// Helper function
async function processQueueItem(item) {
  switch (item.action.type) {
    case 'CREATE_POST':
      return api.createPost(item.action.payload);
    case 'UPDATE_USER':
      return api.updateUser(item.action.payload.id, item.action.payload.data);
    case 'DELETE_POST':
      return api.deletePost(item.action.payload.id);
    default:
      throw new Error(\`Unknown action type: \${item.action.type}\`);
  }
}

export default useDataStore;</code></pre>

            <h2>MobX with MST (MobX State Tree)</h2>
            <pre><code class="language-javascript">// stores/RootStore.js
import { types, flow, applySnapshot, getSnapshot } from 'mobx-state-tree';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { reaction } from 'mobx';

// User model
const User = types.model('User', {
  id: types.identifier,
  name: types.string,
  email: types.string,
  isActive: types.optional(types.boolean, true),
  createdAt: types.Date,
})
.actions(self => ({
  update(data) {
    Object.assign(self, data);
  },
}))
.views(self => ({
  get displayName() {
    return self.name || self.email.split('@')[0];
  },
}));

// Post model
const Post = types.model('Post', {
  id: types.identifier,
  title: types.string,
  content: types.string,
  authorId: types.string,
  likes: types.optional(types.number, 0),
  createdAt: types.Date,
})
.actions(self => ({
  like() {
    self.likes += 1;
  },
  unlike() {
    self.likes = Math.max(0, self.likes - 1);
  },
}))
.views(self => ({
  get author() {
    return getRoot(self).users.get(self.authorId);
  },
  get isLiked() {
    return self.likes > 0;
  },
}));

// Root store
const RootStore = types.model('RootStore', {
  users: types.map(User),
  posts: types.map(Post),
  isLoading: types.optional(types.boolean, false),
  error: types.maybeNull(types.string),
})
.actions(self => ({
  // Fetch data
  fetchUsers: flow(function* () {
    self.isLoading = true;
    self.error = null;
    
    try {
      const response = yield api.getUsers();
      response.forEach(user => {
        self.users.put(user);
      });
    } catch (error) {
      self.error = error.message;
    } finally {
      self.isLoading = false;
    }
  }),

  fetchPosts: flow(function* () {
    self.isLoading = true;
    
    try {
      const response = yield api.getPosts();
      response.forEach(post => {
        self.posts.put(post);
      });
    } catch (error) {
      self.error = error.message;
    } finally {
      self.isLoading = false;
    }
  }),

  // Create post with optimistic update
  createPost: flow(function* (postData) {
    const tempId = \`temp_\${Date.now()}\`;
    const optimisticPost = Post.create({
      id: tempId,
      ...postData,
      createdAt: new Date(),
    });
    
    self.posts.put(optimisticPost);
    
    try {
      const response = yield api.createPost(postData);
      self.posts.delete(tempId);
      self.posts.put(response);
    } catch (error) {
      self.posts.delete(tempId);
      throw error;
    }
  }),

  // Persistence
  hydrate: flow(function* () {
    try {
      const snapshot = yield AsyncStorage.getItem('rootStore');
      if (snapshot) {
        applySnapshot(self, JSON.parse(snapshot));
      }
    } catch (error) {
      console.error('Hydration error:', error);
    }
  }),

  clearAll() {
    self.users.clear();
    self.posts.clear();
    self.error = null;
  },
}))
.views(self => ({
  get userList() {
    return Array.from(self.users.values());
  },
  
  get postList() {
    return Array.from(self.posts.values())
      .sort((a, b) => b.createdAt - a.createdAt);
  },
  
  getUserPosts(userId) {
    return self.postList.filter(post => post.authorId === userId);
  },
  
  searchUsers(query) {
    const lowercaseQuery = query.toLowerCase();
    return self.userList.filter(user => 
      user.name.toLowerCase().includes(lowercaseQuery) ||
      user.email.toLowerCase().includes(lowercaseQuery)
    );
  },
}));

// Create and setup store
let rootStore;

export function setupRootStore() {
  rootStore = RootStore.create({});
  
  // Hydrate on creation
  rootStore.hydrate();
  
  // Setup auto-save
  reaction(
    () => getSnapshot(rootStore),
    snapshot => {
      AsyncStorage.setItem('rootStore', JSON.stringify(snapshot));
    },
    { delay: 1000 }
  );
  
  return rootStore;
}

export function getRootStore() {
  return rootStore;
}</code></pre>

            <h2>State Management with React Query</h2>
            <pre><code class="language-javascript">// hooks/useDataManagement.js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useNetInfo } from '@react-native-community/netinfo';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Custom hook for offline-first data management
export const useOfflineFirst = (key, fetcher, options = {}) => {
  const netInfo = useNetInfo();
  const queryClient = useQueryClient();

  const query = useQuery({
    queryKey: key,
    queryFn: async () => {
      // Try to fetch from network
      if (netInfo.isConnected) {
        try {
          const data = await fetcher();
          // Cache in AsyncStorage
          await AsyncStorage.setItem(
            \`cache_\${JSON.stringify(key)}\`,
            JSON.stringify({
              data,
              timestamp: Date.now(),
            })
          );
          return data;
        } catch (error) {
          // Fall back to cache if network fails
          const cached = await getCachedData(key);
          if (cached) return cached;
          throw error;
        }
      } else {
        // Offline - use cache
        const cached = await getCachedData(key);
        if (cached) return cached;
        throw new Error('No network connection and no cached data');
      }
    },
    ...options,
    // Keep data fresh based on connection
    staleTime: netInfo.isConnected ? 5 * 60 * 1000 : Infinity,
    cacheTime: 24 * 60 * 60 * 1000, // 24 hours
  });

  return {
    ...query,
    isOffline: !netInfo.isConnected,
  };
};

async function getCachedData(key) {
  try {
    const cached = await AsyncStorage.getItem(\`cache_\${JSON.stringify(key)}\`);
    if (cached) {
      const { data, timestamp } = JSON.parse(cached);
      // Check if cache is not too old (24 hours)
      if (Date.now() - timestamp < 24 * 60 * 60 * 1000) {
        return data;
      }
    }
  } catch (error) {
    console.error('Cache read error:', error);
  }
  return null;
}

// Optimistic updates with rollback
export const useOptimisticMutation = (
  mutationFn,
  { onOptimisticUpdate, onRollback }
) => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn,
    onMutate: async (variables) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries();

      // Snapshot previous value
      const previousData = onOptimisticUpdate
        ? await onOptimisticUpdate(queryClient, variables)
        : null;

      return { previousData };
    },
    onError: (err, variables, context) => {
      // Rollback on error
      if (onRollback && context?.previousData) {
        onRollback(queryClient, context.previousData);
      }
    },
    onSettled: () => {
      // Refetch after error or success
      queryClient.invalidateQueries();
    },
  });
};</code></pre>

            <h2>Performance Monitoring</h2>
            <pre><code class="language-javascript">// utils/stateMonitoring.js
class StateMonitor {
  constructor() {
    this.metrics = {
      stateUpdates: 0,
      renderCounts: {},
      actionDurations: {},
    };
  }

  // Monitor Redux
  createReduxMiddleware() {
    return store => next => action => {
      const start = performance.now();
      const result = next(action);
      const duration = performance.now() - start;

      this.metrics.actionDurations[action.type] = 
        (this.metrics.actionDurations[action.type] || []).concat(duration);
      
      if (duration > 16) { // Longer than one frame
        console.warn(\`Slow action: \${action.type} took \${duration}ms\`);
      }

      return result;
    };
  }

  // Monitor Zustand
  zustandMiddleware(config) {
    return (set, get, api) =>
      config(
        (...args) => {
          this.metrics.stateUpdates++;
          const start = performance.now();
          set(...args);
          const duration = performance.now() - start;
          
          if (duration > 16) {
            console.warn(\`Slow state update took \${duration}ms\`);
          }
        },
        get,
        api
      );
  }

  // Monitor component renders
  useRenderCounter(componentName) {
    useEffect(() => {
      this.metrics.renderCounts[componentName] = 
        (this.metrics.renderCounts[componentName] || 0) + 1;
    });
  }

  // Get report
  getReport() {
    const avgActionDurations = {};
    Object.entries(this.metrics.actionDurations).forEach(([action, durations]) => {
      const avg = durations.reduce((a, b) => a + b, 0) / durations.length;
      avgActionDurations[action] = avg.toFixed(2);
    });

    return {
      totalStateUpdates: this.metrics.stateUpdates,
      renderCounts: this.metrics.renderCounts,
      avgActionDurations,
      slowActions: Object.entries(avgActionDurations)
        .filter(([_, avg]) => parseFloat(avg) > 16)
        .map(([action, avg]) => ({ action, avgDuration: avg })),
    };
  }
}

export const stateMonitor = new StateMonitor();</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Choose state management based on app complexity</li>
                    <li>Implement offline-first strategies</li>
                    <li>Use optimistic updates for better UX</li>
                    <li>Monitor state update performance</li>
                    <li>Persist only necessary state</li>
                    <li>Handle sync conflicts gracefully</li>
                    <li>Implement proper error boundaries</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the advantage of RTK Query over regular Redux?",
            options: [
                "Smaller bundle size",
                "Built-in caching and data fetching",
                "Better TypeScript support",
                "Faster performance"
            ],
            correct: 1
        },
        {
            question: "When should you use optimistic updates?",
            options: [
                "For all mutations",
                "Only for deletions",
                "For actions with predictable outcomes and good UX",
                "Never"
            ],
            correct: 2
        },
        {
            question: "What's the best approach for offline-first apps?",
            options: [
                "Always fetch from network",
                "Cache everything forever",
                "Try network first, fall back to cache",
                "Only use local storage"
            ],
            correct: 2
        }
    ],
    project: {
        title: "Offline-First Social App",
        description: "Build a social app with robust offline support and state management",
        requirements: [
            "User authentication with token refresh",
            "Posts with offline creation",
            "Real-time comments with WebSocket",
            "Image upload with queue",
            "Optimistic updates for likes",
            "Conflict resolution for edits",
            "State persistence across sessions",
            "Performance monitoring dashboard"
        ],
        hints: [
            "Use RTK Query for API management",
            "Implement queue for offline actions",
            "Show sync status to users",
            "Handle auth token expiry gracefully"
        ]
    }
},
'file-system-and-media': {
    content: `
        <div class="content-section">
            <h1>File System & Media</h1>
            
            <div class="info-box">
                <p>Learn how to work with the file system, handle media files, and implement file upload/download functionality in React Native applications.</p>
            </div>

            <h2>React Native FS (File System)</h2>
            <pre><code class="language-bash"># Install react-native-fs
npm install react-native-fs

# iOS
cd ios && pod install</code></pre>

            <h2>Basic File Operations</h2>
            <pre><code class="language-javascript">import RNFS from 'react-native-fs';

// File paths
const documentsPath = RNFS.DocumentDirectoryPath;
const cachePath = RNFS.CachesDirectoryPath;
const externalPath = RNFS.ExternalDirectoryPath; // Android only

// Read directory
const readDirectory = async () => {
  try {
    const files = await RNFS.readDir(documentsPath);
    console.log('Files:', files);
    
    files.forEach(file => {
      console.log('Name:', file.name);
      console.log('Path:', file.path);
      console.log('Size:', file.size);
      console.log('Is Directory:', file.isDirectory());
      console.log('Modified:', file.mtime);
    });
  } catch (error) {
    console.error('Read directory error:', error);
  }
};

// Write file
const writeFile = async (filename, content) => {
  const path = \`\${documentsPath}/\${filename}\`;
  
  try {
    await RNFS.writeFile(path, content, 'utf8');
    console.log('File written successfully');
    return path;
  } catch (error) {
    console.error('Write file error:', error);
    throw error;
  }
};

// Read file
const readFile = async (filename) => {
  const path = \`\${documentsPath}/\${filename}\`;
  
  try {
    const content = await RNFS.readFile(path, 'utf8');
    return content;
  } catch (error) {
    console.error('Read file error:', error);
    throw error;
  }
};

// Delete file
const deleteFile = async (filename) => {
  const path = \`\${documentsPath}/\${filename}\`;
  
  try {
    await RNFS.unlink(path);
    console.log('File deleted');
  } catch (error) {
    console.error('Delete file error:', error);
  }
};

// Check if file exists
const fileExists = async (filename) => {
  const path = \`\${documentsPath}/\${filename}\`;
  return await RNFS.exists(path);
};

// Get file info
const getFileInfo = async (filename) => {
  const path = \`\${documentsPath}/\${filename}\`;
  
  try {
    const stats = await RNFS.stat(path);
    return {
      size: stats.size,
      isFile: stats.isFile(),
      isDirectory: stats.isDirectory(),
      modificationTime: stats.mtime,
      creationTime: stats.ctime,
    };
  } catch (error) {
    console.error('File info error:', error);
    return null;
  }
};

// Create directory
const createDirectory = async (dirname) => {
  const path = \`\${documentsPath}/\${dirname}\`;
  
  try {
    await RNFS.mkdir(path);
    console.log('Directory created');
  } catch (error) {
    console.error('Create directory error:', error);
  }
};</code></pre>

            <h2>File Download Management</h2>
            <pre><code class="language-javascript">// Download file with progress
const downloadFile = async (url, filename) => {
  const localPath = \`\${documentsPath}/\${filename}\`;
  
  const options = {
    fromUrl: url,
    toFile: localPath,
    background: true,
    discretionary: true,
    cacheable: true,
    progressDivider: 10,
    begin: (res) => {
      console.log('Download started:', res);
    },
    progress: (res) => {
      const percentage = (res.bytesWritten / res.contentLength) * 100;
      console.log(\`Progress: \${percentage.toFixed(2)}%\`);
    },
  };

  try {
    const result = await RNFS.downloadFile(options).promise;
    
    if (result.statusCode === 200) {
      console.log('Download complete:', localPath);
      return localPath;
    } else {
      throw new Error(\`Download failed: \${result.statusCode}\`);
    }
  } catch (error) {
    console.error('Download error:', error);
    throw error;
  }
};

// Download manager with queue
class DownloadManager {
  constructor() {
    this.queue = [];
    this.activeDownloads = new Map();
    this.maxConcurrent = 3;
  }

  async addToQueue(url, filename, onProgress) {
    const download = {
      id: Date.now().toString(),
      url,
      filename,
      status: 'queued',
      progress: 0,
      onProgress,
    };

    this.queue.push(download);
    this.processQueue();
    
    return download.id;
  }

  async processQueue() {
    while (
      this.queue.length > 0 && 
      this.activeDownloads.size < this.maxConcurrent
    ) {
      const download = this.queue.shift();
      this.startDownload(download);
    }
  }

  async startDownload(download) {
    const localPath = \`\${documentsPath}/downloads/\${download.filename}\`;
    
    const task = RNFS.downloadFile({
      fromUrl: download.url,
      toFile: localPath,
      background: true,
      progressDivider: 5,
      progress: (res) => {
        download.progress = (res.bytesWritten / res.contentLength) * 100;
        download.status = 'downloading';
        download.onProgress?.(download);
      },
    });

    this.activeDownloads.set(download.id, task);

    try {
      const result = await task.promise;
      
      if (result.statusCode === 200) {
        download.status = 'completed';
        download.localPath = localPath;
      } else {
        download.status = 'failed';
        download.error = \`HTTP \${result.statusCode}\`;
      }
    } catch (error) {
      download.status = 'failed';
      download.error = error.message;
    } finally {
      this.activeDownloads.delete(download.id);
      download.onProgress?.(download);
      this.processQueue();
    }
  }

  pauseDownload(downloadId) {
    const task = this.activeDownloads.get(downloadId);
    if (task) {
      task.stopDownload();
      this.activeDownloads.delete(downloadId);
    }
  }

  resumeDownload(downloadId) {
    // Re-add to queue
    const download = this.findDownload(downloadId);
    if (download && download.status === 'paused') {
      this.queue.push(download);
      this.processQueue();
    }
  }
}</code></pre>

            <h2>Image & Media Handling</h2>
            <pre><code class="language-javascript">import {
  launchImageLibrary,
  launchCamera,
} from 'react-native-image-picker';
import ImageResizer from 'react-native-image-resizer';

// Image picker options
const imagePickerOptions = {
  mediaType: 'photo',
  quality: 0.8,
  maxWidth: 1920,
  maxHeight: 1080,
  includeBase64: false,
  selectionLimit: 1,
};

// Pick image from gallery
const pickImage = async () => {
  try {
    const result = await launchImageLibrary(imagePickerOptions);
    
    if (!result.didCancel && result.assets?.[0]) {
      const asset = result.assets[0];
      return {
        uri: asset.uri,
        type: asset.type,
        fileName: asset.fileName,
        fileSize: asset.fileSize,
      };
    }
  } catch (error) {
    console.error('Image picker error:', error);
  }
  return null;
};

// Take photo with camera
const takePhoto = async () => {
  try {
    const result = await launchCamera({
      ...imagePickerOptions,
      saveToPhotos: true,
    });
    
    if (!result.didCancel && result.assets?.[0]) {
      return result.assets[0];
    }
  } catch (error) {
    console.error('Camera error:', error);
  }
  return null;
};

// Resize and compress image
const processImage = async (imageUri, options = {}) => {
  const {
    maxWidth = 1280,
    maxHeight = 1280,
    quality = 80,
    format = 'JPEG',
  } = options;

  try {
    const resizedImage = await ImageResizer.createResizedImage(
      imageUri,
      maxWidth,
      maxHeight,
      format,
      quality,
      0, // rotation
      undefined, // output path
      false, // keep metadata
    );

    return {
      uri: resizedImage.uri,
      size: resizedImage.size,
      width: resizedImage.width,
      height: resizedImage.height,
    };
  } catch (error) {
    console.error('Image resize error:', error);
    throw error;
  }
};

// Save image to device
const saveImageToDevice = async (imageUri, albumName = 'MyApp') => {
  try {
    // Copy to permanent location
    const filename = \`IMG_\${Date.now()}.jpg\`;
    const destPath = \`\${documentsPath}/images/\${filename}\`;
    
    // Ensure directory exists
    await RNFS.mkdir(\`\${documentsPath}/images\`);
    
    // Copy file
    await RNFS.copyFile(imageUri, destPath);
    
    return destPath;
  } catch (error) {
    console.error('Save image error:', error);
    throw error;
  }
};</code></pre>

            <h2>File Upload</h2>
            <pre><code class="language-javascript">// Upload file with progress
class FileUploader {
  async uploadFile(file, uploadUrl, onProgress) {
    const formData = new FormData();
    formData.append('file', {
      uri: file.uri,
      type: file.type || 'application/octet-stream',
      name: file.name || 'file',
    });

    // Add additional fields
    formData.append('userId', 'user123');
    formData.append('timestamp', Date.now().toString());

    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();

      // Progress tracking
      xhr.upload.addEventListener('progress', (event) => {
        if (event.lengthComputable) {
          const progress = (event.loaded / event.total) * 100;
          onProgress?.(progress);
        }
      });

      // Handle completion
      xhr.addEventListener('load', () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          try {
            const response = JSON.parse(xhr.responseText);
            resolve(response);
          } catch (error) {
            resolve(xhr.responseText);
          }
        } else {
          reject(new Error(\`Upload failed: \${xhr.status}\`));
        }
      });

      // Handle errors
      xhr.addEventListener('error', () => {
        reject(new Error('Network error'));
      });

      xhr.addEventListener('abort', () => {
        reject(new Error('Upload cancelled'));
      });

      // Send request
      xhr.open('POST', uploadUrl);
      xhr.setRequestHeader('Authorization', 'Bearer token');
      xhr.send(formData);

      // Return abort function
      return () => xhr.abort();
    });
  }

  // Upload multiple files
  async uploadMultiple(files, uploadUrl, onProgress) {
    const totalSize = files.reduce((sum, file) => sum + file.size, 0);
    let uploadedSize = 0;

    const results = [];

    for (const file of files) {
      const fileStartSize = uploadedSize;
      
      try {
        const result = await this.uploadFile(
          file,
          uploadUrl,
          (fileProgress) => {
            const currentFileUploaded = (file.size * fileProgress) / 100;
            const totalProgress = 
              ((fileStartSize + currentFileUploaded) / totalSize) * 100;
            onProgress?.(totalProgress);
          }
        );

        uploadedSize += file.size;
        results.push({ file, result, success: true });
      } catch (error) {
        results.push({ file, error, success: false });
      }
    }

    return results;
  }
}</code></pre>

            <h2>Document Handling</h2>
            <pre><code class="language-javascript">import DocumentPicker from 'react-native-document-picker';
import FileViewer from 'react-native-file-viewer';

// Pick documents
const pickDocument = async () => {
  try {
    const result = await DocumentPicker.pick({
      type: [
        DocumentPicker.types.pdf,
        DocumentPicker.types.doc,
        DocumentPicker.types.docx,
        DocumentPicker.types.xls,
        DocumentPicker.types.xlsx,
        DocumentPicker.types.ppt,
        DocumentPicker.types.pptx,
      ],
      copyTo: 'cachesDirectory',
    });

    return {
      uri: result[0].fileCopyUri || result[0].uri,
      type: result[0].type,
      name: result[0].name,
      size: result[0].size,
    };
  } catch (error) {
    if (DocumentPicker.isCancel(error)) {
      console.log('User cancelled');
    } else {
      console.error('Document picker error:', error);
    }
    return null;
  }
};

// Open file with default app
const openFile = async (filePath) => {
  try {
    await FileViewer.open(filePath, {
      showOpenWithDialog: true,
      showAppsSuggestions: true,
    });
  } catch (error) {
    console.error('File open error:', error);
    Alert.alert('Error', 'Cannot open this file type');
  }
};

// File type detection
const getFileType = (filename) => {
  const extension = filename.split('.').pop().toLowerCase();
  
  const types = {
    // Images
    jpg: 'image',
    jpeg: 'image',
    png: 'image',
    gif: 'image',
    webp: 'image',
    
    // Videos
    mp4: 'video',
    mov: 'video',
    avi: 'video',
    
    // Documents
    pdf: 'pdf',
    doc: 'document',
    docx: 'document',
    xls: 'spreadsheet',
    xlsx: 'spreadsheet',
    
    // Archives
    zip: 'archive',
    rar: 'archive',
    
    // Default
    default: 'file',
  };
  
  return types[extension] || types.default;
};</code></pre>

            <h2>Cache Management</h2>
            <pre><code class="language-javascript">class CacheManager {
  constructor(maxSize = 100 * 1024 * 1024) { // 100MB
    this.maxSize = maxSize;
    this.cacheDir = \`\${RNFS.CachesDirectoryPath}/app_cache\`;
    this.initCache();
  }

  async initCache() {
    try {
      await RNFS.mkdir(this.cacheDir);
    } catch (error) {
      console.error('Init cache error:', error);
    }
  }

  async getCacheSize() {
    try {
      const files = await RNFS.readDir(this.cacheDir);
      return files.reduce((total, file) => total + file.size, 0);
    } catch (error) {
      return 0;
    }
  }

  async clearCache() {
    try {
      await RNFS.unlink(this.cacheDir);
      await this.initCache();
      console.log('Cache cleared');
    } catch (error) {
      console.error('Clear cache error:', error);
    }
  }

  async pruneCache() {
    try {
      const files = await RNFS.readDir(this.cacheDir);
      
      // Sort by modification time (oldest first)
      files.sort((a, b) => a.mtime - b.mtime);
      
      let totalSize = files.reduce((sum, file) => sum + file.size, 0);
      let deletedCount = 0;
      
      // Delete oldest files until under max size
      for (const file of files) {
        if (totalSize > this.maxSize) {
          await RNFS.unlink(file.path);
          totalSize -= file.size;
          deletedCount++;
        } else {
          break;
        }
      }
      
      console.log(\`Pruned \${deletedCount} files from cache\`);
    } catch (error) {
      console.error('Prune cache error:', error);
    }
  }

  async cacheFile(url, filename) {
    const cachedPath = \`\${this.cacheDir}/\${filename}\`;
    
    // Check if already cached
    if (await RNFS.exists(cachedPath)) {
      return cachedPath;
    }
    
    // Download and cache
    try {
      await RNFS.downloadFile({
        fromUrl: url,
        toFile: cachedPath,
      }).promise;
      
      // Prune cache if needed
      const cacheSize = await this.getCacheSize();
      if (cacheSize > this.maxSize) {
        await this.pruneCache();
      }
      
      return cachedPath;
    } catch (error) {
      console.error('Cache file error:', error);
      throw error;
    }
  }
}</code></pre>

            <div class="tip-box">
                <h3>💡 Best Practices</h3>
                <ul>
                    <li>Always check available storage before writing large files</li>
                    <li>Implement proper error handling for file operations</li>
                    <li>Use appropriate directories (documents vs cache)</li>
                    <li>Clean up temporary files regularly</li>
                    <li>Compress images before uploading</li>
                    <li>Show progress for long operations</li>
                    <li>Handle permissions properly on both platforms</li>
                    <li>Implement file size limits for uploads</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "Which directory should you use for temporary files?",
            options: [
                "DocumentDirectoryPath",
                "CachesDirectoryPath",
                "ExternalDirectoryPath",
                "MainBundlePath"
            ],
            correct: 1
        },
        {
            question: "What's the best way to handle large file uploads?",
            options: [
                "Upload the entire file at once",
                "Use base64 encoding",
                "Use XMLHttpRequest with progress tracking",
                "Avoid large file uploads"
            ],
            correct: 2
        },
        {
            question: "When should you resize images?",
            options: [
                "Never",
                "Only for thumbnails",
                "Before uploading to reduce bandwidth",
                "After downloading"
            ],
            correct: 2
        }
    ],
    project: {
        title: "Cloud Storage App",
        description: "Build a file management app with cloud storage integration",
        requirements: [
            "File browser with folder navigation",
            "Upload files with progress tracking",
            "Download files for offline access",
            "Image gallery with thumbnails",
            "Document viewer",
            "File sharing functionality",
            "Storage usage statistics",
            "Automatic cache management"
        ],
        hints: [
            "Use react-native-fs for file operations",
            "Implement chunked uploads for large files",
            "Cache thumbnails for performance",
            "Show file type icons"
        ]
    }
},
'sqlite': {
    content: `
        <div class="content-section">
            <h1>SQLite Database</h1>
            
            <div class="info-box">
                <p>SQLite is a lightweight, serverless, and self-contained SQL database engine. Perfect for mobile apps requiring structured data storage with complex queries and relationships.</p>
            </div>

            <h2>Installation & Setup</h2>
            <pre><code class="language-bash"># Install SQLite for React Native
npm install react-native-sqlite-storage

# For iOS
cd ios && pod install

# For TypeScript support
npm install --save-dev @types/react-native-sqlite-storage</code></pre>

            <h2>Database Configuration</h2>
            <pre><code class="language-javascript">import SQLite from 'react-native-sqlite-storage';

// Enable debugging in development
if (__DEV__) {
  SQLite.DEBUG(true);
}

// Enable promise-based API
SQLite.enablePromise(true);

// Database configuration
const database_name = "MyApp.db";
const database_version = "1.0";
const database_displayname = "My Application Database";
const database_size = 200000; // in bytes

// Open database connection
export const openDatabase = async () => {
  try {
    const db = await SQLite.openDatabase(
      database_name,
      database_version,
      database_displayname,
      database_size
    );
    
    console.log('Database opened successfully');
    return db;
  } catch (error) {
    console.error('Failed to open database:', error);
    throw error;
  }
};</code></pre>

            <h2>Schema Creation</h2>
            <pre><code class="language-javascript">// Database schema setup
export const createTables = async (db) => {
  try {
    await db.transaction((tx) => {
      // Users table
      tx.executeSql(
        \`CREATE TABLE IF NOT EXISTS users (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          username TEXT NOT NULL UNIQUE,
          email TEXT NOT NULL UNIQUE,
          password_hash TEXT NOT NULL,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )\`
      );

      // Posts table with foreign key
      tx.executeSql(
        \`CREATE TABLE IF NOT EXISTS posts (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id INTEGER NOT NULL,
          title TEXT NOT NULL,
          content TEXT,
          is_published BOOLEAN DEFAULT 0,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (user_id) REFERENCES users (id)
            ON DELETE CASCADE
        )\`
      );

      // Tags table
      tx.executeSql(
        \`CREATE TABLE IF NOT EXISTS tags (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL UNIQUE
        )\`
      );

      // Many-to-many relationship table
      tx.executeSql(
        \`CREATE TABLE IF NOT EXISTS post_tags (
          post_id INTEGER,
          tag_id INTEGER,
          PRIMARY KEY (post_id, tag_id),
          FOREIGN KEY (post_id) REFERENCES posts (id) ON DELETE CASCADE,
          FOREIGN KEY (tag_id) REFERENCES tags (id) ON DELETE CASCADE
        )\`
      );

      // Create indexes for better performance
      tx.executeSql(
        'CREATE INDEX IF NOT EXISTS idx_posts_user_id ON posts (user_id)'
      );
      
      tx.executeSql(
        'CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts (created_at)'
      );
    });

    console.log('Tables created successfully');
  } catch (error) {
    console.error('Failed to create tables:', error);
    throw error;
  }
};</code></pre>

            <h2>CRUD Operations</h2>
            <pre><code class="language-javascript">class SQLiteService {
  constructor(db) {
    this.db = db;
  }

  // CREATE - Insert user
  async createUser(username, email, passwordHash) {
    return new Promise((resolve, reject) => {
      this.db.transaction((tx) => {
        tx.executeSql(
          'INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)',
          [username, email, passwordHash],
          (tx, results) => {
            resolve({
              id: results.insertId,
              username,
              email
            });
          },
          (tx, error) => {
            reject(error);
          }
        );
      });
    });
  }

  // READ - Get all users with pagination
  async getUsers(limit = 10, offset = 0) {
    return new Promise((resolve, reject) => {
      this.db.transaction((tx) => {
        tx.executeSql(
          \`SELECT id, username, email, created_at 
           FROM users 
           ORDER BY created_at DESC 
           LIMIT ? OFFSET ?\`,
          [limit, offset],
          (tx, results) => {
            const users = [];
            for (let i = 0; i < results.rows.length; i++) {
              users.push(results.rows.item(i));
            }
            resolve(users);
          },
          (tx, error) => {
            reject(error);
          }
        );
      });
    });
  }

  // READ - Get user by ID with posts
  async getUserWithPosts(userId) {
    return new Promise((resolve, reject) => {
      this.db.transaction((tx) => {
        // Get user
        tx.executeSql(
          'SELECT * FROM users WHERE id = ?',
          [userId],
          (tx, userResults) => {
            if (userResults.rows.length === 0) {
              resolve(null);
              return;
            }

            const user = userResults.rows.item(0);

            // Get user's posts
            tx.executeSql(
              \`SELECT * FROM posts 
               WHERE user_id = ? 
               ORDER BY created_at DESC\`,
              [userId],
              (tx, postResults) => {
                const posts = [];
                for (let i = 0; i < postResults.rows.length; i++) {
                  posts.push(postResults.rows.item(i));
                }
                
                resolve({
                  ...user,
                  posts
                });
              },
              (tx, error) => reject(error)
            );
          },
          (tx, error) => reject(error)
        );
      });
    });
  }

  // UPDATE - Update user
  async updateUser(userId, updates) {
    const fields = [];
    const values = [];
    
    Object.keys(updates).forEach(key => {
      if (['username', 'email'].includes(key)) {
        fields.push(\`\${key} = ?\`);
        values.push(updates[key]);
      }
    });

    if (fields.length === 0) {
      throw new Error('No valid fields to update');
    }

    values.push(userId);

    return new Promise((resolve, reject) => {
      this.db.transaction((tx) => {
        tx.executeSql(
          \`UPDATE users 
           SET \${fields.join(', ')}, updated_at = CURRENT_TIMESTAMP 
           WHERE id = ?\`,
          values,
          (tx, results) => {
            resolve(results.rowsAffected > 0);
          },
          (tx, error) => reject(error)
        );
      });
    });
  }

  // DELETE - Delete user (cascade deletes posts)
  async deleteUser(userId) {
    return new Promise((resolve, reject) => {
      this.db.transaction((tx) => {
        tx.executeSql(
          'DELETE FROM users WHERE id = ?',
          [userId],
          (tx, results) => {
            resolve(results.rowsAffected > 0);
          },
          (tx, error) => reject(error)
        );
      });
    });
  }

  // Complex query - Search posts with tags
  async searchPostsWithTags(searchTerm, tagNames = []) {
    let query = \`
      SELECT DISTINCT p.*, u.username, u.email
      FROM posts p
      INNER JOIN users u ON p.user_id = u.id
    \`;

    const params = [];

    if (tagNames.length > 0) {
      query += \`
        INNER JOIN post_tags pt ON p.id = pt.post_id
        INNER JOIN tags t ON pt.tag_id = t.id
        WHERE t.name IN (\${tagNames.map(() => '?').join(',')})
      \`;
      params.push(...tagNames);
      
      if (searchTerm) {
        query += ' AND (p.title LIKE ? OR p.content LIKE ?)';
        params.push(\`%\${searchTerm}%\`, \`%\${searchTerm}%\`);
      }
    } else if (searchTerm) {
      query += ' WHERE p.title LIKE ? OR p.content LIKE ?';
      params.push(\`%\${searchTerm}%\`, \`%\${searchTerm}%\`);
    }

    query += ' ORDER BY p.created_at DESC';

    return new Promise((resolve, reject) => {
      this.db.transaction((tx) => {
        tx.executeSql(
          query,
          params,
          (tx, results) => {
            const posts = [];
            for (let i = 0; i < results.rows.length; i++) {
              posts.push(results.rows.item(i));
            }
            resolve(posts);
          },
          (tx, error) => reject(error)
        );
      });
    });
  }
}</code></pre>

            <h2>Transactions & Batch Operations</h2>
            <pre><code class="language-javascript">// Batch insert with transaction
export const batchInsertPosts = async (db, posts) => {
  return new Promise((resolve, reject) => {
    db.transaction(
      (tx) => {
        posts.forEach(post => {
          tx.executeSql(
            'INSERT INTO posts (user_id, title, content) VALUES (?, ?, ?)',
            [post.userId, post.title, post.content]
          );
        });
      },
      (error) => {
        console.error('Transaction failed:', error);
        reject(error);
      },
      () => {
        console.log('Batch insert completed');
        resolve();
      }
    );
  });
};

// Transaction with rollback
export const transferOwnership = async (db, postId, fromUserId, toUserId) => {
  return new Promise((resolve, reject) => {
    db.transaction((tx) => {
      // Verify post exists and belongs to fromUser
      tx.executeSql(
        'SELECT * FROM posts WHERE id = ? AND user_id = ?',
        [postId, fromUserId],
        (tx, results) => {
          if (results.rows.length === 0) {
            throw new Error('Post not found or unauthorized');
          }

          // Update post ownership
          tx.executeSql(
            'UPDATE posts SET user_id = ? WHERE id = ?',
            [toUserId, postId],
            (tx, results) => {
              if (results.rowsAffected === 0) {
                throw new Error('Failed to update ownership');
              }
            }
          );

          // Log the transfer
          tx.executeSql(
            \`INSERT INTO ownership_logs (post_id, from_user_id, to_user_id) 
             VALUES (?, ?, ?)\`,
            [postId, fromUserId, toUserId]
          );
        }
      );
    },
    (error) => {
      console.error('Transfer failed, rolling back:', error);
      reject(error);
    },
    () => {
      console.log('Transfer completed successfully');
      resolve();
    });
  });
};</code></pre>

            <h2>Database Migrations</h2>
            <pre><code class="language-javascript">// Migration system
const migrations = [
  {
    version: 1,
    up: async (db) => {
      // Initial schema
      await createTables(db);
    }
  },
  {
    version: 2,
    up: async (db) => {
      // Add new column
      await db.executeSql(
        'ALTER TABLE users ADD COLUMN avatar_url TEXT'
      );
    }
  },
  {
    version: 3,
    up: async (db) => {
      // Create new table
      await db.executeSql(\`
        CREATE TABLE IF NOT EXISTS user_settings (
          user_id INTEGER PRIMARY KEY,
          theme TEXT DEFAULT 'light',
          notifications_enabled BOOLEAN DEFAULT 1,
          FOREIGN KEY (user_id) REFERENCES users (id)
        )
      \`);
    }
  }
];

export const runMigrations = async (db) => {
  // Create migrations table
  await db.executeSql(\`
    CREATE TABLE IF NOT EXISTS migrations (
      version INTEGER PRIMARY KEY,
      applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  \`);

  // Get current version
  const results = await db.executeSql(
    'SELECT MAX(version) as version FROM migrations'
  );
  
  const currentVersion = results.rows.item(0).version || 0;

  // Run pending migrations
  for (const migration of migrations) {
    if (migration.version > currentVersion) {
      console.log(\`Running migration version \${migration.version}\`);
      
      await db.transaction(async (tx) => {
        await migration.up(db);
        await tx.executeSql(
          'INSERT INTO migrations (version) VALUES (?)',
          [migration.version]
        );
      });
    }
  }
};</code></pre>

            <h2>Performance Optimization</h2>
            <pre><code class="language-javascript">// Connection pooling
class DatabasePool {
  constructor(maxConnections = 5) {
    this.connections = [];
    this.maxConnections = maxConnections;
    this.waitingQueue = [];
  }

  async getConnection() {
    if (this.connections.length < this.maxConnections) {
      const db = await openDatabase();
      this.connections.push(db);
      return db;
    }

    // Wait for available connection
    return new Promise((resolve) => {
      this.waitingQueue.push(resolve);
    });
  }

  releaseConnection(db) {
    if (this.waitingQueue.length > 0) {
      const resolve = this.waitingQueue.shift();
      resolve(db);
    }
  }
}

// Prepared statements for better performance
class PreparedStatements {
  constructor(db) {
    this.db = db;
    this.statements = new Map();
  }

  prepare(key, sql) {
    this.statements.set(key, sql);
  }

  async execute(key, params = []) {
    const sql = this.statements.get(key);
    if (!sql) {
      throw new Error(\`No prepared statement found for key: \${key}\`);
    }

    return new Promise((resolve, reject) => {
      this.db.executeSql(
        sql,
        params,
        (results) => resolve(results),
        (error) => reject(error)
      );
    });
  }
}

// Query optimization tips
const optimizationTips = \`
1. Use indexes on frequently queried columns
2. Avoid SELECT * - specify needed columns
3. Use LIMIT for pagination
4. Batch operations in transactions
5. Use prepared statements for repeated queries
6. Vacuum database periodically
7. Monitor query execution time
\`;

// Example: Optimize slow query
const optimizeUserPostsQuery = async (db) => {
  // Before (slow)
  const slowQuery = \`
    SELECT * FROM posts p, users u 
    WHERE p.user_id = u.id
  \`;

  // After (optimized)
  const optimizedQuery = \`
    SELECT p.id, p.title, p.created_at, 
           u.username, u.email
    FROM posts p
    INNER JOIN users u ON p.user_id = u.id
    WHERE p.is_published = 1
    ORDER BY p.created_at DESC
    LIMIT 20
  \`;

  // Create covering index
  await db.executeSql(\`
    CREATE INDEX idx_posts_published_created 
    ON posts (is_published, created_at) 
    WHERE is_published = 1
  \`);
};</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>SQLite Best Practices:</h4>
                <ul>
                    <li>Always use transactions for multiple operations</li>
                    <li>Close database connections when not in use</li>
                    <li>Use parameterized queries to prevent SQL injection</li>
                    <li>Index foreign keys and frequently searched columns</li>
                    <li>Keep schema migrations versioned</li>
                    <li>Regular VACUUM to optimize database file</li>
                    <li>Use EXPLAIN QUERY PLAN for optimization</li>
                    <li>Implement proper error handling</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Create a note-taking app with SQLite:</p>
                <ul>
                    <li>Categories and notes tables</li>
                    <li>Full-text search capability</li>
                    <li>Tags with many-to-many relationships</li>
                    <li>Backup and restore functionality</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the maximum size of a SQLite database in React Native?",
            options: [
                "2GB",
                "4GB",
                "Limited by device storage",
                "100MB"
            ],
            correct: 2,
            explanation: "SQLite databases can grow as large as device storage allows, with a theoretical limit of 281TB."
        },
        {
            question: "Which is the correct way to prevent SQL injection?",
            options: [
                "String concatenation",
                "Template literals",
                "Parameterized queries with ?",
                "Escaping special characters"
            ],
            correct: 2,
            explanation: "Parameterized queries with placeholders (?) are the safest way to prevent SQL injection attacks."
        },
        {
            question: "What happens when you DELETE a user with CASCADE?",
            options: [
                "Only the user is deleted",
                "Related posts are also deleted",
                "An error is thrown",
                "Posts are set to NULL"
            ],
            correct: 1,
            explanation: "CASCADE delete removes the user and all related records that have foreign key constraints."
        }
    ],
    project: {
        title: "Note-Taking App with SQLite",
        description: "Build a comprehensive note-taking app with categories, tags, full-text search, and relationships",
        requirements: [
            "Create database schema for notes, categories, and tags",
            "Implement CRUD operations for all entities",
            "Add full-text search with FTS5",
            "Create many-to-many relationships for tags",
            "Implement data export/import functionality",
            "Add database backup and restore features",
            "Sync notes across devices",
            "Version history for notes"
        ],
        hints: [
            "Use FTS5 extension for full-text search",
            "Implement database migrations for updates",
            "Use transactions for bulk operations",
            "Index frequently queried columns",
            "Consider using prepared statements"
        ]
    }
},
'realm': {
    content: `
        <div class="content-section">
            <h1>Realm Database</h1>
            
            <div class="info-box">
                <p>Realm is a mobile-first database designed for simplicity and performance. It offers real-time synchronization, reactive architecture, and an intuitive object-oriented API.</p>
            </div>

            <h2>Installation & Setup</h2>
            <pre><code class="language-bash"># Install Realm
npm install realm

# For iOS (required)
cd ios && pod install

# For React Native 0.60+ auto-linking handles native dependencies</code></pre>

            <h2>Defining Schemas</h2>
            <pre><code class="language-javascript">import Realm from 'realm';

// Define your object schemas
const UserSchema = {
  name: 'User',
  primaryKey: 'id',
  properties: {
    id: 'string',
    username: { type: 'string', indexed: true },
    email: { type: 'string', indexed: true },
    age: 'int?', // optional integer
    isActive: { type: 'bool', default: true },
    createdAt: { type: 'date', default: new Date() },
    posts: { type: 'linkingObjects', objectType: 'Post', property: 'author' }
  }
};

const PostSchema = {
  name: 'Post',
  primaryKey: 'id',
  properties: {
    id: 'string',
    title: 'string',
    content: 'string',
    author: 'User',
    tags: 'Tag[]', // Array of Tag objects
    views: { type: 'int', default: 0 },
    isPublished: { type: 'bool', default: false },
    publishedAt: 'date?',
    metadata: 'mixed?', // Can store any type
    createdAt: { type: 'date', default: new Date() },
    updatedAt: { type: 'date', default: new Date() }
  }
};

const TagSchema = {
  name: 'Tag',
  primaryKey: 'name',
  properties: {
    name: 'string',
    color: 'string?',
    posts: { type: 'linkingObjects', objectType: 'Post', property: 'tags' }
  }
};

// Schema with embedded objects
const AddressSchema = {
  name: 'Address',
  embedded: true, // This makes it an embedded object
  properties: {
    street: 'string',
    city: 'string',
    country: 'string',
    postalCode: 'string'
  }
};

const ProfileSchema = {
  name: 'Profile',
  primaryKey: 'userId',
  properties: {
    userId: 'string',
    bio: 'string?',
    avatar: 'data?', // Binary data for images
    address: 'Address?', // Embedded object
    preferences: 'string{}', // Dictionary/Map
    followers: 'string[]', // Array of user IDs
    socialLinks: { type: 'list', objectType: 'string' }
  }
};</code></pre>

            <h2>Opening & Configuring Realm</h2>
            <pre><code class="language-javascript">// Realm configuration
const realmConfig = {
  schema: [UserSchema, PostSchema, TagSchema, ProfileSchema, AddressSchema],
  schemaVersion: 1,
  migration: (oldRealm, newRealm) => {
    // Handle schema migrations
    if (oldRealm.schemaVersion < 1) {
      // Migration logic here
    }
  },
  deleteRealmIfMigrationNeeded: __DEV__, // Only in development
  path: 'myapp.realm', // Custom database file name
  encryptionKey: generateEncryptionKey(), // Optional encryption
};

// Open Realm instance
let realm;

export const initializeRealm = async () => {
  try {
    realm = await Realm.open(realmConfig);
    console.log('Realm initialized successfully');
    return realm;
  } catch (error) {
    console.error('Failed to initialize Realm:', error);
    throw error;
  }
};

// Generate encryption key (store securely!)
function generateEncryptionKey() {
  const key = new ArrayBuffer(64);
  const keyView = new Uint8Array(key);
  for (let i = 0; i < 64; i++) {
    keyView[i] = Math.floor(Math.random() * 256);
  }
  return key;
}</code></pre>

            <h2>CRUD Operations</h2>
            <pre><code class="language-javascript">class RealmService {
  constructor(realm) {
    this.realm = realm;
  }

  // CREATE - Add new user
  createUser(userData) {
    let user;
    
    this.realm.write(() => {
      user = this.realm.create('User', {
        id: Realm.BSON.ObjectId().toHexString(),
        username: userData.username,
        email: userData.email,
        age: userData.age || null,
        createdAt: new Date()
      });
    });
    
    return user;
  }

  // CREATE - With relationships
  createPost(postData, authorId) {
    let post;
    
    this.realm.write(() => {
      const author = this.realm.objectForPrimaryKey('User', authorId);
      if (!author) {
        throw new Error('Author not found');
      }

      // Create tags if they don't exist
      const tags = postData.tags.map(tagName => {
        let tag = this.realm.objectForPrimaryKey('Tag', tagName);
        if (!tag) {
          tag = this.realm.create('Tag', { name: tagName });
        }
        return tag;
      });

      post = this.realm.create('Post', {
        id: Realm.BSON.ObjectId().toHexString(),
        title: postData.title,
        content: postData.content,
        author: author,
        tags: tags,
        createdAt: new Date(),
        updatedAt: new Date()
      });
    });
    
    return post;
  }

  // READ - Query users
  getUsers(filter = {}) {
    let users = this.realm.objects('User');
    
    if (filter.isActive !== undefined) {
      users = users.filtered('isActive = $0', filter.isActive);
    }
    
    if (filter.searchTerm) {
      users = users.filtered(
        'username CONTAINS[c] $0 OR email CONTAINS[c] $0',
        filter.searchTerm
      );
    }
    
    // Sort and limit
    users = users.sorted('createdAt', true); // true for descending
    
    if (filter.limit) {
      return Array.from(users.slice(0, filter.limit));
    }
    
    return Array.from(users);
  }

  // READ - Complex queries
  getPostsWithFilters(filters) {
    let query = this.realm.objects('Post');
    
    // Filter by author
    if (filters.authorId) {
      query = query.filtered('author.id = $0', filters.authorId);
    }
    
    // Filter by publication status
    if (filters.isPublished !== undefined) {
      query = query.filtered('isPublished = $0', filters.isPublished);
    }
    
    // Filter by date range
    if (filters.startDate && filters.endDate) {
      query = query.filtered(
        'createdAt >= $0 AND createdAt <= $1',
        filters.startDate,
        filters.endDate
      );
    }
    
    // Filter by tags (posts that have ALL specified tags)
    if (filters.tags && filters.tags.length > 0) {
      filters.tags.forEach(tag => {
        query = query.filtered('ANY tags.name = $0', tag);
      });
    }
    
    // Full-text search in title and content
    if (filters.searchTerm) {
      query = query.filtered(
        'title CONTAINS[c] $0 OR content CONTAINS[c] $0',
        filters.searchTerm
      );
    }
    
    // Sort by multiple fields
    query = query.sorted([
      ['isPublished', true],
      ['createdAt', true]
    ]);
    
    return Array.from(query);
  }

  // UPDATE - Update user
  updateUser(userId, updates) {
    const user = this.realm.objectForPrimaryKey('User', userId);
    
    if (!user) {
      throw new Error('User not found');
    }
    
    this.realm.write(() => {
      Object.keys(updates).forEach(key => {
        if (user.hasOwnProperty(key)) {
          user[key] = updates[key];
        }
      });
    });
    
    return user;
  }

  // UPDATE - Batch update
  batchUpdatePosts(filterQuery, updates) {
    const posts = this.realm.objects('Post').filtered(filterQuery);
    
    this.realm.write(() => {
      posts.forEach(post => {
        Object.assign(post, updates);
        post.updatedAt = new Date();
      });
    });
    
    return posts.length;
  }

  // DELETE - Delete user
  deleteUser(userId) {
    const user = this.realm.objectForPrimaryKey('User', userId);
    
    if (!user) {
      return false;
    }
    
    this.realm.write(() => {
      // Delete user's posts first (if not using cascade)
      const userPosts = this.realm.objects('Post').filtered('author.id = $0', userId);
      this.realm.delete(userPosts);
      
      // Delete user
      this.realm.delete(user);
    });
    
    return true;
  }

  // DELETE - Batch delete with transaction
  deleteOldPosts(daysOld) {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);
    
    const oldPosts = this.realm.objects('Post').filtered(
      'createdAt < $0 AND isPublished = false',
      cutoffDate
    );
    
    const count = oldPosts.length;
    
    this.realm.write(() => {
      this.realm.delete(oldPosts);
    });
    
    return count;
  }
}</code></pre>

            <h2>Reactive Queries & Listeners</h2>
            <pre><code class="language-javascript">import { useEffect, useState } from 'react';

// Custom hook for reactive Realm queries
export const useRealmQuery = (objectType, filter) => {
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let objects = realm.objects(objectType);
    
    if (filter) {
      objects = objects.filtered(filter);
    }

    // Convert to array initially
    setResults(Array.from(objects));
    setLoading(false);

    // Add listener for changes
    const listener = (collection, changes) => {
      // Update state when collection changes
      setResults(Array.from(collection));
    };

    objects.addListener(listener);

    // Cleanup
    return () => {
      objects.removeListener(listener);
    };
  }, [objectType, filter]);

  return { results, loading };
};

// Component using reactive query
const UserList = () => {
  const { results: users, loading } = useRealmQuery('User', 'isActive = true');

  if (loading) return <Text>Loading...</Text>;

  return (
    <FlatList
      data={users}
      keyExtractor={item => item.id}
      renderItem={({ item }) => (
        <View>
          <Text>{item.username}</Text>
          <Text>{item.email}</Text>
        </View>
      )}
    />
  );
};

// Object-level listeners
const watchUser = (userId) => {
  const user = realm.objectForPrimaryKey('User', userId);
  
  if (!user) return;

  const listener = (object, changes) => {
    console.log('User changed:', changes.changedProperties);
    
    changes.changedProperties.forEach(prop => {
      console.log(\`\${prop}: \${object[prop]}\`);
    });
  };

  user.addListener(listener);

  // Return cleanup function
  return () => user.removeListener(listener);
};

// Collection notifications with detailed changes
const watchPosts = () => {
  const posts = realm.objects('Post').filtered('isPublished = true');

  posts.addListener((collection, changes) => {
    // Handle insertions
    changes.insertions.forEach(index => {
      console.log('New post:', collection[index].title);
    });

    // Handle modifications
    changes.modifications.forEach(index => {
      console.log('Modified post:', collection[index].title);
    });

    // Handle deletions
    console.log('Deleted posts:', changes.deletions.length);
  });
};</code></pre>

            <h2>Advanced Features</h2>
            <pre><code class="language-javascript">// Realm Sync configuration (MongoDB Realm)
const syncConfig = {
  user: realmUser, // Authenticated Realm user
  partitionValue: 'myPartition',
  newRealmFileBehavior: {
    type: 'downloadBeforeOpen',
    timeOut: 30000,
    timeOutBehavior: 'throwException'
  },
  existingRealmFileBehavior: {
    type: 'openImmediately',
    timeOut: 30000,
    timeOutBehavior: 'openLocalRealm'
  }
};

// Open synced Realm
const syncedRealm = await Realm.open({
  ...realmConfig,
  sync: syncConfig
});

// Conflict resolution
const conflictResolution = {
  onConflict: (localChange, remoteChange) => {
    // Custom conflict resolution logic
    if (localChange.updatedAt > remoteChange.updatedAt) {
      return localChange; // Keep local changes
    }
    return remoteChange; // Accept remote changes
  }
};

// Aggregation operations
const getPostStatistics = () => {
  const posts = realm.objects('Post');
  
  return {
    total: posts.length,
    published: posts.filtered('isPublished = true').length,
    avgViews: posts.avg('views'),
    maxViews: posts.max('views'),
    minViews: posts.min('views'),
    totalViews: posts.sum('views'),
    
    // Group by author
    byAuthor: Array.from(new Set(posts.map(p => p.author.id)))
      .map(authorId => ({
        authorId,
        count: posts.filtered('author.id = $0', authorId).length
      }))
  };
};

// Transactions with error handling
const complexTransaction = async () => {
  let success = false;
  
  try {
    realm.beginTransaction();
    
    // Multiple operations
    const user = realm.create('User', userData);
    const profile = realm.create('Profile', { userId: user.id, ...profileData });
    
    // Conditional logic
    if (someCondition) {
      realm.delete(someObject);
    }
    
    realm.commitTransaction();
    success = true;
  } catch (error) {
    if (realm.isInTransaction) {
      realm.cancelTransaction();
    }
    throw error;
  }
  
  return success;
};

// Backup and restore
export const backupRealm = async () => {
  const backupPath = \`\${Realm.defaultPath}.backup\`;
  
  // Close all Realm instances
  Realm.closeAll();
  
  // Copy Realm file
  await RNFS.copyFile(Realm.defaultPath, backupPath);
  
  return backupPath;
};

export const restoreRealm = async (backupPath) => {
  // Close all Realm instances
  Realm.closeAll();
  
  // Replace current Realm with backup
  await RNFS.copyFile(backupPath, Realm.defaultPath);
  
  // Reopen Realm
  realm = await Realm.open(realmConfig);
};</code></pre>

            <h2>Performance Optimization</h2>
            <pre><code class="language-javascript">// Lazy loading with pagination
class RealmPaginator {
  constructor(query, pageSize = 20) {
    this.query = query;
    this.pageSize = pageSize;
    this.currentPage = 0;
  }

  getPage(pageNumber) {
    const start = pageNumber * this.pageSize;
    const end = start + this.pageSize;
    
    return Array.from(this.query.slice(start, end));
  }

  getNextPage() {
    return this.getPage(++this.currentPage);
  }

  hasNextPage() {
    const start = (this.currentPage + 1) * this.pageSize;
    return start < this.query.length;
  }
}

// Efficient data loading
const efficientDataLoading = () => {
  // Use projections to load only needed fields
  const users = realm.objects('User').map(user => ({
    id: user.id,
    username: user.username,
    postCount: user.posts.length
  }));

  // Limit initial query
  const recentPosts = realm.objects('Post')
    .filtered('createdAt > $0', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000))
    .sorted('createdAt', true)
    .slice(0, 50);

  return { users, recentPosts };
};

// Index optimization
const optimizeIndexes = () => {
  // Indexes are defined in schema
  const OptimizedUserSchema = {
    name: 'User',
    primaryKey: 'id',
    properties: {
      id: 'string',
      username: { type: 'string', indexed: true },
      email: { type: 'string', indexed: true },
      createdAt: { type: 'date', indexed: true },
      // Compound indexes not directly supported
    }
  };
};

// Memory management
const memoryEfficientQueries = () => {
  // Use snapshots for large result sets
  const results = realm.objects('Post').snapshot();
  
  // Process in chunks
  const chunkSize = 100;
  for (let i = 0; i < results.length; i += chunkSize) {
    const chunk = results.slice(i, Math.min(i + chunkSize, results.length));
    processChunk(chunk);
  }
};

// Async operations
const asyncRealmOperations = async () => {
  // Write async
  await realm.writeAsync(async () => {
    // Async operations within transaction
    const userData = await fetchUserData();
    realm.create('User', userData);
  });

  // Background processing
  const backgroundQueue = new BackgroundQueue();
  
  backgroundQueue.addTask(async () => {
    const realm = await Realm.open(realmConfig);
    // Perform heavy operations
    realm.close();
  });
};</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>Realm Best Practices:</h4>
                <ul>
                    <li>Define clear schemas with proper relationships</li>
                    <li>Use primary keys for all objects</li>
                    <li>Index frequently queried properties</li>
                    <li>Avoid storing large binary data directly</li>
                    <li>Close Realm instances when not needed</li>
                    <li>Handle migrations carefully in production</li>
                    <li>Use transactions for multiple writes</li>
                    <li>Implement proper error handling</li>
                    <li>Monitor Realm file size</li>
                    <li>Use listeners efficiently (remove when done)</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Build a task management app with Realm:</p>
                <ul>
                    <li>Projects, tasks, and subtasks with relationships</li>
                    <li>Real-time sync across devices</li>
                    <li>Offline support with conflict resolution</li>
                    <li>Advanced filtering and sorting</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What makes Realm different from SQLite?",
            options: [
                "It uses SQL queries",
                "It's object-oriented and reactive",
                "It's smaller in size",
                "It doesn't support relationships"
            ],
            correct: 1,
            explanation: "Realm uses an object-oriented API with reactive queries, unlike SQLite's SQL-based approach."
        },
        {
            question: "How do you define a one-to-many relationship in Realm?",
            options: [
                "Using foreign keys",
                "Using linkingObjects",
                "Using JOIN queries",
                "It's not supported"
            ],
            correct: 1,
            explanation: "Realm uses linkingObjects to define inverse relationships for one-to-many connections."
        },
        {
            question: "What's the purpose of realm.write()?",
            options: [
                "To read data",
                "To create a transaction for modifications",
                "To sync with server",
                "To optimize queries"
            ],
            correct: 1,
            explanation: "realm.write() creates a transaction where all data modifications must occur to ensure consistency."
        }
    ],
    project: {

        title: "Task Management App with Realm",
        description: "Build a real-time task management app with projects, tasks, subtasks, and team collaboration",
        requirements: [
            "Design schemas for projects, tasks, and subtasks with relationships",
            "Implement real-time sync with Realm Sync",
            "Add offline support with conflict resolution",
            "Create reactive UI with Realm listeners",
            "Implement advanced filtering and sorting",
            "Add data migration for schema updates",
            "User authentication and permissions",
            "Task assignment and notifications"
        ],
        hints: [
            "Use linkingObjects for inverse relationships",
            "Implement optimistic UI with local writes",
            "Handle sync conflicts gracefully",
            "Use Realm notifications for real-time updates",
            "Partition data by team or project"
        ]
    }
},
'firebase': {
    content: `
        <div class="content-section">
            <h1>Firebase Integration</h1>
            
            <div class="info-box">
                <p>Firebase provides a comprehensive suite of backend services including real-time database, authentication, cloud storage, and more. Learn how to integrate Firebase services into your React Native app.</p>
            </div>

            <h2>Installation & Initial Setup</h2>
            <pre><code class="language-bash"># Install Firebase core
npm install @react-native-firebase/app

# Install specific Firebase services
npm install @react-native-firebase/auth
npm install @react-native-firebase/firestore
npm install @react-native-firebase/database
npm install @react-native-firebase/storage
npm install @react-native-firebase/messaging
npm install @react-native-firebase/analytics

# iOS setup
cd ios && pod install</code></pre>

            <h2>Firebase Configuration</h2>
            <pre><code class="language-javascript">// firebase.config.js
import { initializeApp } from '@react-native-firebase/app';
import auth from '@react-native-firebase/auth';
import firestore from '@react-native-firebase/firestore';
import database from '@react-native-firebase/database';
import storage from '@react-native-firebase/storage';
import messaging from '@react-native-firebase/messaging';
import analytics from '@react-native-firebase/analytics';

// Firebase configuration (from Firebase Console)
const firebaseConfig = {
  apiKey: "your-api-key",
  authDomain: "your-auth-domain",
  databaseURL: "your-database-url",
  projectId: "your-project-id",
  storageBucket: "your-storage-bucket",
  messagingSenderId: "your-messaging-sender-id",
  appId: "your-app-id",
  measurementId: "your-measurement-id"
};

// Initialize Firebase if not already initialized
if (!firebase.apps.length) {
  initializeApp(firebaseConfig);
}

// Export services
export {
  auth,
  firestore,
  database,
  storage,
  messaging,
  analytics
};</code></pre>

            <h2>Authentication</h2>
            <pre><code class="language-javascript">import auth from '@react-native-firebase/auth';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import { LoginManager, AccessToken } from 'react-native-fbsdk-next';

// Email/Password Authentication
export const signUpWithEmail = async (email, password) => {
  try {
    const userCredential = await auth().createUserWithEmailAndPassword(email, password);
    
    // Send verification email
    await userCredential.user.sendEmailVerification();
    
    // Update user profile
    await userCredential.user.updateProfile({
      displayName: email.split('@')[0]
    });
    
    return userCredential.user;
  } catch (error) {
    handleAuthError(error);
  }
};

export const signInWithEmail = async (email, password) => {
  try {
    const userCredential = await auth().signInWithEmailAndPassword(email, password);
    
    // Check if email is verified
    if (!userCredential.user.emailVerified) {
      throw new Error('Please verify your email before signing in');
    }
    
    return userCredential.user;
  } catch (error) {
    handleAuthError(error);
  }
};

// Google Sign-In
export const signInWithGoogle = async () => {
  try {
    // Configure Google Sign-In
    GoogleSignin.configure({
      webClientId: 'YOUR_WEB_CLIENT_ID',
    });

    // Get user ID token
    const { idToken } = await GoogleSignin.signIn();

    // Create Google credential
    const googleCredential = auth.GoogleAuthProvider.credential(idToken);

    // Sign in with credential
    return auth().signInWithCredential(googleCredential);
  } catch (error) {
    handleAuthError(error);
  }
};

// Facebook Sign-In
export const signInWithFacebook = async () => {
  try {
    // Login with permissions
    const result = await LoginManager.logInWithPermissions(['public_profile', 'email']);

    if (result.isCancelled) {
      throw new Error('User cancelled login');
    }

    // Get access token
    const data = await AccessToken.getCurrentAccessToken();

    if (!data) {
      throw new Error('Something went wrong obtaining access token');
    }

    // Create Facebook credential
    const facebookCredential = auth.FacebookAuthProvider.credential(data.accessToken);

    // Sign in with credential
    return auth().signInWithCredential(facebookCredential);
  } catch (error) {
    handleAuthError(error);
  }
};

// Phone Authentication
export const signInWithPhone = async (phoneNumber) => {
  try {
    const confirmation = await auth().signInWithPhoneNumber(phoneNumber);
    return confirmation;
  } catch (error) {
    handleAuthError(error);
  }
};

export const confirmPhoneCode = async (confirmation, code) => {
  try {
    const userCredential = await confirmation.confirm(code);
    return userCredential.user;
  } catch (error) {
    handleAuthError(error);
  }
};

// Auth State Management
export const useAuthState = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = auth().onAuthStateChanged((user) => {
      setUser(user);
      setLoading(false);
    });

    return unsubscribe;
  }, []);

  return { user, loading };
};

// Error handling
const handleAuthError = (error) => {
  switch (error.code) {
    case 'auth/email-already-in-use':
      throw new Error('Email is already registered');
    case 'auth/invalid-email':
      throw new Error('Invalid email address');
    case 'auth/weak-password':
      throw new Error('Password is too weak');
    case 'auth/user-not-found':
      throw new Error('User not found');
    case 'auth/wrong-password':
      throw new Error('Incorrect password');
    default:
      throw error;
  }
};</code></pre>

            <h2>Firestore Database</h2>
            <pre><code class="language-javascript">import firestore from '@react-native-firebase/firestore';

// Collection references
const usersCollection = firestore().collection('users');
const postsCollection = firestore().collection('posts');

// CREATE - Add document
export const createUser = async (userId, userData) => {
  try {
    await usersCollection.doc(userId).set({
      ...userData,
      createdAt: firestore.FieldValue.serverTimestamp(),
      updatedAt: firestore.FieldValue.serverTimestamp()
    });
  } catch (error) {
    console.error('Error creating user:', error);
    throw error;
  }
};

// CREATE - Add with auto-generated ID
export const createPost = async (postData) => {
  try {
    const docRef = await postsCollection.add({
      ...postData,
      views: 0,
      likes: [],
      createdAt: firestore.FieldValue.serverTimestamp()
    });
    
    return docRef.id;
  } catch (error) {
    console.error('Error creating post:', error);
    throw error;
  }
};

// READ - Get single document
export const getUser = async (userId) => {
  try {
    const doc = await usersCollection.doc(userId).get();
    
    if (!doc.exists) {
      throw new Error('User not found');
    }
    
    return {
      id: doc.id,
      ...doc.data()
    };
  } catch (error) {
    console.error('Error getting user:', error);
    throw error;
  }
};

// READ - Query documents
export const getPosts = async (filters = {}) => {
  try {
    let query = postsCollection;
    
    // Apply filters
    if (filters.authorId) {
      query = query.where('authorId', '==', filters.authorId);
    }
    
    if (filters.isPublished !== undefined) {
      query = query.where('isPublished', '==', filters.isPublished);
    }
    
    if (filters.tags && filters.tags.length > 0) {
      query = query.where('tags', 'array-contains-any', filters.tags);
    }
    
    // Ordering and limiting
    query = query.orderBy('createdAt', 'desc');
    
    if (filters.limit) {
      query = query.limit(filters.limit);
    }
    
    const snapshot = await query.get();
    
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
  } catch (error) {
    console.error('Error getting posts:', error);
    throw error;
  }
};

// READ - Real-time listener
export const subscribeToUserPosts = (userId, callback) => {
  return postsCollection
    .where('authorId', '==', userId)
    .orderBy('createdAt', 'desc')
    .onSnapshot(
      (snapshot) => {
        const posts = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
        callback(posts);
      },
      (error) => {
        console.error('Error listening to posts:', error);
      }
    );
};

// UPDATE - Update document
export const updatePost = async (postId, updates) => {
  try {
    await postsCollection.doc(postId).update({
      ...updates,
      updatedAt: firestore.FieldValue.serverTimestamp()
    });
  } catch (error) {
    console.error('Error updating post:', error);
    throw error;
  }
};

// UPDATE - Atomic operations
export const incrementPostViews = async (postId) => {
  try {
    await postsCollection.doc(postId).update({
      views: firestore.FieldValue.increment(1),
      lastViewedAt: firestore.FieldValue.serverTimestamp()
    });
  } catch (error) {
    console.error('Error incrementing views:', error);
    throw error;
  }
};

// UPDATE - Array operations
export const togglePostLike = async (postId, userId) => {
  try {
    const postRef = postsCollection.doc(postId);
    const post = await postRef.get();
    
    if (!post.exists) {
      throw new Error('Post not found');
    }
    
    const likes = post.data().likes || [];
    
    if (likes.includes(userId)) {
      // Remove like
      await postRef.update({
        likes: firestore.FieldValue.arrayRemove(userId)
      });
    } else {
      // Add like
      await postRef.update({
        likes: firestore.FieldValue.arrayUnion(userId)
      });
    }
  } catch (error) {
    console.error('Error toggling like:', error);
    throw error;
  }
};

// DELETE - Delete document
export const deletePost = async (postId) => {
  try {
    await postsCollection.doc(postId).delete();
  } catch (error) {
    console.error('Error deleting post:', error);
    throw error;
  }
};

// Batch operations
export const batchUpdatePosts = async (updates) => {
  const batch = firestore().batch();
  
  updates.forEach(({ postId, data }) => {
    const postRef = postsCollection.doc(postId);
    batch.update(postRef, {
      ...data,
      updatedAt: firestore.FieldValue.serverTimestamp()
    });
  });
  
  try {
    await batch.commit();
  } catch (error) {
    console.error('Batch update failed:', error);
    throw error;
  }
};

// Transactions
export const transferPostOwnership = async (postId, fromUserId, toUserId) => {
  try {
    await firestore().runTransaction(async (transaction) => {
      const postRef = postsCollection.doc(postId);
      const postDoc = await transaction.get(postRef);
      
      if (!postDoc.exists) {
        throw new Error('Post not found');
      }
      
      if (postDoc.data().authorId !== fromUserId) {
        throw new Error('Unauthorized transfer');
      }
      
      transaction.update(postRef, {
        authorId: toUserId,
        transferredAt: firestore.FieldValue.serverTimestamp()
      });
    });
  } catch (error) {
    console.error('Transfer failed:', error);
    throw error;
  }
};</code></pre>

            <h2>Realtime Database</h2>
            <pre><code class="language-javascript">import database from '@react-native-firebase/database';

// Reference to database
const dbRef = database().ref();

// CREATE - Push new data
export const createChatMessage = async (chatId, message) => {
  try {
    const messageRef = database()
      .ref(\`chats/\${chatId}/messages\`)
      .push();
    
    await messageRef.set({
      ...message,
      timestamp: database.ServerValue.TIMESTAMP
    });
    
    return messageRef.key;
  } catch (error) {
    console.error('Error sending message:', error);
    throw error;
  }
};

// READ - Get data once
export const getChatMessages = async (chatId, limit = 50) => {
  try {
    const snapshot = await database()
      .ref(\`chats/\${chatId}/messages\`)
      .orderByChild('timestamp')
      .limitToLast(limit)
      .once('value');
    
    const messages = [];
    snapshot.forEach((child) => {
      messages.push({
        id: child.key,
        ...child.val()
      });
    });
    
    return messages.reverse();
  } catch (error) {
    console.error('Error getting messages:', error);
    throw error;
  }
};

// READ - Real-time listener
export const subscribeToChatMessages = (chatId, callback) => {
  const messagesRef = database()
    .ref(\`chats/\${chatId}/messages\`)
    .orderByChild('timestamp')
    .limitToLast(100);
  
  messagesRef.on('value', (snapshot) => {
    const messages = [];
    snapshot.forEach((child) => {
      messages.push({
        id: child.key,
        ...child.val()
      });
    });
    callback(messages.reverse());
  });
  
  // Return unsubscribe function
  return () => messagesRef.off();
};

// UPDATE - Update specific fields
export const updateUserStatus = async (userId, isOnline) => {
  try {
    const updates = {
      [\`users/\${userId}/isOnline\`]: isOnline,
      [\`users/\${userId}/lastSeen\`]: database.ServerValue.TIMESTAMP
    };
    
    await database().ref().update(updates);
  } catch (error) {
    console.error('Error updating status:', error);
    throw error;
  }
};

// DELETE - Remove data
export const deleteChatMessage = async (chatId, messageId) => {
  try {
    await database()
      .ref(\`chats/\${chatId}/messages/\${messageId}\`)
      .remove();
  } catch (error) {
    console.error('Error deleting message:', error);
    throw error;
  }
};

// Presence system
export const setupPresence = (userId) => {
  const userStatusRef = database().ref(\`users/\${userId}/status\`);
  
  // Set online
  database()
    .ref('.info/connected')
    .on('value', async (snapshot) => {
      if (snapshot.val() === false) {
        return;
      }
      
      await userStatusRef.onDisconnect().set({
        isOnline: false,
        lastSeen: database.ServerValue.TIMESTAMP
      });
      
      await userStatusRef.set({
        isOnline: true,
        lastSeen: database.ServerValue.TIMESTAMP
      });
    });
};

// Offline persistence
database().setPersistenceEnabled(true);
database().setPersistenceCacheSizeBytes(10000000); // 10MB</code></pre>

            <h2>Cloud Storage</h2>
            <pre><code class="language-javascript">import storage from '@react-native-firebase/storage';

// Upload file
export const uploadFile = async (uri, path, onProgress) => {
  try {
    const reference = storage().ref(path);
    
    // Create upload task
    const task = reference.putFile(uri);
    
    // Monitor progress
    task.on('state_changed', (snapshot) => {
      const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
      
      if (onProgress) {
        onProgress(progress);
      }
      
      console.log(\`Upload is \${progress}% done\`);
    });
    
    // Wait for upload to complete
    await task;
    
    // Get download URL
    const downloadURL = await reference.getDownloadURL();
    
    return downloadURL;
  } catch (error) {
    console.error('Upload failed:', error);
    throw error;
  }
};

// Upload with metadata
export const uploadImage = async (imageUri, userId) => {
  const filename = \`images/\${userId}/\${Date.now()}.jpg\`;
  const reference = storage().ref(filename);
  
  // Set metadata
  const metadata = {
    contentType: 'image/jpeg',
    customMetadata: {
      userId: userId,
      uploadedAt: new Date().toISOString()
    }
  };
  
  try {
    await reference.putFile(imageUri, metadata);
    const downloadURL = await reference.getDownloadURL();
    
    return {
      url: downloadURL,
      path: filename,
      metadata
    };
  } catch (error) {
    console.error('Image upload failed:', error);
    throw error;
  }
};

// Download file
export const downloadFile = async (url, localPath) => {
  try {
    const reference = storage().refFromURL(url);
    await reference.writeToFile(localPath);
    
    console.log('File downloaded to:', localPath);
    return localPath;
  } catch (error) {
    console.error('Download failed:', error);
    throw error;
  }
};

// Delete file
export const deleteFile = async (path) => {
  try {
    const reference = storage().ref(path);
    await reference.delete();
    
    console.log('File deleted successfully');
  } catch (error) {
    console.error('Delete failed:', error);
    throw error;
  }
};

// List files
export const listUserFiles = async (userId, maxResults = 20) => {
  try {
    const reference = storage().ref(\`images/\${userId}\`);
    const result = await reference.list({ maxResults });
    
    const files = await Promise.all(
      result.items.map(async (item) => ({
        name: item.name,
        path: item.fullPath,
        url: await item.getDownloadURL(),
        metadata: await item.getMetadata()
      }))
    );
    
    return {
      files,
      nextPageToken: result.nextPageToken
    };
  } catch (error) {
    console.error('List files failed:', error);
    throw error;
  }
};</code></pre>

            <h2>Cloud Messaging (Push Notifications)</h2>
            <pre><code class="language-javascript">import messaging from '@react-native-firebase/messaging';
import notifee from '@notifee/react-native';

// Request permission
export const requestNotificationPermission = async () => {
  const authStatus = await messaging().requestPermission();
  const enabled =
    authStatus === messaging.AuthorizationStatus.AUTHORIZED ||
    authStatus === messaging.AuthorizationStatus.PROVISIONAL;

  if (enabled) {
    console.log('Authorization status:', authStatus);
  }

  return enabled;
};

// Get FCM token
export const getFCMToken = async () => {
  try {
    const token = await messaging().getToken();
    console.log('FCM Token:', token);
    
    // Save token to backend
    await saveTokenToBackend(token);
    
    return token;
  } catch (error) {
    console.error('Failed to get FCM token:', error);
    throw error;
  }
};

// Token refresh listener
export const setupTokenRefreshListener = () => {
  return messaging().onTokenRefresh(async (token) => {
    console.log('FCM Token refreshed:', token);
    await saveTokenToBackend(token);
  });
};

// Message handlers
export const setupMessageHandlers = () => {
  // Background message handler
  messaging().setBackgroundMessageHandler(async (remoteMessage) => {
    console.log('Background message:', remoteMessage);
    
    // Display notification using notifee
    await displayNotification(remoteMessage);
  });

  // Foreground message handler
  const unsubscribe = messaging().onMessage(async (remoteMessage) => {
    console.log('Foreground message:', remoteMessage);
    
    // Display notification
    await displayNotification(remoteMessage);
  });

  return unsubscribe;
};

// Display notification with notifee
const displayNotification = async (remoteMessage) => {
  // Create a channel
  const channelId = await notifee.createChannel({
    id: 'default',
    name: 'Default Channel',
    importance: notifee.AndroidImportance.HIGH,
  });

  // Display notification
  await notifee.displayNotification({
    title: remoteMessage.notification?.title,
    body: remoteMessage.notification?.body,
    data: remoteMessage.data,
    android: {
      channelId,
      smallIcon: 'ic_launcher',
      pressAction: {
        id: 'default',
      },
    },
    ios: {
      sound: 'default',
      badge: 1,
    },
  });
};

// Handle notification interactions
export const setupNotificationHandlers = () => {
  // When app opened from notification
  messaging()
    .getInitialNotification()
    .then((remoteMessage) => {
      if (remoteMessage) {
        console.log('App opened from notification:', remoteMessage);
        handleNotificationOpen(remoteMessage);
      }
    });

  // When app in background and opened
  messaging().onNotificationOpenedApp((remoteMessage) => {
    console.log('App opened from background:', remoteMessage);
    handleNotificationOpen(remoteMessage);
  });
};

// Topic subscription
export const subscribeToTopic = async (topic) => {
  try {
    await messaging().subscribeToTopic(topic);
    console.log(\`Subscribed to topic: \${topic}\`);
  } catch (error) {
    console.error('Topic subscription failed:', error);
    throw error;
  }
};

// Send notification (from backend)
const sendNotificationExample = \`
// Backend code (Node.js)
const admin = require('firebase-admin');

const message = {
  notification: {
    title: 'New Message',
    body: 'You have a new message!'
  },
  data: {
    type: 'chat',
    chatId: '12345'
  },
  token: userFCMToken,
  // or topic: 'news'
};

admin.messaging().send(message)
  .then((response) => {
    console.log('Successfully sent message:', response);
  })
  .catch((error) => {
    console.log('Error sending message:', error);
  });
\`;</code></pre>

            <h2>Analytics</h2>
            <pre><code class="language-javascript">import analytics from '@react-native-firebase/analytics';

// Log custom events
export const logEvent = async (eventName, parameters = {}) => {
  try {
    await analytics().logEvent(eventName, parameters);
  } catch (error) {
    console.error('Analytics error:', error);
  }
};

// Screen tracking
export const logScreenView = async (screenName, screenClass) => {
  try {
    await analytics().logScreenView({
      screen_name: screenName,
      screen_class: screenClass
    });
  } catch (error) {
    console.error('Screen tracking error:', error);
  }
};

// User properties
export const setUserProperties = async (properties) => {
  try {
    for (const [key, value] of Object.entries(properties)) {
      await analytics().setUserProperty(key, value);
    }
  } catch (error) {
    console.error('User properties error:', error);
  }
};

// E-commerce events
export const logPurchase = async (value, currency, items) => {
  try {
    await analytics().logPurchase({
      value: value,
      currency: currency,
      items: items
    });
  } catch (error) {
    console.error('Purchase tracking error:', error);
  }
};

// Custom event examples
export const trackUserEngagement = async (action, category, label, value) => {
  await logEvent('user_engagement', {
    action,
    category,
    label,
    value
  });
};

// React Navigation integration
export const getActiveRouteName = (state) => {
  const route = state.routes[state.index];
  
  if (route.state) {
    return getActiveRouteName(route.state);
  }
  
  return route.name;
};

export const navigationTracking = (navigationRef) => {
  const routeNameRef = useRef();

  return () => {
    const previousRouteName = routeNameRef.current;
    const currentRouteName = getActiveRouteName(navigationRef.current.getRootState());

    if (previousRouteName !== currentRouteName) {
      logScreenView(currentRouteName, currentRouteName);
    }

    routeNameRef.current = currentRouteName;
  };
};</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>Firebase Best Practices:</h4>
                <ul>
                    <li>Configure security rules properly for all services</li>
                    <li>Use batch operations for multiple writes</li>
                    <li>Implement proper error handling and retry logic</li>
                    <li>Enable offline persistence for better UX</li>
                    <li>Optimize queries with indexes</li>
                    <li>Use Cloud Functions for complex operations</li>
                    <li>Monitor usage and costs in Firebase Console</li>
                    <li>Implement proper authentication flows</li>
                    <li>Cache frequently accessed data</li>
                    <li>Use appropriate data structure for your use case</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Build a social media app with Firebase:</p>
                <ul>
                    <li>User authentication with multiple providers</li>
                    <li>Real-time feed with Firestore</li>
                    <li>Image uploads with Cloud Storage</li>
                    <li>Push notifications for interactions</li>
                    <li>Analytics tracking</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the difference between Firestore and Realtime Database?",
            options: [
                "No difference",
                "Firestore is document-based, Realtime is JSON tree",
                "Realtime is newer",
                "Firestore doesn't support offline"
            ],
            correct: 1,
            explanation: "Firestore uses a document-collection model while Realtime Database stores data as a large JSON tree."
        },
        {
            question: "How do you handle offline data in Firestore?",
            options: [
                "It's not supported",
                "Enable persistence with firestore().settings()",
                "Use AsyncStorage",
                "It's enabled by default"
            ],
            correct: 3,
            explanation: "Firestore offline persistence is enabled by default in React Native, automatically caching data for offline use."
        },
        {
            question: "What's required for push notifications on iOS?",
            options: [
                "Nothing special",
                "APNs certificates and capabilities",
                "Only Firebase config",
                "Just request permission"
            ],
            correct: 1,
            explanation: "iOS requires Apple Push Notification service (APNs) certificates and enabling push notification capabilities in Xcode."
        }
    ],
    project: {
        title: "Social Media App with Firebase",
        description: "Build a full-featured social media app with real-time feeds, messaging, and media sharing",
        requirements: [
            "User authentication with multiple providers",
            "Real-time feed with Firestore",
            "Direct messaging with Realtime Database",
            "Image and video uploads with Cloud Storage",
            "Push notifications for interactions",
            "User profiles and following system",
            "Content moderation with Cloud Functions",
            "Analytics tracking for engagement"
        ],
        hints: [
            "Use Firestore for structured data",
            "Implement pagination for feeds",
            "Compress images before upload",
            "Cache user data locally",
            "Use security rules to protect data",
            "Implement presence system for online status"
        ]
    }
},
'graphql': {
    content: `
        <div class="content-section">
            <h1>GraphQL with Apollo</h1>
            
            <div class="info-box">
                <p>GraphQL is a query language for APIs that provides a more efficient and flexible alternative to REST. Apollo Client is a comprehensive GraphQL client with caching, error handling, and React integration.</p>
            </div>

            <h2>Installation & Setup</h2>
            <pre><code class="language-bash"># Install Apollo Client and GraphQL
npm install @apollo/client graphql

# Additional dependencies for React Native
npm install @react-native-async-storage/async-storage

# For subscriptions (optional)
npm install subscriptions-transport-ws

# For file uploads (optional)
npm install apollo-upload-client</code></pre>

            <h2>Apollo Client Configuration</h2>
            <pre><code class="language-javascript">import {
  ApolloClient,
  InMemoryCache,
  ApolloProvider,
  createHttpLink,
  split
} from '@apollo/client';
import { setContext } from '@apollo/client/link/context';
import { onError } from '@apollo/client/link/error';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getMainDefinition } from '@apollo/client/utilities';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { persistCache } from 'apollo3-cache-persist';

// HTTP connection to the API
const httpLink = createHttpLink({
  uri: 'https://api.example.com/graphql',
});

// WebSocket link for subscriptions
const wsLink = new WebSocketLink({
  uri: 'wss://api.example.com/graphql',
  options: {
    reconnect: true,
    connectionParams: async () => {
      const token = await AsyncStorage.getItem('authToken');
      return {
        authorization: token ? \`Bearer \${token}\` : '',
      };
    },
  },
});

// Authentication link
const authLink = setContext(async (_, { headers }) => {
  const token = await AsyncStorage.getItem('authToken');
  
  return {
    headers: {
      ...headers,
      authorization: token ? \`Bearer \${token}\` : '',
    },
  };
});

// Error handling link
const errorLink = onError(({ graphQLErrors, networkError, operation, forward }) => {
  if (graphQLErrors) {
    graphQLErrors.forEach(({ message, locations, path }) => {
      console.error(
        \`GraphQL error: Message: \${message}, Location: \${locations}, Path: \${path}\`
      );
    });
  }

  if (networkError) {
    console.error(\`Network error: \${networkError}\`);
    
    // Handle token expiration
    if (networkError.statusCode === 401) {
      // Refresh token logic
      return refreshToken().then(() => forward(operation));
    }
  }
});

// Split links based on operation type
const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  authLink.concat(httpLink),
);

// Create the Apollo Client
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        posts: {
          keyArgs: ['filter'],
          merge(existing = [], incoming) {
            return [...existing, ...incoming];
          },
        },
      },
    },
    Post: {
      keyFields: ['id'],
    },
  },
});

// Persist cache
const initializeApollo = async () => {
  await persistCache({
    cache,
    storage: AsyncStorage,
    maxSize: false, // unlimited
    debug: __DEV__,
  });

  const client = new ApolloClient({
    link: errorLink.concat(splitLink),
    cache,
    defaultOptions: {
      watchQuery: {
        fetchPolicy: 'cache-and-network',
      },
    },
  });

  return client;
};

// App wrapper
export const App = () => {
  const [client, setClient] = useState(null);

  useEffect(() => {
    initializeApollo().then(setClient);
  }, []);

  if (!client) {
    return <LoadingScreen />;
  }

  return (
    <ApolloProvider client={client}>
      <YourApp />
    </ApolloProvider>
  );
};</code></pre>

            <h2>GraphQL Queries</h2>
            <pre><code class="language-javascript">import { gql, useQuery, useLazyQuery } from '@apollo/client';

// Define queries
const GET_USER = gql\`
  query GetUser($id: ID!) {
    user(id: $id) {
      id
      username
      email
      avatar
      posts {
        id
        title
        createdAt
      }
      followers {
        id
        username
      }
    }
  }
\`;

const SEARCH_POSTS = gql\`
  query SearchPosts($searchTerm: String!, $limit: Int, $offset: Int) {
    searchPosts(searchTerm: $searchTerm, limit: $limit, offset: $offset) {
      posts {
        id
        title
        content
        author {
          id
          username
          avatar
        }
        tags
        likes
        createdAt
      }
      totalCount
      hasMore
    }
  }
\`;

// Using queries in components
const UserProfile = ({ userId }) => {
  const { loading, error, data, refetch } = useQuery(GET_USER, {
    variables: { id: userId },
    fetchPolicy: 'cache-first',
    notifyOnNetworkStatusChange: true,
  });

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <View>
      <Text>{data.user.username}</Text>
      <Avatar source={{ uri: data.user.avatar }} />
      <TouchableOpacity onPress={() => refetch()}>
        <Text>Refresh</Text>
      </TouchableOpacity>
    </View>
  );
};

// Lazy query for on-demand fetching
const SearchScreen = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const [searchPosts, { loading, data, error, fetchMore }] = useLazyQuery(
    SEARCH_POSTS,
    {
      fetchPolicy: 'network-only',
    }
  );

  const handleSearch = () => {
    searchPosts({
      variables: {
        searchTerm,
        limit: 20,
        offset: 0,
      },
    });
  };

  const loadMore = () => {
    if (!data?.searchPosts.hasMore || loading) return;

    fetchMore({
      variables: {
        offset: data.searchPosts.posts.length,
      },
      updateQuery: (prev, { fetchMoreResult }) => {
        if (!fetchMoreResult) return prev;

        return {
          searchPosts: {
            ...fetchMoreResult.searchPosts,
            posts: [
              ...prev.searchPosts.posts,
              ...fetchMoreResult.searchPosts.posts,
            ],
          },
        };
      },
    });
  };

  return (
    <View>
      <TextInput
        value={searchTerm}
        onChangeText={setSearchTerm}
        onSubmitEditing={handleSearch}
      />
      <FlatList
        data={data?.searchPosts.posts || []}
        renderItem={({ item }) => <PostCard post={item} />}
        onEndReached={loadMore}
        onEndReachedThreshold={0.5}
      />
    </View>
  );
};</code></pre>

            <h2>GraphQL Mutations</h2>
            <pre><code class="language-javascript">import { gql, useMutation } from '@apollo/client';

// Define mutations
const CREATE_POST = gql\`
  mutation CreatePost($input: CreatePostInput!) {
    createPost(input: $input) {
      id
      title
      content
      author {
        id
        username
      }
      createdAt
    }
  }
\`;

const UPDATE_USER_PROFILE = gql\`
  mutation UpdateUserProfile($id: ID!, $input: UpdateUserInput!) {
    updateUser(id: $id, input: $input) {
      id
      username
      email
      bio
      avatar
    }
  }
\`;

const DELETE_POST = gql\`
  mutation DeletePost($id: ID!) {
    deletePost(id: $id) {
      success
      message
    }
  }
\`;

// Using mutations in components
const CreatePostForm = () => {
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  
  const [createPost, { loading, error }] = useMutation(CREATE_POST, {
    onCompleted: (data) => {
      console.log('Post created:', data.createPost);
      navigation.navigate('Post', { postId: data.createPost.id });
    },
    onError: (error) => {
      Alert.alert('Error', error.message);
    },
    update: (cache, { data: { createPost } }) => {
      // Update cache manually
      const existingPosts = cache.readQuery({
        query: GET_USER_POSTS,
        variables: { userId: currentUser.id },
      });

      cache.writeQuery({
        query: GET_USER_POSTS,
        variables: { userId: currentUser.id },
        data: {
          userPosts: [createPost, ...existingPosts.userPosts],
        },
      });
    },
    // Optimistic response
    optimisticResponse: {
      createPost: {
        __typename: 'Post',
        id: 'temp-id',
        title,
        content,
        author: {
          __typename: 'User',
          id: currentUser.id,
          username: currentUser.username,
        },
        createdAt: new Date().toISOString(),
      },
    },
  });

  const handleSubmit = async () => {
    try {
      await createPost({
        variables: {
          input: {
            title,
            content,
            tags: extractTags(content),
          },
        },
      });
    } catch (err) {
      // Error handled by onError
    }
  };

  return (
    <View>
      <TextInput
        placeholder="Title"
        value={title}
        onChangeText={setTitle}
      />
      <TextInput
        placeholder="Content"
        value={content}
        onChangeText={setContent}
        multiline
      />
      <Button
        title="Create Post"
        onPress={handleSubmit}
        disabled={loading || !title || !content}
      />
    </View>
  );
};

// Batch mutations
const BATCH_DELETE_POSTS = gql\`
  mutation BatchDeletePosts($ids: [ID!]!) {
    batchDeletePosts(ids: $ids) {
      deletedCount
      deletedIds
    }
  }
\`;

const useBatchDelete = () => {
  const [batchDelete] = useMutation(BATCH_DELETE_POSTS, {
    update: (cache, { data: { batchDeletePosts } }) => {
      // Remove deleted posts from cache
      batchDeletePosts.deletedIds.forEach(id => {
        cache.evict({ id: \`Post:\${id}\` });
      });
      cache.gc();
    },
  });

  return batchDelete;
};</code></pre>

            <h2>GraphQL Subscriptions</h2>
            <pre><code class="language-javascript">import { gql, useSubscription } from '@apollo/client';

// Define subscriptions
const MESSAGE_SUBSCRIPTION = gql\`
  subscription OnMessageAdded($chatId: ID!) {
    messageAdded(chatId: $chatId) {
      id
      content
      user {
        id
        username
        avatar
      }
      createdAt
    }
  }
\`;

const USER_STATUS_SUBSCRIPTION = gql\`
  subscription OnUserStatusChanged($userId: ID!) {
    userStatusChanged(userId: $userId) {
      userId
      isOnline
      lastSeen
    }
  }
\`;

// Using subscriptions in components
const ChatRoom = ({ chatId }) => {
  const [messages, setMessages] = useState([]);

  // Subscribe to new messages
  const { data, loading } = useSubscription(MESSAGE_SUBSCRIPTION, {
    variables: { chatId },
    onSubscriptionData: ({ subscriptionData }) => {
      if (subscriptionData.data) {
        setMessages(prev => [
          ...prev,
          subscriptionData.data.messageAdded,
        ]);
      }
    },
  });

  // Query existing messages
  const { data: existingMessages } = useQuery(GET_CHAT_MESSAGES, {
    variables: { chatId },
    onCompleted: (data) => {
      setMessages(data.chatMessages);
    },
  });

  return (
    <FlatList
      data={messages}
      renderItem={({ item }) => <MessageBubble message={item} />}
      inverted
    />
  );
};

// Complex subscription with multiple events
const CHAT_EVENTS_SUBSCRIPTION = gql\`
  subscription OnChatEvent($chatId: ID!) {
    chatEvent(chatId: $chatId) {
      __typename
      ... on MessageAdded {
        message {
          id
          content
          user {
            id
            username
          }
        }
      }
      ... on UserJoined {
        user {
          id
          username
        }
        joinedAt
      }
      ... on UserLeft {
        userId
        leftAt
      }
      ... on UserTyping {
        userId
        isTyping
      }
    }
  }
\`;

const useChatSubscription = (chatId) => {
  const [typingUsers, setTypingUsers] = useState(new Set());

  useSubscription(CHAT_EVENTS_SUBSCRIPTION, {
    variables: { chatId },
    onSubscriptionData: ({ subscriptionData }) => {
      const event = subscriptionData.data?.chatEvent;
      
      switch (event.__typename) {
        case 'MessageAdded':
          // Handle new message
          break;
        case 'UserTyping':
          setTypingUsers(prev => {
            const newSet = new Set(prev);
            if (event.isTyping) {
              newSet.add(event.userId);
            } else {
              newSet.delete(event.userId);
            }
            return newSet;
          });
          break;
        // Handle other events
      }
    },
  });

  return { typingUsers };
};</code></pre>

            <h2>Advanced Caching</h2>
            <pre><code class="language-javascript">import { makeVar, useReactiveVar } from '@apollo/client';

// Reactive variables for local state
export const isLoggedInVar = makeVar(false);
export const cartItemsVar = makeVar([]);

// Type policies for custom caching behavior
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        isLoggedIn: {
          read() {
            return isLoggedInVar();
          },
        },
        cartItems: {
          read() {
            return cartItemsVar();
          },
        },
        posts: {
          keyArgs: ['filter', 'sort'],
          merge(existing = { posts: [], hasMore: true }, incoming) {
            return {
              ...incoming,
              posts: [...existing.posts, ...incoming.posts],
            };
          },
        },
      },
    },
    User: {
      fields: {
        fullName: {
          read(_, { readField }) {
            const firstName = readField('firstName');
            const lastName = readField('lastName');
            return \`\${firstName} \${lastName}\`;
          },
        },
      },
    },
    Post: {
      fields: {
        isLiked: {
          read(_, { readField, toReference }) {
            const currentUserId = isLoggedInVar() ? currentUser.id : null;
            const likes = readField('likes') || [];
            return likes.some(like => 
              readField('id', toReference(like)) === currentUserId
            );
          },
        },
      },
    },
  },
});

// Custom hooks for reactive variables
export const useAuth = () => {
  const isLoggedIn = useReactiveVar(isLoggedInVar);
  
  const login = (token) => {
    AsyncStorage.setItem('authToken', token);
    isLoggedInVar(true);
  };
  
  const logout = () => {
    AsyncStorage.removeItem('authToken');
    isLoggedInVar(false);
    client.clearStore();
  };
  
  return { isLoggedIn, login, logout };
};

// Manual cache updates
const updatePostInCache = (postId, updates) => {
  const id = \`Post:\${postId}\`;
  
  cache.modify({
    id,
    fields: {
      likes(existingLikes = []) {
        return updates.liked
          ? [...existingLikes, { __ref: \`User:\${currentUser.id}\` }]
          : existingLikes.filter(
              ref => ref.__ref !== \`User:\${currentUser.id}\`
            );
      },
      likesCount(existingCount) {
        return existingCount + (updates.liked ? 1 : -1);
      },
    },
  });
};

// Optimistic updates with rollback
const [likePost] = useMutation(LIKE_POST, {
  optimisticResponse: {
    likePost: {
      __typename: 'Post',
      id: postId,
      liked: true,
      likesCount: post.likesCount + 1,
    },
  },
  update: (cache, { data }) => {
    if (!data) return; // Rollback on error
    
    updatePostInCache(postId, { liked: data.likePost.liked });
  },
});</code></pre>

            <h2>Error Handling & Loading States</h2>
            <pre><code class="language-javascript">// Custom error handling hook
const useErrorHandler = () => {
  const handleError = (error) => {
    if (error.networkError) {
      Alert.alert(
        'Network Error',
        'Please check your internet connection',
        [{ text: 'OK' }]
      );
    } else if (error.graphQLErrors?.length > 0) {
      const message = error.graphQLErrors[0].message;
      Alert.alert('Error', message);
    } else {
      Alert.alert('Error', 'An unexpected error occurred');
    }
  };

  return { handleError };
};

// Loading component with skeleton
const PostListWithLoading = () => {
  const { loading, error, data, refetch, networkStatus } = useQuery(
    GET_POSTS,
    {
      notifyOnNetworkStatusChange: true,
      errorPolicy: 'all',
    }
  );

  const isRefetching = networkStatus === NetworkStatus.refetch;

  if (loading && !data) {
    return <PostListSkeleton />;
  }

  if (error && !data) {
    return (
      <ErrorView
        error={error}
        onRetry={refetch}
      />
    );
  }

  return (
    <FlatList
      data={data?.posts || []}
      renderItem={({ item }) => <PostItem post={item} />}
      refreshControl={
        <RefreshControl
          refreshing={isRefetching}
          onRefresh={refetch}
        />
      }
      ListEmptyComponent={<EmptyState />}
    />
  );
};

// Polling and refetching
const LiveDataComponent = () => {
  const { data, startPolling, stopPolling } = useQuery(
    GET_LIVE_DATA,
    {
      pollInterval: 0, // Start with polling disabled
    }
  );

  useEffect(() => {
    // Start polling when component is visible
    startPolling(5000); // Poll every 5 seconds

    return () => {
      stopPolling();
    };
  }, [startPolling, stopPolling]);

  return <DataDisplay data={data} />;
};</code></pre>

            <h2>File Uploads</h2>
            <pre><code class="language-javascript">import { createUploadLink } from 'apollo-upload-client';

// Configure upload link
const uploadLink = createUploadLink({
  uri: 'https://api.example.com/graphql',
});

// Upload mutation
const UPLOAD_AVATAR = gql\`
  mutation UploadAvatar($file: Upload!) {
    uploadAvatar(file: $file) {
      url
      filename
      mimetype
      size
    }
  }
\`;

// Upload component
const AvatarUpload = () => {
  const [uploadAvatar, { loading }] = useMutation(UPLOAD_AVATAR);

  const handleImagePick = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 0.8,
    });

    if (!result.cancelled) {
      const file = new ReactNativeFile({
        uri: result.uri,
        type: 'image/jpeg',
        name: 'avatar.jpg',
      });

      try {
        const { data } = await uploadAvatar({
          variables: { file },
        });
        
        console.log('Upload successful:', data.uploadAvatar);
      } catch (error) {
        console.error('Upload failed:', error);
      }
    }
  };

  return (
    <TouchableOpacity onPress={handleImagePick} disabled={loading}>
      <Text>{loading ? 'Uploading...' : 'Change Avatar'}</Text>
    </TouchableOpacity>
  );
};</code></pre>

            <h2>Testing GraphQL</h2>
            <pre><code class="language-javascript">import { MockedProvider } from '@apollo/client/testing';
import { render, waitFor } from '@testing-library/react-native';

// Mock data
const mocks = [
  {
    request: {
      query: GET_USER,
      variables: { id: '1' },
    },
    result: {
      data: {
        user: {
          id: '1',
          username: 'testuser',
          email: 'test@example.com',
          avatar: 'https://example.com/avatar.jpg',
          posts: [],
          followers: [],
        },
      },
    },
  },
];

// Test component
describe('UserProfile', () => {
  it('renders user data', async () => {
    const { getByText } = render(
      <MockedProvider mocks={mocks} addTypename={false}>
        <UserProfile userId="1" />
      </MockedProvider>
    );

    // Wait for loading to finish
    await waitFor(() => {
      expect(getByText('testuser')).toBeTruthy();
    });
  });

  it('handles errors', async () => {
    const errorMocks = [
      {
        request: {
          query: GET_USER,
          variables: { id: '1' },
        },
        error: new Error('User not found'),
      },
    ];

    const { getByText } = render(
      <MockedProvider mocks={errorMocks} addTypename={false}>
        <UserProfile userId="1" />
      </MockedProvider>
    );

    await waitFor(() => {
      expect(getByText(/error/i)).toBeTruthy();
    });
  });
});</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>GraphQL/Apollo Best Practices:</h4>
                <ul>
                    <li>Use fragments to share fields between queries</li>
                    <li>Implement proper error boundaries</li>
                    <li>Cache normalized data efficiently</li>
                    <li>Use optimistic UI for better UX</li>
                    <li>Batch queries when possible</li>
                    <li>Implement proper pagination strategies</li>
                    <li>Use TypeScript with generated types</li>
                    <li>Monitor query performance</li>
                    <li>Handle loading and error states consistently</li>
                    <li>Clean up subscriptions on unmount</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Build a real-time chat app with GraphQL:</p>
                <ul>
                    <li>User authentication with JWT</li>
                    <li>Real-time messages with subscriptions</li>
                    <li>Typing indicators</li>
                    <li>Optimistic UI updates</li>
                    <li>Offline support with cache persistence</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the main advantage of GraphQL over REST?",
            options: [
                "It's faster",
                "Request exactly what you need",
                "Better security",
                "Simpler to implement"
            ],
            correct: 1,
            explanation: "GraphQL allows clients to request exactly the data they need, avoiding over-fetching or under-fetching."
        },
        {
            question: "What does Apollo Client's cache do?",
            options: [
                "Stores queries as strings",
                "Normalizes and stores data",
                "Only caches images",
                "Requires manual management"
            ],
            correct: 1,
            explanation: "Apollo Client normalizes and caches query results, automatically updating the UI when cached data changes."
        },
        {
            question: "When should you use subscriptions?",
            options: [
                "For all queries",
                "For real-time updates",
                "Only for mutations",
                "Never in mobile apps"
            ],
            correct: 1,
            explanation: "GraphQL subscriptions are ideal for real-time updates like chat messages, live data, or status changes."
        }
    ],
    project: {
        title: "Real-time Collaboration App with GraphQL",
        description: "Build a collaborative workspace app with real-time updates, document editing, and team chat",
        requirements: [
            "User authentication with JWT tokens",
            "Real-time document collaboration",
            "Team chat with typing indicators",
            "File sharing and comments",
            "Activity feed with subscriptions",
            "Offline support with cache persistence",
            "Optimistic UI for all mutations",
            "Search across documents and messages"
        ],
        hints: [
            "Use subscriptions for real-time features",
            "Implement proper cache normalization",
            "Handle connection state changes",
            "Use fragments to avoid duplication",
            "Batch queries when possible",
            "Implement cursor-based pagination"
        ]
    }
},
'offline-sync': {
    content: `
        <div class="content-section">
            <h1>Offline Data Sync</h1>
            
            <div class="info-box">
                <p>Learn how to implement robust offline capabilities with data synchronization. Handle network changes, queue operations, resolve conflicts, and ensure data consistency across online and offline states.</p>
            </div>

            <h2>Network State Detection</h2>
            <pre><code class="language-javascript">import NetInfo from '@react-native-community/netinfo';
import { EventEmitter } from 'events';

// Network state manager
class NetworkManager extends EventEmitter {
  constructor() {
    super();
    this.isConnected = true;
    this.connectionType = 'unknown';
    this.connectionDetails = null;
    this.listeners = new Map();
  }

  initialize() {
    // Subscribe to network state updates
    this.unsubscribe = NetInfo.addEventListener(state => {
      const wasConnected = this.isConnected;
      this.isConnected = state.isConnected;
      this.connectionType = state.type;
      this.connectionDetails = state.details;

      // Emit events
      this.emit('connectionChange', state);

      if (!wasConnected && this.isConnected) {
        this.emit('online');
      } else if (wasConnected && !this.isConnected) {
        this.emit('offline');
      }

      // Log network quality
      if (state.type === 'cellular') {
        console.log('Cellular generation:', state.details.cellularGeneration);
      }
    });

    // Get initial state
    NetInfo.fetch().then(state => {
      this.isConnected = state.isConnected;
      this.connectionType = state.type;
      this.connectionDetails = state.details;
    });
  }

  cleanup() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }

  // Check if we have a good connection for sync
  isGoodConnection() {
    if (!this.isConnected) return false;
    
    // Don't sync on expensive connections unless user preference
    if (this.connectionType === 'cellular') {
      const generation = this.connectionDetails?.cellularGeneration;
      return generation === '4g' || generation === '5g';
    }
    
    return true;
  }
}

export const networkManager = new NetworkManager();

// React hook for network state
export const useNetworkState = () => {
  const [isOnline, setIsOnline] = useState(networkManager.isConnected);
  const [connectionType, setConnectionType] = useState(networkManager.connectionType);

  useEffect(() => {
    const handleConnectionChange = (state) => {
      setIsOnline(state.isConnected);
      setConnectionType(state.type);
    };

    networkManager.on('connectionChange', handleConnectionChange);

    return () => {
      networkManager.off('connectionChange', handleConnectionChange);
    };
  }, []);

  return { isOnline, connectionType };
};</code></pre>

            <h2>Offline Queue Implementation</h2>
            <pre><code class="language-javascript">import AsyncStorage from '@react-native-async-storage/async-storage';
import uuid from 'react-native-uuid';

// Operation types
const OperationType = {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  CUSTOM: 'CUSTOM'
};

// Offline queue for pending operations
class OfflineQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
    this.storageKey = '@offline_queue';
    this.maxRetries = 3;
    this.retryDelay = 1000; // Start with 1 second
  }

  async initialize() {
    // Load queue from storage
    try {
      const savedQueue = await AsyncStorage.getItem(this.storageKey);
      if (savedQueue) {
        this.queue = JSON.parse(savedQueue);
        console.log(\`Loaded \${this.queue.length} pending operations\`);
      }
    } catch (error) {
      console.error('Failed to load offline queue:', error);
    }

    // Listen for online events
    networkManager.on('online', () => {
      console.log('Network is back online, processing queue...');
      this.processQueue();
    });
  }

  async addOperation(operation) {
    const queueItem = {
      id: uuid.v4(),
      ...operation,
      timestamp: new Date().toISOString(),
      retries: 0,
      status: 'pending'
    };

    this.queue.push(queueItem);
    await this.saveQueue();

    // Try to process immediately if online
    if (networkManager.isConnected) {
      this.processQueue();
    }

    return queueItem.id;
  }

  async saveQueue() {
    try {
      await AsyncStorage.setItem(this.storageKey, JSON.stringify(this.queue));
    } catch (error) {
      console.error('Failed to save offline queue:', error);
    }
  }

  async processQueue() {
    if (this.processing || !networkManager.isConnected || this.queue.length === 0) {
      return;
    }

    this.processing = true;

    while (this.queue.length > 0 && networkManager.isConnected) {
      const operation = this.queue[0];

      try {
        // Process based on operation type
        const result = await this.processOperation(operation);
        
        // Remove successful operation
        this.queue.shift();
        await this.saveQueue();

        // Notify success
        this.emit('operationCompleted', { operation, result });
      } catch (error) {
        console.error('Operation failed:', error);
        operation.retries++;
        operation.lastError = error.message;

        if (operation.retries >= this.maxRetries) {
          // Move to failed operations
          operation.status = 'failed';
          this.queue.shift();
          await this.handleFailedOperation(operation);
        } else {
          // Exponential backoff
          const delay = this.retryDelay * Math.pow(2, operation.retries - 1);
          await new Promise(resolve => setTimeout(resolve, delay));
        }

        await this.saveQueue();
      }
    }

    this.processing = false;
  }

  async processOperation(operation) {
    switch (operation.type) {
      case OperationType.CREATE:
        return await this.processCreate(operation);
      case OperationType.UPDATE:
        return await this.processUpdate(operation);
      case OperationType.DELETE:
        return await this.processDelete(operation);
      case OperationType.CUSTOM:
        return await this.processCustom(operation);
      default:
        throw new Error(\`Unknown operation type: \${operation.type}\`);
    }
  }

  async processCreate(operation) {
    const { endpoint, data, localId } = operation;
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Local-Id': localId // For mapping local to server IDs
      },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }

    const result = await response.json();
    
    // Update local ID mapping
    await this.updateLocalIdMapping(localId, result.id);
    
    return result;
  }

  async handleFailedOperation(operation) {
    // Save to failed operations for manual retry
    const failedOps = await AsyncStorage.getItem('@failed_operations') || '[]';
    const failed = JSON.parse(failedOps);
    failed.push(operation);
    await AsyncStorage.setItem('@failed_operations', JSON.stringify(failed));

    // Notify user
    this.emit('operationFailed', operation);
  }
}

// Usage example
const offlineQueue = new OfflineQueue();

export const createPostOffline = async (postData) => {
  const localId = uuid.v4();
  
  // Save to local database with temporary ID
  await localDatabase.createPost({
    ...postData,
    id: localId,
    syncStatus: 'pending'
  });

  // Add to offline queue
  await offlineQueue.addOperation({
    type: OperationType.CREATE,
    endpoint: '/api/posts',
    data: postData,
    localId: localId
  });

  return localId;
};</code></pre>

            <h2>Conflict Resolution Strategies</h2>
            <pre><code class="language-javascript">// Conflict resolution strategies
const ConflictStrategy = {
  CLIENT_WINS: 'client_wins',
  SERVER_WINS: 'server_wins',
  MANUAL: 'manual',
  MERGE: 'merge',
  TIMESTAMP: 'timestamp'
};

class ConflictResolver {
  constructor(strategy = ConflictStrategy.TIMESTAMP) {
    this.strategy = strategy;
    this.pendingConflicts = [];
  }

  async resolveConflict(localData, serverData, metadata = {}) {
    switch (this.strategy) {
      case ConflictStrategy.CLIENT_WINS:
        return localData;
        
      case ConflictStrategy.SERVER_WINS:
        return serverData;
        
      case ConflictStrategy.TIMESTAMP:
        return this.resolveByTimestamp(localData, serverData);
        
      case ConflictStrategy.MERGE:
        return this.mergeData(localData, serverData);
        
      case ConflictStrategy.MANUAL:
        return this.requestManualResolution(localData, serverData, metadata);
        
      default:
        throw new Error(\`Unknown conflict strategy: \${this.strategy}\`);
    }
  }

  resolveByTimestamp(localData, serverData) {
    const localTime = new Date(localData.updatedAt || localData.modifiedAt);
    const serverTime = new Date(serverData.updatedAt || serverData.modifiedAt);
    
    return localTime > serverTime ? localData : serverData;
  }

  mergeData(localData, serverData) {
    // Custom merge logic based on data type
    const merged = { ...serverData };
    
    // For arrays, combine unique values
    Object.keys(localData).forEach(key => {
      if (Array.isArray(localData[key]) && Array.isArray(serverData[key])) {
        merged[key] = [...new Set([...serverData[key], ...localData[key]])];
      } else if (typeof localData[key] === 'object' && typeof serverData[key] === 'object') {
        // Recursive merge for nested objects
        merged[key] = this.mergeData(localData[key], serverData[key]);
      } else if (localData[key] !== serverData[key]) {
        // For simple values, implement field-level resolution
        merged[key] = this.resolveField(key, localData[key], serverData[key]);
      }
    });
    
    return merged;
  }

  resolveField(fieldName, localValue, serverValue) {
    // Custom field-level resolution rules
    const fieldRules = {
      // Numeric fields: sum the changes
      viewCount: () => localValue + serverValue,
      likeCount: () => Math.max(localValue, serverValue),
      
      // Text fields: keep longer content
      description: () => localValue.length > serverValue.length ? localValue : serverValue,
      
      // Boolean fields: OR operation
      isPublished: () => localValue || serverValue,
      
      // Default: use local value
      default: () => localValue
    };
    
    const resolver = fieldRules[fieldName] || fieldRules.default;
    return resolver();
  }

  async requestManualResolution(localData, serverData, metadata) {
    const conflict = {
      id: uuid.v4(),
      localData,
      serverData,
      metadata,
      timestamp: new Date().toISOString()
    };
    
    this.pendingConflicts.push(conflict);
    
    // Notify user about conflict
    this.emit('conflictDetected', conflict);
    
    // Return server data temporarily
    return serverData;
  }
}

// Sync manager with conflict resolution
class SyncManager {
  constructor(database, api, conflictResolver) {
    this.database = database;
    this.api = api;
    this.conflictResolver = conflictResolver;
    this.syncInProgress = false;
    this.lastSyncTime = null;
  }

  async sync() {
    if (this.syncInProgress || !networkManager.isConnected) {
      return;
    }

    this.syncInProgress = true;
    
    try {
      // Pull changes from server
      await this.pullChanges();
      
      // Push local changes
      await this.pushChanges();
      
      this.lastSyncTime = new Date().toISOString();
      await AsyncStorage.setItem('@last_sync_time', this.lastSyncTime);
      
      this.emit('syncCompleted', { timestamp: this.lastSyncTime });
    } catch (error) {
      console.error('Sync failed:', error);
      this.emit('syncFailed', error);
    } finally {
      this.syncInProgress = false;
    }
  }

  async pullChanges() {
    // Get changes since last sync
    const changes = await this.api.getChanges(this.lastSyncTime);
    
    for (const change of changes) {
      const localData = await this.database.getById(change.id);
      
      if (localData && localData.modifiedAt > change.modifiedAt) {
        // Conflict detected
        const resolved = await this.conflictResolver.resolveConflict(
          localData,
          change,
          { source: 'pull' }
        );
        
        await this.database.update(change.id, resolved);
      } else {
        // No conflict, apply server change
        await this.database.upsert(change);
      }
    }
  }

  async pushChanges() {
    // Get local changes
    const localChanges = await this.database.getUnsyncedChanges();
    
    for (const change of localChanges) {
      try {
        const serverResponse = await this.api.pushChange(change);
        
        if (serverResponse.conflict) {
          // Server detected conflict
          const resolved = await this.conflictResolver.resolveConflict(
            change,
            serverResponse.serverData,
            { source: 'push' }
          );
          
          // Retry with resolved data
          await this.api.pushChange(resolved);
        }
        
        // Mark as synced
        await this.database.markAsSynced(change.id);
      } catch (error) {
        console.error(\`Failed to push change \${change.id}:\`, error);
        // Keep in unsynced state for retry
      }
    }
  }
}</code></pre>

            <h2>Delta Sync Implementation</h2>
            <pre><code class="language-javascript">// Delta sync for efficient data transfer
class DeltaSync {
  constructor() {
    this.syncToken = null;
    this.pageSize = 100;
  }

  async performDeltaSync(endpoint, localDatabase) {
    const syncResult = {
      added: 0,
      updated: 0,
      deleted: 0,
      conflicts: []
    };

    try {
      // Get sync token from storage
      this.syncToken = await AsyncStorage.getItem('@sync_token');
      
      let hasMore = true;
      
      while (hasMore) {
        const response = await fetch(\`\${endpoint}/delta\`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': \`Bearer \${await getAuthToken()}\`
          },
          body: JSON.stringify({
            syncToken: this.syncToken,
            pageSize: this.pageSize
          })
        });

        const data = await response.json();
        
        // Process changes
        for (const item of data.items) {
          await this.processChange(item, localDatabase, syncResult);
        }
        
        // Update sync token
        this.syncToken = data.nextSyncToken;
        hasMore = data.hasMore;
        
        // Save intermediate sync token
        await AsyncStorage.setItem('@sync_token', this.syncToken);
      }
      
      return syncResult;
    } catch (error) {
      console.error('Delta sync failed:', error);
      throw error;
    }
  }

  async processChange(change, database, syncResult) {
    switch (change.changeType) {
      case 'created':
        await database.create(change.data);
        syncResult.added++;
        break;
        
      case 'updated':
        const existing = await database.findById(change.data.id);
        if (existing && existing.version > change.data.version) {
          // Conflict - local version is newer
          syncResult.conflicts.push({
            id: change.data.id,
            local: existing,
            remote: change.data
          });
        } else {
          await database.update(change.data.id, change.data);
          syncResult.updated++;
        }
        break;
        
      case 'deleted':
        await database.delete(change.data.id);
        syncResult.deleted++;
        break;
    }
  }
}

// Sync status UI component
const SyncStatusIndicator = () => {
  const [syncStatus, setSyncStatus] = useState('idle');
  const [lastSync, setLastSync] = useState(null);
  const { isOnline } = useNetworkState();

  useEffect(() => {
    const updateStatus = (status) => setSyncStatus(status);
    
    syncManager.on('syncStarted', () => updateStatus('syncing'));
    syncManager.on('syncCompleted', ({ timestamp }) => {
      updateStatus('success');
      setLastSync(timestamp);
      setTimeout(() => updateStatus('idle'), 3000);
    });
    syncManager.on('syncFailed', () => {
      updateStatus('error');
      setTimeout(() => updateStatus('idle'), 5000);
    });

    // Load last sync time
    AsyncStorage.getItem('@last_sync_time').then(setLastSync);
  }, []);

  const getSyncIcon = () => {
    const icons = {
      idle: 'cloud-sync',
      syncing: 'cloud-upload',
      success: 'cloud-check',
      error: 'cloud-alert',
      offline: 'cloud-offline'
    };
    
    return icons[isOnline ? syncStatus : 'offline'];
  };

  return (
    <View style={styles.syncStatus}>
      <Icon name={getSyncIcon()} size={20} />
      <Text style={styles.syncText}>
        {!isOnline ? 'Offline' : syncStatus === 'idle' ? 'Synced' : syncStatus}
      </Text>
      {lastSync && (
        <Text style={styles.lastSyncText}>
          Last sync: {formatRelativeTime(lastSync)}
        </Text>
      )}
    </View>
  );
};</code></pre>

            <h2>Background Sync</h2>
            <pre><code class="language-javascript">import BackgroundFetch from 'react-native-background-fetch';
import PushNotification from 'react-native-push-notification';

// Configure background sync
export const configureBackgroundSync = async () => {
  // Configure BackgroundFetch
  await BackgroundFetch.configure({
    minimumFetchInterval: 15, // minutes
    stopOnTerminate: false,
    startOnBoot: true,
    enableHeadless: true,
    requiresBatteryNotLow: false,
    requiresCharging: false,
    requiresStorageNotLow: false,
    requiresDeviceIdle: false,
    requiredNetworkType: BackgroundFetch.NETWORK_TYPE_ANY
  }, async (taskId) => {
    console.log('[BackgroundFetch] Starting sync task:', taskId);
    
    try {
      // Perform sync
      await performBackgroundSync();
      
      // Notify user if there are updates
      const updates = await checkForUpdates();
      if (updates.count > 0) {
        showUpdateNotification(updates);
      }
      
      BackgroundFetch.finish(taskId);
    } catch (error) {
      console.error('[BackgroundFetch] Sync failed:', error);
      BackgroundFetch.finish(taskId);
    }
  }, (taskId) => {
    console.log('[BackgroundFetch] Task timeout:', taskId);
    BackgroundFetch.finish(taskId);
  });

  // Check current status
  const status = await BackgroundFetch.status();
  console.log('[BackgroundFetch] Status:', status);
};

// Background sync implementation
const performBackgroundSync = async () => {
  // Initialize services
  await database.open();
  
  // Check network
  const netInfo = await NetInfo.fetch();
  if (!netInfo.isConnected) {
    console.log('No network connection, skipping sync');
    return;
  }

  // Sync data
  const syncManager = new SyncManager(database, api, conflictResolver);
  await syncManager.sync();
  
  // Clean up old data
  await cleanupOldData();
  
  // Close database
  await database.close();
};

// Headless task for Android
BackgroundFetch.registerHeadlessTask(async (taskId) => {
  console.log('[Headless] Starting background sync');
  
  try {
    await performBackgroundSync();
  } catch (error) {
    console.error('[Headless] Sync failed:', error);
  }
  
  BackgroundFetch.finish(taskId);
});

// iOS Background refresh
export const scheduleBackgroundRefresh = async () => {
  if (Platform.OS === 'ios') {
    await BackgroundFetch.scheduleTask({
      taskId: 'com.myapp.sync',
      delay: 5000, // milliseconds
      periodic: true,
      forceAlarmManager: false,
      stopOnTerminate: false,
      enableHeadless: true
    });
  }
};</code></pre>

            <h2>Data Consistency</h2>
            <pre><code class="language-javascript">// Ensure data consistency across sync operations
class DataConsistencyManager {
  constructor(database) {
    this.database = database;
    this.transactions = new Map();
  }

  // Atomic sync transaction
  async performAtomicSync(operations) {
    const transactionId = uuid.v4();
    const rollbackOperations = [];
    
    try {
      // Begin transaction
      await this.database.beginTransaction();
      
      for (const operation of operations) {
        // Store rollback info
        const rollback = await this.prepareRollback(operation);
        rollbackOperations.push(rollback);
        
        // Execute operation
        await this.executeOperation(operation);
      }
      
      // Commit transaction
      await this.database.commitTransaction();
      
      // Clear rollback data
      this.transactions.delete(transactionId);
      
      return { success: true, transactionId };
    } catch (error) {
      // Rollback on error
      console.error('Atomic sync failed, rolling back:', error);
      
      await this.database.rollbackTransaction();
      
      // Execute rollback operations
      for (const rollback of rollbackOperations.reverse()) {
        try {
          await this.executeRollback(rollback);
        } catch (rollbackError) {
          console.error('Rollback failed:', rollbackError);
        }
      }
      
      throw error;
    }
  }

  async prepareRollback(operation) {
    switch (operation.type) {
      case 'create':
        return {
          type: 'delete',
          id: operation.data.id
        };
        
      case 'update':
        const original = await this.database.findById(operation.id);
        return {
          type: 'update',
          id: operation.id,
          data: original
        };
        
      case 'delete':
        const deleted = await this.database.findById(operation.id);
        return {
          type: 'create',
          data: deleted
        };
        
      default:
        return null;
    }
  }

  // Validate data integrity
  async validateDataIntegrity() {
    const issues = [];
    
    // Check for orphaned records
    const orphans = await this.database.findOrphanedRecords();
    if (orphans.length > 0) {
      issues.push({
        type: 'orphaned_records',
        count: orphans.length,
        ids: orphans.map(r => r.id)
      });
    }
    
    // Check for missing references
    const missingRefs = await this.database.checkReferentialIntegrity();
    if (missingRefs.length > 0) {
      issues.push({
        type: 'missing_references',
        count: missingRefs.length,
        details: missingRefs
      });
    }
    
    // Check for duplicate records
    const duplicates = await this.database.findDuplicates();
    if (duplicates.length > 0) {
      issues.push({
        type: 'duplicate_records',
        count: duplicates.length,
        groups: duplicates
      });
    }
    
    return {
      isValid: issues.length === 0,
      issues
    };
  }

  // Repair data issues
  async repairDataIssues(issues) {
    const repairs = [];
    
    for (const issue of issues) {
      switch (issue.type) {
        case 'orphaned_records':
          await this.cleanupOrphans(issue.ids);
          repairs.push(\`Removed \${issue.count} orphaned records\`);
          break;
          
        case 'missing_references':
          await this.fixMissingReferences(issue.details);
          repairs.push(\`Fixed \${issue.count} missing references\`);
          break;
          
        case 'duplicate_records':
          await this.mergeDuplicates(issue.groups);
          repairs.push(\`Merged \${issue.count} duplicate records\`);
          break;
      }
    }
    
    return repairs;
  }
}</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>Offline Sync Best Practices:</h4>
                <ul>
                    <li>Always check network state before sync operations</li>
                    <li>Implement proper conflict resolution strategies</li>
                    <li>Use optimistic UI updates for better UX</li>
                    <li>Queue operations when offline</li>
                    <li>Implement exponential backoff for retries</li>
                    <li>Validate data integrity regularly</li>
                    <li>Provide clear sync status to users</li>
                    <li>Handle authentication token refresh</li>
                    <li>Implement data compression for large syncs</li>
                    <li>Use delta sync to minimize data transfer</li>
                    <li>Clean up old/stale data periodically</li>
                    <li>Test sync with various network conditions</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Build an offline-first note-taking app:</p>
                <ul>
                    <li>Full offline functionality</li>
                    <li>Background sync with conflict resolution</li>
                    <li>Real-time collaboration when online</li>
                    <li>Sync status indicators</li>
                    <li>Manual conflict resolution UI</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the best conflict resolution strategy for collaborative apps?",
            options: [
                "Always use server wins",
                "Always use client wins",
                "Timestamp-based with manual option",
                "Random selection"
            ],
            correct: 2,
            explanation: "Timestamp-based resolution with manual option provides automatic resolution for most cases while allowing users to intervene when needed."
        },
        {
            question: "When should you perform background sync?",
            options: [
                "Every minute",
                "Only when app is active",
                "Based on network and battery conditions",
                "Never"
            ],
            correct: 2,
            explanation: "Background sync should consider network availability, battery level, and user preferences to optimize resource usage."
        },
        {
            question: "How do you handle sync failures?",
            options: [
                "Ignore them",
                "Retry immediately",
                "Exponential backoff with max retries",
                "Delete the data"
            ],
            correct: 2,
            explanation: "Exponential backoff prevents overwhelming the server while giving temporary issues time to resolve."
        }
    ],
    project: {
        title: "Offline-First Expense Tracker",
        description: "Build a fully functional expense tracking app that works seamlessly offline and syncs across devices",
        requirements: [
            "Complete offline functionality for all features",
            "Background sync with smart scheduling",
            "Conflict resolution for shared accounts",
            "Data compression for efficient sync",
            "Sync progress indicators",
            "Manual sync trigger option",
            "Sync history and logs",
            "Handle authentication token refresh"
        ],
        hints: [
            "Use SQLite for local storage",
            "Implement queue for offline operations",
            "Show sync status in UI",
            "Compress images before sync",
            "Use delta sync for efficiency",
            "Test with airplane mode"
        ]
    }
},

'debugging-tools': {
    content: `
        <div class="content-section">
            <h1>Debugging Tools</h1>
            
            <div class="info-box">
                <p>Master the essential debugging tools and techniques for React Native development. Learn how to efficiently identify and fix issues using Chrome DevTools, React DevTools, and platform-specific debugging methods.</p>
            </div>

            <h2>React Native Debugger Setup</h2>
            <pre><code class="language-bash"># Install React Native Debugger (standalone app)
# macOS
brew install --cask react-native-debugger

# Windows/Linux - Download from GitHub releases
# https://github.com/jhen0409/react-native-debugger/releases

# Enable debugging in your app
# iOS: Cmd + D (Mac) or Ctrl + D (Windows)
# Android: Cmd + M (Mac) or Ctrl + M (Windows)
# Select "Debug with Chrome" or "Debug"</code></pre>

            <h2>Chrome DevTools Integration</h2>
            <pre><code class="language-javascript">// Enable Chrome debugging
if (__DEV__) {
  // This enables network inspection in Chrome DevTools
  global.XMLHttpRequest = global.originalXMLHttpRequest || global.XMLHttpRequest;
  global.FormData = global.originalFormData || global.FormData;

  if (window.__FETCH_SUPPORT__) {
    window.__FETCH_SUPPORT__.blob = false;
  } else {
    global.Blob = global.originalBlob || global.Blob;
    global.FileReader = global.originalFileReader || global.FileReader;
  }
}

// Custom console methods for better debugging
const customConsole = {
  logWithStyle: (message, style = 'color: blue; font-weight: bold') => {
    console.log(\`%c\${message}\`, style);
  },
  
  logGroup: (groupName, data) => {
    console.group(groupName);
    Object.entries(data).forEach(([key, value]) => {
      console.log(\`\${key}:\`, value);
    });
    console.groupEnd();
  },
  
  logTable: (data) => {
    if (console.table) {
      console.table(data);
    } else {
      console.log(JSON.stringify(data, null, 2));
    }
  },
  
  logPerformance: (label, fn) => {
    console.time(label);
    const result = fn();
    console.timeEnd(label);
    return result;
  }
};

// Usage examples
customConsole.logWithStyle('App initialized', 'color: green; font-size: 16px');
customConsole.logGroup('User Data', { id: 1, name: 'John', role: 'admin' });
customConsole.logPerformance('API Call', () => fetchUserData());</code></pre>

            <h2>React DevTools</h2>
            <pre><code class="language-javascript">// Install React DevTools
npm install -g react-devtools

// Run React DevTools
react-devtools

// Connect to your app
// The app will automatically connect when in debug mode

// Custom hooks for debugging components
import { useEffect, useRef } from 'react';

export const useWhyDidYouUpdate = (name, props) => {
  const previousProps = useRef();

  useEffect(() => {
    if (previousProps.current) {
      const allKeys = Object.keys({ ...previousProps.current, ...props });
      const changedProps = {};

      allKeys.forEach(key => {
        if (previousProps.current[key] !== props[key]) {
          changedProps[key] = {
            from: previousProps.current[key],
            to: props[key]
          };
        }
      });

      if (Object.keys(changedProps).length) {
        console.log('[why-did-you-update]', name, changedProps);
      }
    }

    previousProps.current = props;
  });
};

// Usage in component
const MyComponent = (props) => {
  useWhyDidYouUpdate('MyComponent', props);
  // Component logic
};

// Debug component renders
export const useRenderCount = (componentName) => {
  const renderCount = useRef(0);
  
  useEffect(() => {
    renderCount.current += 1;
    console.log(\`\${componentName} rendered \${renderCount.current} times\`);
  });
  
  return renderCount.current;
};</code></pre>

            <h2>Network Debugging</h2>
            <pre><code class="language-javascript">// Network request interceptor for debugging
class NetworkDebugger {
  constructor() {
    this.requests = [];
    this.enabled = __DEV__;
    
    if (this.enabled) {
      this.setupInterceptor();
    }
  }

  setupInterceptor() {
    // Store original fetch
    const originalFetch = global.fetch;

    // Override fetch
    global.fetch = async (...args) => {
      const [url, config = {}] = args;
      const method = config.method || 'GET';
      const requestId = Date.now();

      // Log request
      const requestInfo = {
        id: requestId,
        url,
        method,
        headers: config.headers,
        body: config.body,
        timestamp: new Date().toISOString()
      };

      this.logRequest(requestInfo);

      try {
        const startTime = performance.now();
        const response = await originalFetch(...args);
        const endTime = performance.now();
        const duration = endTime - startTime;

        // Clone response to read body
        const responseClone = response.clone();
        const responseBody = await responseClone.json().catch(() => null);

        // Log response
        const responseInfo = {
          id: requestId,
          status: response.status,
          statusText: response.statusText,
          headers: Object.fromEntries(response.headers.entries()),
          body: responseBody,
          duration: \`\${duration.toFixed(2)}ms\`
        };

        this.logResponse(responseInfo);

        return response;
      } catch (error) {
        this.logError(requestId, error);
        throw error;
      }
    };
  }

  logRequest(info) {
    console.group(\`🔵 REQUEST: \${info.method} \${info.url}\`);
    console.log('Headers:', info.headers);
    if (info.body) {
      console.log('Body:', JSON.parse(info.body));
    }
    console.log('Time:', info.timestamp);
    console.groupEnd();
    
    this.requests.push({ type: 'request', ...info });
  }

  logResponse(info) {
    const statusEmoji = info.status < 400 ? '🟢' : '🔴';
    console.group(\`\${statusEmoji} RESPONSE: \${info.status} (\${info.duration})\`);
    console.log('Headers:', info.headers);
    console.log('Body:', info.body);
    console.groupEnd();
    
    this.requests.push({ type: 'response', ...info });
  }

  logError(requestId, error) {
    console.group(\`🔴 NETWORK ERROR\`);
    console.error('Request ID:', requestId);
    console.error('Error:', error.message);
    console.error('Stack:', error.stack);
    console.groupEnd();
  }

  getRequests() {
    return this.requests;
  }

  clearRequests() {
    this.requests = [];
  }
}

// Initialize network debugger
export const networkDebugger = new NetworkDebugger();

// Custom hook for network monitoring
export const useNetworkMonitor = () => {
  const [requests, setRequests] = useState([]);

  useEffect(() => {
    const interval = setInterval(() => {
      setRequests([...networkDebugger.getRequests()]);
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return requests;
};</code></pre>

            <h2>Memory & Performance Debugging</h2>
            <pre><code class="language-javascript">// Memory leak detector
class MemoryLeakDetector {
  constructor() {
    this.components = new Map();
    this.intervals = new Map();
    this.listeners = new Map();
  }

  trackComponent(componentName, instance) {
    if (!this.components.has(componentName)) {
      this.components.set(componentName, new Set());
    }
    this.components.get(componentName).add(instance);
  }

  untrackComponent(componentName, instance) {
    if (this.components.has(componentName)) {
      this.components.get(componentName).delete(instance);
    }
  }

  trackInterval(id, componentName) {
    this.intervals.set(id, {
      componentName,
      createdAt: Date.now()
    });
  }

  untrackInterval(id) {
    this.intervals.delete(id);
  }

  trackListener(target, event, componentName) {
    const key = \`\${target}-\${event}\`;
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set());
    }
    this.listeners.get(key).add(componentName);
  }

  untrackListener(target, event, componentName) {
    const key = \`\${target}-\${event}\`;
    if (this.listeners.has(key)) {
      this.listeners.get(key).delete(componentName);
    }
  }

  getReport() {
    const report = {
      components: {},
      intervals: [],
      listeners: {}
    };

    // Component instances
    this.components.forEach((instances, name) => {
      if (instances.size > 0) {
        report.components[name] = instances.size;
      }
    });

    // Active intervals
    this.intervals.forEach((info, id) => {
      report.intervals.push({
        id,
        component: info.componentName,
        duration: Date.now() - info.createdAt
      });
    });

    // Event listeners
    this.listeners.forEach((components, key) => {
      if (components.size > 0) {
        report.listeners[key] = Array.from(components);
      }
    });

    return report;
  }

  checkForLeaks() {
    const report = this.getReport();
    const leaks = [];

    // Check for too many component instances
    Object.entries(report.components).forEach(([name, count]) => {
      if (count > 10) {
        leaks.push(\`Possible memory leak: \${count} instances of \${name}\`);
      }
    });

    // Check for long-running intervals
    report.intervals.forEach(interval => {
      if (interval.duration > 60000) { // 1 minute
        leaks.push(\`Long-running interval in \${interval.component}\`);
      }
    });

    return leaks;
  }
}

export const memoryLeakDetector = new MemoryLeakDetector();

// Hook for tracking memory leaks
export const useMemoryLeakDetection = (componentName) => {
  const instanceRef = useRef({});

  useEffect(() => {
    memoryLeakDetector.trackComponent(componentName, instanceRef.current);

    return () => {
      memoryLeakDetector.untrackComponent(componentName, instanceRef.current);
    };
  }, [componentName]);

  // Override setInterval to track it
  useEffect(() => {
    const originalSetInterval = global.setInterval;
    
    global.setInterval = (callback, delay, ...args) => {
      const id = originalSetInterval(callback, delay, ...args);
      memoryLeakDetector.trackInterval(id, componentName);
      return id;
    };

    return () => {
      global.setInterval = originalSetInterval;
    };
  }, [componentName]);
};</code></pre>

            <h2>Platform-Specific Debugging</h2>
            <pre><code class="language-javascript">// iOS-specific debugging
import { NativeModules, Platform } from 'react-native';

if (Platform.OS === 'ios' && __DEV__) {
  // Enable layout debugging
  NativeModules.DevSettings?.setIsDebuggingRemotely(true);
  
  // Log iOS-specific information
  console.log('iOS Version:', Platform.Version);
  console.log('Is iPad:', Platform.isPad);
  
  // Custom iOS debug menu items
  if (NativeModules.DevMenu) {
    NativeModules.DevMenu.addItem('Show View Hierarchy', () => {
      // Custom action
      console.log('Showing view hierarchy...');
    });
  }
}

// Android-specific debugging
if (Platform.OS === 'android' && __DEV__) {
  // Enable strict mode
  if (NativeModules.StrictMode) {
    NativeModules.StrictMode.setThreadPolicy({
      detectAll: true,
      penaltyLog: true
    });
  }
  
  // Log Android-specific information
  console.log('Android API Level:', Platform.Version);
  
  // Monitor app state for debugging
  const { AppState } = require('react-native');
  
  AppState.addEventListener('change', (nextAppState) => {
    console.log('App State Changed:', nextAppState);
  });
}

// Cross-platform debug utilities
export const DebugView = ({ children, showBorders = true, showInfo = true }) => {
  if (!__DEV__) {
    return children;
  }

  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  const [renderCount, setRenderCount] = useState(0);

  useEffect(() => {
    setRenderCount(prev => prev + 1);
  }, []);

  return (
    <View
      style={{
        borderWidth: showBorders ? 1 : 0,
        borderColor: 'red',
        borderStyle: 'dashed'
      }}
      onLayout={(event) => {
        const { width, height } = event.nativeEvent.layout;
        setDimensions({ width, height });
      }}
    >
      {showInfo && (
        <View style={{
          position: 'absolute',
          top: 0,
          right: 0,
          backgroundColor: 'rgba(255, 0, 0, 0.7)',
          padding: 2,
          zIndex: 999
        }}>
          <Text style={{ color: 'white', fontSize: 10 }}>
            {Math.round(dimensions.width)}x{Math.round(dimensions.height)} R:{renderCount}
          </Text>
        </View>
      )}
      {children}
    </View>
  );
};</code></pre>

            <h2>Error Boundary Implementation</h2>
            <pre><code class="language-javascript">// Enhanced error boundary with debugging features
class DebugErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      errorCount: 0
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Log to console with full details
    console.group('🔴 Error Boundary Caught Error');
    console.error('Error:', error);
    console.error('Component Stack:', errorInfo.componentStack);
    console.error('Props:', this.props);
    console.error('State:', this.state);
    console.groupEnd();

    // Update state
    this.setState(prevState => ({
      error,
      errorInfo,
      errorCount: prevState.errorCount + 1
    }));

    // Report to error tracking service
    if (!__DEV__) {
      this.reportError(error, errorInfo);
    }
  }

  reportError(error, errorInfo) {
    // Integrate with Sentry, Bugsnag, etc.
    const errorReport = {
      message: error.toString(),
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      props: JSON.stringify(this.props),
      timestamp: new Date().toISOString()
    };

    // Send to error tracking service
    console.log('Sending error report:', errorReport);
  }

  render() {
    if (this.state.hasError) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorTitle}>Something went wrong!</Text>
          
          {__DEV__ && (
            <>
              <ScrollView style={styles.errorDetails}>
                <Text style={styles.errorText}>
                  {this.state.error?.toString()}
                </Text>
                <Text style={styles.stackTrace}>
                  {this.state.error?.stack}
                </Text>
                <Text style={styles.componentStack}>
                  Component Stack:{this.state.errorInfo?.componentStack}
                </Text>
              </ScrollView>
              
              <TouchableOpacity
                style={styles.retryButton}
                onPress={() => this.setState({ hasError: false, error: null })}
              >
                <Text style={styles.retryText}>Retry</Text>
              </TouchableOpacity>
            </>
          )}
        </View>
      );
    }

    return this.props.children;
  }
}

const styles = StyleSheet.create({
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#f8f8f8'
  },
  errorTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 10,
    color: '#e74c3c'
  },
  errorDetails: {
    maxHeight: 300,
    width: '100%',
    marginVertical: 10,
    padding: 10,
    backgroundColor: '#fff',
    borderRadius: 5
  },
  errorText: {
    color: '#e74c3c',
    marginBottom: 10
  },
  stackTrace: {
    fontSize: 12,
    color: '#666',
    fontFamily: 'monospace'
  },
  componentStack: {
    fontSize: 12,
    color: '#666',
    marginTop: 10
  },
  retryButton: {
    marginTop: 20,
    padding: 10,
    backgroundColor: '#3498db',
    borderRadius: 5
  },
  retryText: {
    color: '#fff',
    fontWeight: 'bold'
  }
});</code></pre>

            <h2>Debug Configuration</h2>
            <pre><code class="language-javascript">// Create a debug configuration file
// debug.config.js
export const DebugConfig = {
  // Feature flags
  features: {
    enableNetworkLogging: __DEV__,
    enablePerformanceMonitoring: __DEV__,
    enableMemoryLeakDetection: __DEV__,
    enableGestureDebugging: __DEV__,
    showFPSMonitor: __DEV__,
    showTouchIndicator: __DEV__
  },

  // Console settings
  console: {
    logLevel: __DEV__ ? 'debug' : 'error',
    groupNetworkCalls: true,
    showTimestamps: true,
    coloredLogs: true
  },

  // Performance thresholds
  performance: {
    slowRenderThreshold: 16, // ms
    slowNetworkThreshold: 3000, // ms
    memoryWarningThreshold: 100 // MB
  },

  // Error handling
  errorHandling: {
    showErrorDetails: __DEV__,
    logErrorsToFile: !__DEV__,
    sendCrashReports: !__DEV__
  }
};

// Debug utilities manager
class DebugManager {
  constructor(config) {
    this.config = config;
    this.initialize();
  }

  initialize() {
    if (this.config.features.enableNetworkLogging) {
      this.enableNetworkLogging();
    }

    if (this.config.features.showFPSMonitor) {
      this.showFPSMonitor();
    }

    if (this.config.console.showTimestamps) {
      this.addTimestampsToConsole();
    }
  }

  enableNetworkLogging() {
    // Network logging implementation
  }

  showFPSMonitor() {
    // FPS monitor implementation
  }

  addTimestampsToConsole() {
    const originalLog = console.log;
    console.log = (...args) => {
      const timestamp = new Date().toISOString();
      originalLog(\`[\${timestamp}]\`, ...args);
    };
  }
}

// Initialize debug manager
export const debugManager = new DebugManager(DebugConfig);</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>Debugging Best Practices:</h4>
                <ul>
                    <li>Always remove console.log statements before production</li>
                    <li>Use conditional debugging based on __DEV__</li>
                    <li>Implement proper error boundaries</li>
                    <li>Log meaningful information with context</li>
                    <li>Use source maps for production debugging</li>
                    <li>Monitor memory usage and leaks</li>
                    <li>Test on real devices, not just simulators</li>
                    <li>Use platform-specific debugging tools</li>
                    <li>Implement remote debugging capabilities</li>
                    <li>Keep debugging tools updated</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Create a comprehensive debugging toolkit:</p>
                <ul>
                    <li>Custom console with colored outputs</li>
                    <li>Network request logger</li>
                    <li>Performance monitor</li>
                    <li>Memory leak detector</li>
                    <li>Error boundary with reporting</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the keyboard shortcut to open debug menu on iOS?",
            options: [
                "Cmd + R",
                "Cmd + D",
                "Cmd + M",
                "Cmd + I"
            ],
            correct: 1,
            explanation: "Cmd + D opens the debug menu on iOS simulator, while Cmd + M is used for Android."
        },
        {
            question: "Which tool is best for inspecting React component hierarchy?",
            options: [
                "Chrome DevTools",
                "React DevTools",
                "Safari Web Inspector",
                "Android Studio"
            ],
            correct: 1,
            explanation: "React DevTools is specifically designed for inspecting React component trees and props."
        },
        {
            question: "What does __DEV__ indicate in React Native?",
            options: [
                "Development server is running",
                "Debug mode is enabled",
                "App is in development mode",
                "DevTools are connected"
            ],
            correct: 2,
            explanation: "__DEV__ is a global variable that's true when the app is running in development mode."
        }
    ],
    project: {
        title: "Debug Dashboard App",
        description: "Build a debug dashboard that displays real-time app metrics, network requests, and error logs",
        requirements: [
            "Show FPS and memory usage",
            "Log and display network requests",
            "Capture and show console logs",
            "Error tracking with stack traces",
            "Performance metrics visualization",
            "Export debug logs feature",
            "Filter logs by type/level",
            "Clear debug data option"
        ],
        hints: [
            "Use react-native-performance for metrics",
            "Intercept fetch/XMLHttpRequest",
            "Store logs in AsyncStorage",
            "Create custom error boundary",
            "Use charts for visualization"
        ]
    }
},
'flipper': {
    content: `
        <div class="content-section">
            <h1>Flipper</h1>
            
            <div class="info-box">
                <p>Flipper is a platform for debugging mobile apps with a desktop interface. It provides tools for inspecting network requests, databases, React components, and native logs, making debugging more efficient and visual.</p>
            </div>

            <h2>Installation & Setup</h2>
            <pre><code class="language-bash"># Install Flipper desktop app
# Download from: https://fbflipper.com/

# For React Native 0.62+, Flipper is integrated by default
# For older versions, manual setup is required

# iOS Setup (if not auto-configured)
cd ios && pod install

# Verify Flipper integration in iOS
# Check ios/Podfile for Flipper pods

# Android Setup (if not auto-configured)
# Check android/gradle.properties for FLIPPER_VERSION</code></pre>

            <h2>Flipper Configuration</h2>
            <pre><code class="language-javascript">// Configure Flipper in your app
// index.js or App.js
if (__DEV__) {
  require('react-native-flipper').default();
}

// Advanced Flipper configuration
// flipper.config.js
import { initializeFlipper } from 'react-native-flipper';

const flipperConfig = {
  // Enable specific plugins
  plugins: {
    'Network': true,
    'React': true,
    'React Native': true,
    'Databases': true,
    'Images': true,
    'Layout': true,
    'Logs': true,
    'Preferences': true,
    'Crash Reporter': true
  },
  
  // Network plugin configuration
  network: {
    // Ignore certain URLs
    ignoreUrls: [
      'https://localhost:8081/symbolicate',
      /\\/logs$/
    ],
    
    // Custom request formatter
    requestFormatter: (request) => ({
      ...request,
      headers: {
        ...request.headers,
        'X-Debug-Time': new Date().toISOString()
      }
    })
  }
};

// Initialize with custom config
export const setupFlipper = () => {
  if (__DEV__) {
    initializeFlipper(flipperConfig);
  }
};</code></pre>

            <h2>Custom Flipper Plugins</h2>
            <pre><code class="language-javascript">// Create custom Flipper plugin
import { FlipperPlugin, FlipperClient } from 'react-native-flipper';

class CustomLoggerPlugin extends FlipperPlugin {
  static id = 'CustomLogger';
  
  constructor() {
    super();
    this.logs = [];
  }

  onConnect(connection) {
    // Send initial data
    connection.send('init', {
      logs: this.logs
    });

    // Listen for commands from Flipper desktop
    connection.receive('clear', () => {
      this.logs = [];
      connection.send('logs', { logs: [] });
    });

    connection.receive('filter', (data) => {
      const filtered = this.logs.filter(log => 
        log.level === data.level
      );
      connection.send('logs', { logs: filtered });
    });
  }

  log(level, message, data = {}) {
    const logEntry = {
      id: Date.now(),
      timestamp: new Date().toISOString(),
      level,
      message,
      data
    };

    this.logs.push(logEntry);

    // Send to connected Flipper desktop
    this.send('newLog', logEntry);
  }

  // Convenience methods
  debug(message, data) {
    this.log('debug', message, data);
  }

  info(message, data) {
    this.log('info', message, data);
  }

  warn(message, data) {
    this.log('warn', message, data);
  }

  error(message, data) {
    this.log('error', message, data);
  }
}

// Register and export plugin
const customLogger = new CustomLoggerPlugin();
FlipperClient.addPlugin(customLogger);

export { customLogger };

// Usage in your app
import { customLogger } from './flipper/CustomLoggerPlugin';

// Log custom events
customLogger.info('User logged in', { userId: 123 });
customLogger.error('API call failed', { 
  endpoint: '/api/users',
  error: 'Network timeout'
});</code></pre>

            <h2>Redux Flipper Integration</h2>
            <pre><code class="language-javascript">// Install Redux Flipper
npm install --save-dev redux-flipper react-native-flipper

// Configure Redux with Flipper
import { createStore, applyMiddleware } from 'redux';
import { createFlipperMiddleware } from 'redux-flipper';

const flipperMiddleware = __DEV__ 
  ? createFlipperMiddleware({
      // Options
      actionsBlacklist: ['@@INIT'],
      actionsWhitelist: [],
      actionSanitizer: (action) => action,
      stateSanitizer: (state) => state,
      // Send only changed state parts
      diffStrategy: 'diff'
    })
  : undefined;

const store = createStore(
  rootReducer,
  applyMiddleware(
    ...(flipperMiddleware ? [flipperMiddleware] : []),
    // other middleware
  )
);

// For Redux Toolkit
import { configureStore } from '@reduxjs/toolkit';

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => {
    const middleware = getDefaultMiddleware();
    
    if (__DEV__ && flipperMiddleware) {
      middleware.push(flipperMiddleware);
    }
    
    return middleware;
  }
});</code></pre>

            <h2>Database Inspection</h2>
            <pre><code class="language-javascript">// Setup database plugin for SQLite
import SQLite from 'react-native-sqlite-storage';

// Flipper will automatically detect SQLite databases
// Make sure to name your databases properly
const database = SQLite.openDatabase({
  name: 'MyApp.db', // This name will appear in Flipper
  location: 'default'
});

// For Realm databases
import Realm from 'realm';

const realm = new Realm({
  schema: [UserSchema, PostSchema],
  schemaVersion: 1,
  // Enable Flipper integration
  // Flipper will show this in Databases plugin
  path: 'MyAppRealm.realm'
});

// AsyncStorage debugging
import AsyncStorage from '@react-native-async-storage/async-storage';

// Create debug wrapper for AsyncStorage
const DebugAsyncStorage = {
  async setItem(key, value) {
    if (__DEV__) {
      customLogger.debug('AsyncStorage.setItem', { key, value });
    }
    return AsyncStorage.setItem(key, value);
  },

  async getItem(key) {
    const value = await AsyncStorage.getItem(key);
    if (__DEV__) {
      customLogger.debug('AsyncStorage.getItem', { key, value });
    }
    return value;
  },

  async removeItem(key) {
    if (__DEV__) {
      customLogger.debug('AsyncStorage.removeItem', { key });
    }
    return AsyncStorage.removeItem(key);
  },

  async getAllKeys() {
    const keys = await AsyncStorage.getAllKeys();
    if (__DEV__) {
      customLogger.debug('AsyncStorage.getAllKeys', { keys });
    }
    return keys;
  }
};</code></pre>

            <h2>Network Inspection</h2>
            <pre><code class="language-javascript">// Enhanced network debugging with Flipper
import { NetworkFlipperPlugin } from 'react-native-flipper';

// Custom network interceptor
class FlipperNetworkInterceptor {
  constructor() {
    this.plugin = new NetworkFlipperPlugin();
  }

  async interceptFetch(url, options = {}) {
    const requestId = Date.now().toString();
    
    // Log request start
    this.plugin.reportRequest({
      id: requestId,
      timestamp: Date.now(),
      method: options.method || 'GET',
      url: url,
      headers: options.headers || {},
      body: options.body
    });

    try {
      const startTime = performance.now();
      const response = await fetch(url, options);
      const endTime = performance.now();

      // Clone response to read body
      const responseClone = response.clone();
      let responseBody;
      
      try {
        responseBody = await responseClone.json();
      } catch {
        responseBody = await responseClone.text();
      }

      // Log response
      this.plugin.reportResponse({
        id: requestId,
        timestamp: Date.now(),
        status: response.status,
        reason: response.statusText,
        headers: Object.fromEntries(response.headers.entries()),
        body: responseBody,
        duration: endTime - startTime
      });

      return response;
    } catch (error) {
      // Log error
      this.plugin.reportResponse({
        id: requestId,
        timestamp: Date.now(),
        status: 0,
        reason: error.message,
        headers: {},
        body: { error: error.message },
        duration: 0
      });

      throw error;
    }
  }

  // Create wrapped fetch
  createInterceptedFetch() {
    return (url, options) => this.interceptFetch(url, options);
  }
}

// Replace global fetch with intercepted version
if (__DEV__) {
  const interceptor = new FlipperNetworkInterceptor();
  global.fetch = interceptor.createInterceptedFetch();
}</code></pre>

            <h2>Layout Inspector</h2>
            <pre><code class="language-javascript">// Using Flipper's Layout Inspector
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

// Component with debug information
const DebugComponent = ({ children, name }) => {
  // In development, add debug attributes
  const debugProps = __DEV__ ? {
    // These attributes help identify components in Flipper
    accessibilityLabel: \`Debug: \${name}\`,
    testID: \`component-\${name}\`,
    // Custom debug data
    nativeID: \`\${name}-\${Date.now()}\`
  } : {};

  return (
    <View {...debugProps} style={styles.container}>
      {__DEV__ && (
        <View style={styles.debugOverlay}>
          <Text style={styles.debugText}>{name}</Text>
        </View>
      )}
      {children}
    </View>
  );
};

// Helper to track component hierarchy
export const withFlipperLayout = (Component, componentName) => {
  return React.forwardRef((props, ref) => {
    React.useEffect(() => {
      if (__DEV__) {
        console.log(\`[Flipper Layout] \${componentName} mounted\`);
      }
    }, []);

    return (
      <Component
        ref={ref}
        {...props}
        flipperComponentName={componentName}
      />
    );
  });
};</code></pre>

            <h2>Performance Monitoring</h2>
            <pre><code class="language-javascript">// Flipper performance plugin
import { PerformancePlugin } from 'react-native-flipper';

class PerformanceMonitor {
  constructor() {
    this.plugin = new PerformancePlugin();
    this.marks = new Map();
  }

  startMeasure(name) {
    this.marks.set(name, performance.now());
    
    this.plugin.reportMark({
      name: \`\${name}-start\`,
      timestamp: Date.now()
    });
  }

  endMeasure(name, metadata = {}) {
    const startTime = this.marks.get(name);
    if (!startTime) {
      console.warn(\`No start mark found for \${name}\`);
      return;
    }

    const duration = performance.now() - startTime;
    this.marks.delete(name);

    this.plugin.reportMeasure({
      name,
      startMark: \`\${name}-start\`,
      endMark: \`\${name}-end\`,
      duration,
      timestamp: Date.now(),
      metadata
    });

    return duration;
  }

  // React component performance
  measureComponent(componentName) {
    return {
      onRenderStart: () => this.startMeasure(\`render-\${componentName}\`),
      onRenderEnd: () => this.endMeasure(\`render-\${componentName}\`),
      onMountStart: () => this.startMeasure(\`mount-\${componentName}\`),
      onMountEnd: () => this.endMeasure(\`mount-\${componentName}\`)
    };
  }

  // API call performance
  async measureAsync(name, asyncFn, metadata = {}) {
    this.startMeasure(name);
    
    try {
      const result = await asyncFn();
      const duration = this.endMeasure(name, { ...metadata, status: 'success' });
      
      return { result, duration };
    } catch (error) {
      const duration = this.endMeasure(name, { ...metadata, status: 'error', error: error.message });
      
      throw error;
    }
  }
}

export const performanceMonitor = new PerformanceMonitor();

// Usage example
const fetchUserData = async (userId) => {
  const { result, duration } = await performanceMonitor.measureAsync(
    'fetchUserData',
    () => fetch(\`/api/users/\${userId}\`),
    { userId }
  );
  
  console.log(\`User data fetched in \${duration}ms\`);
  return result;
};</code></pre>

            <h2>Crash Reporting</h2>
            <pre><code class="language-javascript">// Flipper crash reporter integration
import { CrashReporterPlugin } from 'react-native-flipper';

class FlipperCrashReporter {
  constructor() {
    this.plugin = new CrashReporterPlugin();
    this.setupErrorHandlers();
  }

  setupErrorHandlers() {
    // Handle JavaScript errors
    const originalHandler = ErrorUtils.getGlobalHandler();
    
    ErrorUtils.setGlobalHandler((error, isFatal) => {
      this.reportCrash({
        message: error.message,
        stack: error.stack,
        isFatal,
        type: 'javascript',
        timestamp: new Date().toISOString()
      });

      // Call original handler
      if (originalHandler) {
        originalHandler(error, isFatal);
      }
    });

    // Handle promise rejections
    global.onunhandledRejection = (error, promise) => {
      this.reportCrash({
        message: error.message || 'Unhandled Promise Rejection',
        stack: error.stack,
        type: 'promise_rejection',
        timestamp: new Date().toISOString()
      });
    };
  }

  reportCrash(crashInfo) {
    // Send to Flipper
    this.plugin.reportCrash({
      id: Date.now().toString(),
      ...crashInfo,
      deviceInfo: {
        platform: Platform.OS,
        version: Platform.Version,
        model: DeviceInfo.getModel(),
        brand: DeviceInfo.getBrand()
      },
      appInfo: {
        version: DeviceInfo.getVersion(),
        buildNumber: DeviceInfo.getBuildNumber()
      }
    });

    // Also log to console in dev
    if (__DEV__) {
      console.group('🔴 Crash Report');
      console.error('Message:', crashInfo.message);
      console.error('Stack:', crashInfo.stack);
      console.error('Type:', crashInfo.type);
      console.groupEnd();
    }
  }

  // Manual crash reporting
  reportCustomCrash(name, details) {
    this.reportCrash({
      message: name,
      stack: new Error().stack,
      type: 'custom',
      details,
      timestamp: new Date().toISOString()
    });
  }
}

// Initialize crash reporter
export const crashReporter = new FlipperCrashReporter();</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>Flipper Best Practices:</h4>
                <ul>
                    <li>Only enable Flipper in development builds</li>
                    <li>Use custom plugins for app-specific debugging</li>
                    <li>Monitor performance impact of Flipper</li>
                    <li>Regularly update Flipper desktop app</li>
                    <li>Configure plugins based on debugging needs</li>
                    <li>Use network plugin to debug API issues</li>
                    <li>Leverage layout inspector for UI debugging</li>
                    <li>Create shortcuts for common debugging tasks</li>
                    <li>Export logs for sharing with team</li>
                    <li>Disable Flipper for release builds</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Create a custom Flipper plugin for your app:</p>
                <ul>
                    <li>User action logger</li>
                    <li>State change monitor</li>
                    <li>Performance metrics dashboard</li>
                    <li>Custom network inspector</li>
                    <li>Analytics event tracker</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What is Flipper primarily used for?",
            options: [
                "Code compilation",
                "Debugging mobile apps",
                "Testing automation",
                "Performance optimization"
            ],
            correct: 1,
            explanation: "Flipper is a platform for debugging mobile apps with tools for network inspection, database viewing, and more."
        },
        {
            question: "Which React Native version includes Flipper by default?",
            options: [
                "0.59",
                "0.60",
                "0.62",
                "0.64"
            ],
            correct: 2,
            explanation: "React Native 0.62 and later versions include Flipper integration by default."
        },
        {
            question: "What can you inspect with Flipper's Layout plugin?",
            options: [
                "Network requests",
                "Component hierarchy and styles",
                "Database contents",
                "Console logs"
            ],
            correct: 1,
            explanation: "The Layout plugin allows you to inspect the component hierarchy, view styles, and modify properties in real-time."
        }
    ],
    project: {
        title: "Custom Flipper Plugin Suite",
        description: "Build a comprehensive set of custom Flipper plugins for advanced app debugging",
        requirements: [
            "User session tracker plugin",
            "API performance monitor",
            "State change visualizer",
            "Custom logger with filters",
            "Memory usage tracker",
            "Navigation flow analyzer",
            "Error aggregation plugin",
            "Feature flag manager"
        ],
        hints: [
            "Extend FlipperPlugin class",
            "Use connection.send() for updates",
            "Implement desktop UI in TypeScript",
            "Store plugin state persistently",
            "Add export functionality"
        ]
    }
},
      'jest-setup': {
    content: `
        <div class="content-section">
            <h1>Jest Setup</h1>
            
            <div class="info-box">
                <p>Jest is a delightful JavaScript testing framework with a focus on simplicity. Learn how to set up Jest for React Native projects, configure it properly, and write effective unit tests.</p>
            </div>

            <h2>Installation & Basic Setup</h2>
            <pre><code class="language-bash"># Jest comes pre-installed with React Native
# Additional testing utilities
npm install --save-dev @testing-library/react-native
npm install --save-dev @testing-library/jest-native
npm install --save-dev jest-expo # For Expo projects

# For TypeScript support
npm install --save-dev @types/jest ts-jest

# Mock libraries
npm install --save-dev react-native-mock-render</code></pre>

            <h2>Jest Configuration</h2>
            <pre><code class="language-javascript">// jest.config.js
module.exports = {
  preset: 'react-native',
  
  // Module paths
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
  
  // Transform files
  transform: {
    '^.+\\\\.(js|jsx|ts|tsx)$': 'babel-jest',
  },
  
  // Test match patterns
  testMatch: [
    '**/__tests__/**/*.(ts|tsx|js|jsx)',
    '**/*.(test|spec).(ts|tsx|js|jsx)',
  ],
  
  // Coverage collection
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/index.{js,ts}',
    '!src/**/*.stories.{js,jsx,ts,tsx}',
  ],
  
  // Coverage thresholds
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  
  // Setup files
  setupFiles: ['<rootDir>/jest/setup.js'],
  setupFilesAfterEnv: ['<rootDir>/jest/setupAfterEnv.js'],
  
  // Module name mapper for assets
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@components/(.*)$': '<rootDir>/src/components/$1',
    '^@screens/(.*)$': '<rootDir>/src/screens/$1',
    '^@utils/(.*)$': '<rootDir>/src/utils/$1',
    '\\\\.(jpg|jpeg|png|gif|svg)$': '<rootDir>/jest/mocks/fileMock.js',
    '\\\\.(css|less|scss|sass)$': 'identity-obj-proxy',
  },
  
  // Transform ignore patterns
  transformIgnorePatterns: [
    'node_modules/(?!(react-native|@react-native|@react-navigation|react-native-vector-icons|react-native-reanimated)/)',
  ],
  
  // Timers
  timers: 'fake',
  
  // Test environment
  testEnvironment: 'node',
  
  // Globals
  globals: {
    __DEV__: true,
  },
};

// For TypeScript projects - tsconfig.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "jsx": "react"
  },
  "include": [
    "src/**/*",
    "jest/**/*",
    "__tests__/**/*"
  ]
}</code></pre>

            <h2>Setup Files</h2>
            <pre><code class="language-javascript">// jest/setup.js - Initial setup
import 'react-native-gesture-handler/jestSetup';

// Mock native modules
jest.mock('react-native/Libraries/Animated/NativeAnimatedHelper');
jest.mock('react-native/Libraries/EventEmitter/NativeEventEmitter');

// Mock react-native modules
jest.mock('react-native', () => {
  const RN = jest.requireActual('react-native');
  
  RN.NativeModules.SettingsManager = {
    settings: {
      AppleLocale: 'en-US',
      AppleLanguages: ['en-US'],
    },
  };
  
  return RN;
});

// Mock AsyncStorage
jest.mock('@react-native-async-storage/async-storage', () =>
  require('@react-native-async-storage/async-storage/jest/async-storage-mock')
);

// Mock NetInfo
jest.mock('@react-native-community/netinfo', () =>
  require('@react-native-community/netinfo/jest/netinfo-mock')
);

// Mock device info
jest.mock('react-native-device-info', () =>
  require('react-native-device-info/jest/react-native-device-info-mock')
);

// Global mocks
global.fetch = jest.fn();
global.console = {
  ...console,
  // Suppress console methods in tests
  log: jest.fn(),
  debug: jest.fn(),
  info: jest.fn(),
  warn: jest.fn(),
  error: jest.fn(),
};

// Performance mock
global.performance = {
  now: jest.fn(() => Date.now()),
};

// jest/setupAfterEnv.js - Extended matchers
import '@testing-library/jest-native/extend-expect';

// Custom matchers
expect.extend({
  toBeWithinRange(received, floor, ceiling) {
    const pass = received >= floor && received <= ceiling;
    if (pass) {
      return {
        message: () =>
          \`expected \${received} not to be within range \${floor} - \${ceiling}\`,
        pass: true,
      };
    } else {
      return {
        message: () =>
          \`expected \${received} to be within range \${floor} - \${ceiling}\`,
        pass: false,
      };
    }
  },
  
  toHaveBeenCalledWithMatch(received, ...args) {
    const calls = received.mock.calls;
    const pass = calls.some(call =>
      args.every((arg, index) => {
        if (typeof arg === 'function') {
          return arg(call[index]);
        }
        return call[index] === arg;
      })
    );
    
    return {
      pass,
      message: () => pass
        ? \`expected \${received} not to have been called with matching arguments\`
        : \`expected \${received} to have been called with matching arguments\`,
    };
  },
});</code></pre>

            <h2>Component Testing</h2>
            <pre><code class="language-javascript">// __tests__/components/Button.test.js
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import Button from '../src/components/Button';

describe('Button Component', () => {
  it('renders correctly with title', () => {
    const { getByText } = render(
      <Button title="Click me" onPress={() => {}} />
    );
    
    expect(getByText('Click me')).toBeTruthy();
  });
  
  it('calls onPress when pressed', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <Button title="Click me" onPress={onPressMock} />
    );
    
    fireEvent.press(getByText('Click me'));
    expect(onPressMock).toHaveBeenCalledTimes(1);
  });
  
  it('shows loading state', () => {
    const { getByTestId, rerender } = render(
      <Button title="Submit" loading={false} />
    );
    
    expect(() => getByTestId('loading-indicator')).toThrow();
    
    rerender(<Button title="Submit" loading={true} />);
    expect(getByTestId('loading-indicator')).toBeTruthy();
  });
  
  it('is disabled when loading', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <Button title="Submit" loading={true} onPress={onPressMock} />
    );
    
    fireEvent.press(getByText('Submit'));
    expect(onPressMock).not.toHaveBeenCalled();
  });
  
  it('applies custom styles', () => {
    const customStyle = { backgroundColor: 'red' };
    const { getByTestId } = render(
      <Button title="Styled" style={customStyle} testID="button" />
    );
    
    const button = getByTestId('button');
    expect(button).toHaveStyle(customStyle);
  });
});

// Snapshot testing
describe('Button Snapshots', () => {
  it('matches snapshot', () => {
    const tree = render(
      <Button title="Snapshot Test" onPress={() => {}} />
    ).toJSON();
    
    expect(tree).toMatchSnapshot();
  });
  
  it('matches snapshot with different props', () => {
    const tree = render(
      <Button 
        title="Loading Button" 
        loading={true}
        disabled={true}
        variant="primary"
      />
    ).toJSON();
    
    expect(tree).toMatchSnapshot();
  });
});</code></pre>

            <h2>Hook Testing</h2>
            <pre><code class="language-javascript">// __tests__/hooks/useCounter.test.js
import { renderHook, act } from '@testing-library/react-hooks';
import useCounter from '../src/hooks/useCounter';

describe('useCounter Hook', () => {
  it('initializes with default value', () => {
    const { result } = renderHook(() => useCounter());
    
    expect(result.current.count).toBe(0);
  });
  
  it('initializes with custom value', () => {
    const { result } = renderHook(() => useCounter(10));
    
    expect(result.current.count).toBe(10);
  });
  
  it('increments counter', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });
  
  it('decrements counter', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.decrement();
    });
    
    expect(result.current.count).toBe(4);
  });
  
  it('resets counter', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.increment();
      result.current.increment();
      result.current.reset();
    });
    
    expect(result.current.count).toBe(5);
  });
});

// Async hook testing
describe('useApi Hook', () => {
  beforeEach(() => {
    fetch.mockClear();
  });
  
  it('fetches data successfully', async () => {
    const mockData = { id: 1, name: 'Test User' };
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockData,
    });
    
    const { result, waitForNextUpdate } = renderHook(() => 
      useApi('/api/user/1')
    );
    
    expect(result.current.loading).toBe(true);
    expect(result.current.data).toBe(null);
    
    await waitForNextUpdate();
    
    expect(result.current.loading).toBe(false);
    expect(result.current.data).toEqual(mockData);
    expect(result.current.error).toBe(null);
  });
  
  it('handles fetch error', async () => {
    fetch.mockRejectedValueOnce(new Error('Network error'));
    
    const { result, waitForNextUpdate } = renderHook(() => 
      useApi('/api/user/1')
    );
    
    await waitForNextUpdate();
    
    expect(result.current.loading).toBe(false);
    expect(result.current.data).toBe(null);
    expect(result.current.error).toBe('Network error');
  });
});</code></pre>

            <h2>Redux Testing</h2>
            <pre><code class="language-javascript">// __tests__/redux/userSlice.test.js
import userReducer, {
  setUser,
  updateUser,
  clearUser,
  selectUser,
} from '../src/redux/userSlice';

describe('User Slice', () => {
  const initialState = {
    user: null,
    loading: false,
    error: null,
  };
  
  it('should handle initial state', () => {
    expect(userReducer(undefined, { type: 'unknown' })).toEqual(initialState);
  });
  
  it('should handle setUser', () => {
    const user = { id: 1, name: 'John Doe' };
    const actual = userReducer(initialState, setUser(user));
    
    expect(actual.user).toEqual(user);
  });
  
  it('should handle updateUser', () => {
    const state = {
      ...initialState,
      user: { id: 1, name: 'John Doe', email: 'john@example.com' },
    };
    
    const updates = { email: 'newemail@example.com' };
    const actual = userReducer(state, updateUser(updates));
    
    expect(actual.user.email).toBe('newemail@example.com');
    expect(actual.user.name).toBe('John Doe');
  });
  
  it('should handle clearUser', () => {
    const state = {
      ...initialState,
      user: { id: 1, name: 'John Doe' },
    };
    
    const actual = userReducer(state, clearUser());
    expect(actual.user).toBe(null);
  });
});

// Async action testing
import configureMockStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import { loginUser } from '../src/redux/authActions';

const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

describe('Auth Actions', () => {
  beforeEach(() => {
    fetch.mockClear();
  });
  
  it('creates LOGIN_SUCCESS when login is successful', async () => {
    const mockUser = { id: 1, email: 'test@example.com' };
    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ user: mockUser, token: 'fake-token' }),
    });
    
    const expectedActions = [
      { type: 'auth/loginPending' },
      { type: 'auth/loginSuccess', payload: mockUser },
    ];
    
    const store = mockStore({ auth: {} });
    
    await store.dispatch(loginUser('test@example.com', 'password'));
    
    expect(store.getActions()).toEqual(expectedActions);
  });
});</code></pre>

            <h2>Navigation Testing</h2>
            <pre><code class="language-javascript">// __tests__/navigation/AppNavigator.test.js
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { render, fireEvent } from '@testing-library/react-native';
import AppNavigator from '../src/navigation/AppNavigator';

// Mock navigation
const mockNavigate = jest.fn();
const mockGoBack = jest.fn();

jest.mock('@react-navigation/native', () => {
  const actualNav = jest.requireActual('@react-navigation/native');
  return {
    ...actualNav,
    useNavigation: () => ({
      navigate: mockNavigate,
      goBack: mockGoBack,
    }),
  };
});

describe('App Navigation', () => {
  beforeEach(() => {
    mockNavigate.mockClear();
    mockGoBack.mockClear();
  });
  
  it('renders home screen by default', () => {
    const { getByText } = render(
      <NavigationContainer>
        <AppNavigator />
      </NavigationContainer>
    );
    
    expect(getByText('Welcome to Home')).toBeTruthy();
  });
  
  it('navigates to profile screen', () => {
    const { getByText } = render(
      <NavigationContainer>
        <AppNavigator />
      </NavigationContainer>
    );
    
    fireEvent.press(getByText('Go to Profile'));
    
    expect(mockNavigate).toHaveBeenCalledWith('Profile', {});
  });
  
  it('passes params correctly', () => {
    const { getByText } = render(
      <NavigationContainer>
        <AppNavigator />
      </NavigationContainer>
    );
    
    fireEvent.press(getByText('View User'));
    
    expect(mockNavigate).toHaveBeenCalledWith('UserDetail', {
      userId: 123,
      userName: 'John Doe',
    });
  });
});</code></pre>

            <h2>Mocking Best Practices</h2>
            <pre><code class="language-javascript">// __mocks__/react-native-camera.js
export default {
  RNCamera: {
    Constants: {
      Type: { back: 'back', front: 'front' },
      FlashMode: { off: 'off', on: 'on', auto: 'auto' },
    },
  },
  takePictureAsync: jest.fn(() => Promise.resolve({
    uri: 'mock-photo-uri',
    width: 1920,
    height: 1080,
  })),
  recordAsync: jest.fn(() => Promise.resolve({
    uri: 'mock-video-uri',
    codec: 'mp4',
  })),
};

// __mocks__/react-native-permissions.js
const RESULTS = {
  UNAVAILABLE: 'unavailable',
  DENIED: 'denied',
  GRANTED: 'granted',
  BLOCKED: 'blocked',
};

export default {
  RESULTS,
  check: jest.fn(() => Promise.resolve(RESULTS.GRANTED)),
  request: jest.fn(() => Promise.resolve(RESULTS.GRANTED)),
  checkMultiple: jest.fn(() => Promise.resolve({
    'ios.permission.CAMERA': RESULTS.GRANTED,
    'ios.permission.MICROPHONE': RESULTS.GRANTED,
  })),
  requestMultiple: jest.fn(() => Promise.resolve({
    'ios.permission.CAMERA': RESULTS.GRANTED,
    'ios.permission.MICROPHONE': RESULTS.GRANTED,
  })),
};

// Custom test utilities
// testUtils.js
import React from 'react';
import { render } from '@testing-library/react-native';
import { Provider } from 'react-redux';
import { NavigationContainer } from '@react-navigation/native';
import { ThemeProvider } from 'styled-components/native';
import { configureStore } from '@reduxjs/toolkit';

export const renderWithProviders = (
  component,
  {
    preloadedState = {},
    store = configureStore({ reducer: rootReducer, preloadedState }),
    theme = defaultTheme,
    navigationOptions = {},
    ...renderOptions
  } = {}
) => {
  const Wrapper = ({ children }) => (
    <Provider store={store}>
      <ThemeProvider theme={theme}>
        <NavigationContainer {...navigationOptions}>
          {children}
        </NavigationContainer>
      </ThemeProvider>
    </Provider>
  );

  return {
    ...render(component, { wrapper: Wrapper, ...renderOptions }),
    store,
  };
};

// Usage
const { getByText, store } = renderWithProviders(<MyComponent />, {
  preloadedState: {
    user: { name: 'Test User' },
  },
});</code></pre>

            <h2>Coverage Reports</h2>
            <pre><code class="language-bash"># Run tests with coverage
npm test -- --coverage

# Generate coverage report
npm test -- --coverage --coverageDirectory=coverage

# Open coverage report
open coverage/lcov-report/index.html

# Run specific test file
npm test Button.test.js

# Run tests in watch mode
npm test -- --watch

# Update snapshots
npm test -- --updateSnapshot

# Run tests with specific pattern
npm test -- --testNamePattern="should render"</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>Jest Testing Best Practices:</h4>
                <ul>
                    <li>Write tests that focus on behavior, not implementation</li>
                    <li>Use descriptive test names that explain what is being tested</li>
                    <li>Follow the AAA pattern: Arrange, Act, Assert</li>
                    <li>Keep tests independent and isolated</li>
                    <li>Mock external dependencies properly</li>
                    <li>Use beforeEach/afterEach for setup and cleanup</li>
                    <li>Test edge cases and error scenarios</li>
                    <li>Maintain good test coverage (aim for 80%+)</li>
                    <li>Use snapshot tests sparingly</li>
                    <li>Keep test files close to source files</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Set up comprehensive testing for a React Native app:</p>
                <ul>
                    <li>Configure Jest with TypeScript</li>
                    <li>Write unit tests for components</li>
                    <li>Test custom hooks</li>
                    <li>Test Redux actions and reducers</li>
                    <li>Set up coverage thresholds</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What is the purpose of setupFiles in Jest config?",
            options: [
                "To run tests",
                "To initialize test environment",
                "To generate reports",
                "To update snapshots"
            ],
            correct: 1,
            explanation: "setupFiles runs before the test framework is installed in the environment, perfect for setting up global mocks."
        },
        {
            question: "Which method is used to test asynchronous hooks?",
            options: [
                "waitFor",
                "waitForElement",
                "waitForNextUpdate",
                "waitForAsync"
            ],
            correct: 2,
            explanation: "waitForNextUpdate waits for the next update of a hook when testing asynchronous behavior."
        },
        {
            question: "What does coverage threshold configuration do?",
            options: [
                "Limits test execution time",
                "Sets minimum coverage requirements",
                "Configures test timeout",
                "Defines test patterns"
            ],
            correct: 1,
            explanation: "Coverage thresholds ensure your code maintains a minimum level of test coverage by failing tests if thresholds aren't met."
        }
    ],
    project: {
        title: "Testing Framework Setup",
        description: "Create a complete testing setup for a React Native app with Jest, including unit tests, integration tests, and coverage reports",
        requirements: [
            "Configure Jest for React Native and TypeScript",
            "Set up testing utilities and custom matchers",
            "Write component tests with snapshots",
            "Test custom hooks and async operations",
            "Mock native modules properly",
            "Configure coverage thresholds",
            "Create test helpers for common scenarios",
            "Set up CI/CD test pipeline"
        ],
        hints: [
            "Use @testing-library/react-native",
            "Create reusable test utilities",
            "Mock navigation and native modules",
            "Use MSW for API mocking",
            "Generate coverage badges"
        ]
    }
},
'testing-library': {
    content: `
        <div class="content-section">
            <h1>React Native Testing Library</h1>
            
            <div class="info-box">
                <p>React Native Testing Library builds on top of React's Testing Library, providing utilities to test React Native components with a focus on testing user behavior rather than implementation details.</p>
            </div>

            <h2>Installation & Setup</h2>
            <pre><code class="language-bash"># Install React Native Testing Library
npm install --save-dev @testing-library/react-native

# Additional utilities
npm install --save-dev @testing-library/jest-native
npm install --save-dev @testing-library/react-hooks

# For user event simulation
npm install --save-dev @testing-library/react-native-user-event</code></pre>

            <h2>Basic Component Testing</h2>
            <pre><code class="language-javascript">import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react-native';
import LoginScreen from '../screens/LoginScreen';

describe('LoginScreen', () => {
  it('renders login form', () => {
    render(<LoginScreen />);
    
    // Query elements
    const emailInput = screen.getByPlaceholderText('Email');
    const passwordInput = screen.getByPlaceholderText('Password');
    const loginButton = screen.getByText('Login');
    
    // Assertions
    expect(emailInput).toBeTruthy();
    expect(passwordInput).toBeTruthy();
    expect(loginButton).toBeTruthy();
  });
  
  it('shows validation errors', async () => {
    const { getByText, getByTestId } = render(<LoginScreen />);
    
    // Press login without filling form
    fireEvent.press(getByText('Login'));
    
    // Wait for validation
    const emailError = await screen.findByText('Email is required');
    const passwordError = await screen.findByText('Password is required');
    
    expect(emailError).toBeTruthy();
    expect(passwordError).toBeTruthy();
  });
  
  it('calls onLogin with correct data', () => {
    const onLoginMock = jest.fn();
    const { getByPlaceholderText, getByText } = render(
      <LoginScreen onLogin={onLoginMock} />
    );
    
    // Fill form
    fireEvent.changeText(
      getByPlaceholderText('Email'),
      'test@example.com'
    );
    fireEvent.changeText(
      getByPlaceholderText('Password'),
      'password123'
    );
    
    // Submit
    fireEvent.press(getByText('Login'));
    
    expect(onLoginMock).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123'
    });
  });
});</code></pre>

            <h2>Query Methods</h2>
            <pre><code class="language-javascript">// Different query methods and when to use them
import { render, screen } from '@testing-library/react-native';

describe('Query Methods', () => {
  it('demonstrates different query methods', () => {
    const { 
      getByText,
      queryByText,
      findByText,
      getAllByText,
      queryAllByText,
      findAllByText 
    } = render(<MyComponent />);
    
    // getBy* - Throws error if not found (use when element should exist)
    const title = getByText('Welcome');
    expect(title).toBeTruthy();
    
    // queryBy* - Returns null if not found (use for checking non-existence)
    const missingElement = queryByText('Not There');
    expect(missingElement).toBeNull();
    
    // findBy* - Returns promise, waits for element (use for async elements)
    const asyncElement = await findByText('Loading Complete');
    expect(asyncElement).toBeTruthy();
    
    // *All* variants - Return arrays
    const listItems = getAllByText(/Item/);
    expect(listItems).toHaveLength(3);
  });
  
  // Query priorities (in order of preference)
  it('demonstrates query priorities', () => {
    render(
      <View>
        <Text accessibilityRole="header">Title</Text>
        <TextInput placeholder="Enter name" />
        <Button title="Submit" testID="submit-button" />
        <Text>Regular text</Text>
      </View>
    );
    
    // 1. Accessible queries (preferred)
    screen.getByRole('header');
    screen.getByPlaceholderText('Enter name');
    screen.getByLabelText('Submit'); // if accessibilityLabel is set
    
    // 2. Semantic queries
    screen.getByText('Regular text');
    screen.getByDisplayValue('Current Value'); // for inputs
    
    // 3. Test IDs (last resort)
    screen.getByTestId('submit-button');
  });
});</code></pre>

            <h2>Testing User Interactions</h2>
            <pre><code class="language-javascript">import { render, fireEvent, waitFor } from '@testing-library/react-native';
import UserProfile from '../screens/UserProfile';

describe('User Interactions', () => {
  it('handles text input', () => {
    const { getByPlaceholderText } = render(<UserProfile />);
    const nameInput = getByPlaceholderText('Enter your name');
    
    // Simulate text input
    fireEvent.changeText(nameInput, 'John Doe');
    
    expect(nameInput.props.value).toBe('John Doe');
  });
  
  it('handles multiple selections', () => {
    const { getByText, getAllByRole } = render(<MultiSelectList />);
    
    // Select multiple items
    fireEvent.press(getByText('Item 1'));
    fireEvent.press(getByText('Item 3'));
    
    const selectedItems = getAllByRole('checkbox', { checked: true });
    expect(selectedItems).toHaveLength(2);
  });
  
  it('handles swipe gestures', () => {
    const onSwipeMock = jest.fn();
    const { getByTestId } = render(
      <SwipeableItem onSwipe={onSwipeMock} testID="swipeable" />
    );
    
    const swipeable = getByTestId('swipeable');
    
    // Simulate swipe
    fireEvent(swipeable, 'swipeLeft');
    expect(onSwipeMock).toHaveBeenCalledWith('left');
    
    fireEvent(swipeable, 'swipeRight');
    expect(onSwipeMock).toHaveBeenCalledWith('right');
  });
  
  it('handles scroll events', () => {
    const onEndReachedMock = jest.fn();
    const { getByTestId } = render(
      <FlatList
        testID="list"
        data={Array(20).fill(null).map((_, i) => ({ id: i }))}
        renderItem={({ item }) => <Text>{item.id}</Text>}
        onEndReached={onEndReachedMock}
      />
    );
    
    const list = getByTestId('list');
    
    // Simulate scroll to end
    fireEvent.scroll(list, {
      nativeEvent: {
        contentOffset: { y: 1000 },
        contentSize: { height: 1000 },
        layoutMeasurement: { height: 100 }
      }
    });
    
    expect(onEndReachedMock).toHaveBeenCalled();
  });
});</code></pre>

            <h2>Async Testing</h2>
            <pre><code class="language-javascript">import { render, waitFor, screen } from '@testing-library/react-native';
import AsyncDataScreen from '../screens/AsyncDataScreen';

// Mock API
jest.mock('../api/userApi');
import * as userApi from '../api/userApi';

describe('Async Testing', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  it('loads and displays data', async () => {
    const mockData = [
      { id: 1, name: 'User 1' },
      { id: 2, name: 'User 2' }
    ];
    
    userApi.fetchUsers.mockResolvedValueOnce(mockData);
    
    render(<AsyncDataScreen />);
    
    // Initially shows loading
    expect(screen.getByText('Loading...')).toBeTruthy();
    
    // Wait for data to load
    await waitFor(() => {
      expect(screen.queryByText('Loading...')).toBeNull();
    });
    
    // Check data is displayed
    expect(screen.getByText('User 1')).toBeTruthy();
    expect(screen.getByText('User 2')).toBeTruthy();
  });
  
  it('handles API errors', async () => {
    userApi.fetchUsers.mockRejectedValueOnce(new Error('Network error'));
    
    render(<AsyncDataScreen />);
    
    // Wait for error state
    await waitFor(() => {
      expect(screen.getByText('Error: Network error')).toBeTruthy();
    });
    
    // Test retry
    fireEvent.press(screen.getByText('Retry'));
    
    expect(userApi.fetchUsers).toHaveBeenCalledTimes(2);
  });
  
  it('handles timeout scenarios', async () => {
    jest.useFakeTimers();
    
    render(<TimerComponent />);
    
    expect(screen.getByText('Time: 0')).toBeTruthy();
    
    // Fast-forward time
    act(() => {
      jest.advanceTimersByTime(5000);
    });
    
    await waitFor(() => {
      expect(screen.getByText('Time: 5')).toBeTruthy();
    });
    
    jest.useRealTimers();
  });
});</code></pre>

            <h2>Custom Render Functions</h2>
            <pre><code class="language-javascript">// test-utils.js
import React from 'react';
import { render } from '@testing-library/react-native';
import { NavigationContainer } from '@react-navigation/native';
import { Provider } from 'react-redux';
import { ThemeProvider } from 'styled-components/native';
import { QueryClient, QueryClientProvider } from 'react-query';
import { SafeAreaProvider } from 'react-native-safe-area-context';

// Create custom render with all providers
export const renderWithProviders = (
  ui,
  {
    initialState = {},
    store = createTestStore(initialState),
    theme = defaultTheme,
    queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false },
      },
    }),
    ...renderOptions
  } = {}
) => {
  const Wrapper = ({ children }) => (
    <SafeAreaProvider
      initialMetrics={{
        frame: { x: 0, y: 0, width: 320, height: 640 },
        insets: { top: 0, left: 0, right: 0, bottom: 0 },
      }}
    >
      <Provider store={store}>
        <QueryClientProvider client={queryClient}>
          <ThemeProvider theme={theme}>
            <NavigationContainer>
              {children}
            </NavigationContainer>
          </ThemeProvider>
        </QueryClientProvider>
      </Provider>
    </SafeAreaProvider>
  );

  return {
    ...render(ui, { wrapper: Wrapper, ...renderOptions }),
    store,
    queryClient,
  };
};

// Custom queries
export const withinScreen = (screen) => within(screen);

// Re-export everything
export * from '@testing-library/react-native';
export { renderWithProviders as render };</code></pre>

            <h2>Testing Navigation</h2>
            <pre><code class="language-javascript">import { render, fireEvent } from '@testing-library/react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import HomeScreen from '../screens/HomeScreen';
import DetailsScreen from '../screens/DetailsScreen';

const Stack = createStackNavigator();

const TestNavigator = () => (
  <NavigationContainer>
    <Stack.Navigator>
      <Stack.Screen name="Home" component={HomeScreen} />
      <Stack.Screen name="Details" component={DetailsScreen} />
    </Stack.Navigator>
  </NavigationContainer>
);

describe('Navigation Testing', () => {
  it('navigates between screens', async () => {
    const { getByText, findByText } = render(<TestNavigator />);
    
    // Start at Home
    expect(getByText('Welcome to Home')).toBeTruthy();
    
    // Navigate to Details
    fireEvent.press(getByText('Go to Details'));
    
    // Wait for Details screen
    const detailsTitle = await findByText('Details Screen');
    expect(detailsTitle).toBeTruthy();
    
    // Navigate back
    fireEvent.press(getByText('Go Back'));
    
    // Back at Home
    const homeTitle = await findByText('Welcome to Home');
    expect(homeTitle).toBeTruthy();
  });
  
  it('passes params correctly', async () => {
    const { getByText, findByText } = render(<TestNavigator />);
    
    // Navigate with params
    fireEvent.press(getByText('View Item 123'));
    
    // Check params are received
    const itemText = await findByText('Viewing item: 123');
    expect(itemText).toBeTruthy();
  });
});</code></pre>

            <h2>Testing Accessibility</h2>
            <pre><code class="language-javascript">import { render } from '@testing-library/react-native';
import AccessibleForm from '../components/AccessibleForm';

describe('Accessibility Testing', () => {
  it('has proper accessibility labels', () => {
    const { getByLabelText, getByRole } = render(<AccessibleForm />);
    
    // Test accessibility labels
    expect(getByLabelText('Email address')).toBeTruthy();
    expect(getByLabelText('Password')).toBeTruthy();
    expect(getByLabelText('Submit form')).toBeTruthy();
  });
  
  it('has proper accessibility roles', () => {
    const { getByRole } = render(<AccessibleForm />);
    
    expect(getByRole('button')).toBeTruthy();
    expect(getByRole('header')).toBeTruthy();
  });
  
  it('announces changes for screen readers', async () => {
    const { getByText, getByLabelText } = render(<AccessibleForm />);
    
    // Submit empty form
    fireEvent.press(getByLabelText('Submit form'));
    
    // Check error is announced
    const errorText = await findByText('Please fill all fields');
    expect(errorText).toHaveAccessibilityLiveRegion('assertive');
  });
  
  it('has proper focus management', () => {
    const { getByLabelText } = render(<AccessibleForm />);
    
    const emailInput = getByLabelText('Email address');
    const passwordInput = getByLabelText('Password');
    
    // Check tab order
    expect(emailInput).toHaveProp('accessibilityElementsHidden', false);
    expect(passwordInput).toHaveProp('accessibilityElementsHidden', false);
  });
});</code></pre>

            <h2>Performance Testing</h2>
            <pre><code class="language-javascript">import { render, measurePerformance } from '@testing-library/react-native';
import { measureRenders } from '@testing-library/react-native/pure';
import HeavyComponent from '../components/HeavyComponent';

describe('Performance Testing', () => {
  it('renders within performance budget', async () => {
    const { renderTime } = await measurePerformance(
      <HeavyComponent data={largeDataset} />
    );
    
    // Assert render time is within budget (16ms for 60fps)
    expect(renderTime).toBeLessThan(16);
  });
  
  it('does not re-render unnecessarily', () => {
    const { rerender } = render(
      <HeavyComponent data={data} />
    );
    
    const renderCount = measureRenders(() => {
      // Re-render with same props
      rerender(<HeavyComponent data={data} />);
    });
    
    // Should not re-render with same props
    expect(renderCount).toBe(0);
  });
  
  it('handles large lists efficiently', async () => {
    const items = Array(1000).fill(null).map((_, i) => ({
      id: i,
      title: \`Item \${i}\`
    }));
    
    const start = performance.now();
    
    const { getByTestId } = render(
      <FlatList
        testID="large-list"
        data={items}
        renderItem={({ item }) => <Text>{item.title}</Text>}
        getItemLayout={(data, index) => ({
          length: 50,
          offset: 50 * index,
          index,
        })}
      />
    );
    
    const renderTime = performance.now() - start;
    
    // Should render quickly even with large dataset
    expect(renderTime).toBeLessThan(100);
    
    // Should use virtualization
    const visibleItems = getByTestId('large-list')
      .findAllByType('Text');
    expect(visibleItems.length).toBeLessThan(50); // Not all 1000 items
  });
});</code></pre>

            <h2>Integration Testing</h2>
            <pre><code class="language-javascript">// Full feature integration test
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import { rest } from 'msw';
import { setupServer } from 'msw/node';
import App from '../App';

// Setup MSW server
const server = setupServer(
  rest.get('/api/todos', (req, res, ctx) => {
    return res(ctx.json([
      { id: 1, title: 'Test Todo 1', completed: false },
      { id: 2, title: 'Test Todo 2', completed: true },
    ]));
  }),
  
  rest.post('/api/todos', (req, res, ctx) => {
    return res(ctx.json({
      id: 3,
      title: req.body.title,
      completed: false,
    }));
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

describe('Todo App Integration', () => {
  it('completes full todo workflow', async () => {
    const { getByText, getByPlaceholderText, findByText } = render(<App />);
    
    // Wait for todos to load
    await waitFor(() => {
      expect(getByText('Test Todo 1')).toBeTruthy();
      expect(getByText('Test Todo 2')).toBeTruthy();
    });
    
    // Add new todo
    const input = getByPlaceholderText('Add a new todo');
    fireEvent.changeText(input, 'New Todo Item');
    fireEvent.press(getByText('Add'));
    
    // Wait for new todo to appear
    const newTodo = await findByText('New Todo Item');
    expect(newTodo).toBeTruthy();
    
    // Mark as completed
    fireEvent.press(newTodo);
    
    await waitFor(() => {
      expect(newTodo).toHaveStyle({ textDecorationLine: 'line-through' });
    });
    
    // Filter completed
    fireEvent.press(getByText('Show Active'));
    
    expect(getByText('Test Todo 1')).toBeTruthy();
    expect(() => getByText('Test Todo 2')).toThrow();
    expect(() => getByText('New Todo Item')).toThrow();
  });
});</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>React Native Testing Library Best Practices:</h4>
                <ul>
                    <li>Query by accessible elements first (role, label, text)</li>
                    <li>Avoid testing implementation details</li>
                    <li>Use userEvent for more realistic interactions</li>
                    <li>Write tests from the user's perspective</li>
                    <li>Keep tests focused and independent</li>
                    <li>Use custom render functions for common setups</li>
                    <li>Test the integration, not units in isolation</li>
                    <li>Wait for async operations properly</li>
                    <li>Mock at the network level, not component level</li>
                    <li>Test accessibility as part of regular tests</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Create comprehensive tests for a feature:</p>
                <ul>
                    <li>Test user registration flow</li>
                    <li>Test form validation</li>
                    <li>Test async data loading</li>
                    <li>Test navigation between screens</li>
                    <li>Test error states and recovery</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the difference between getBy and queryBy queries?",
            options: [
                "No difference",
                "getBy throws if not found, queryBy returns null",
                "queryBy is faster",
                "getBy is async"
            ],
            correct: 1,
            explanation: "getBy queries throw an error if element is not found, while queryBy returns null, making it useful for asserting non-existence."
        },
        {
            question: "Which query should you use for elements that appear after async operations?",
            options: [
                "getBy",
                "queryBy",
                "findBy",
                "searchBy"
            ],
            correct: 2,
            explanation: "findBy queries return a promise and wait for the element to appear, perfect for testing async behavior."
        },
        {
            question: "What's the recommended order for querying elements?",
            options: [
                "testID, text, role",
                "role, label, text, testID",
                "text, testID, role",
                "It doesn't matter"
            ],
            correct: 1,
            explanation: "Prefer accessible queries (role, label) first, then text, and use testID as a last resort."
        }
    ],
    project: {
        title: "E-commerce App Test Suite",
        description: "Build a comprehensive test suite for an e-commerce app using React Native Testing Library",
        requirements: [
            "Test product listing and search",
            "Test add to cart functionality",
            "Test checkout flow",
            "Test user authentication",
            "Test payment integration",
            "Test order history",
            "Mock API responses",
            "Test error scenarios"
        ],
        hints: [
            "Use MSW for API mocking",
            "Create custom render with providers",
            "Test from user perspective",
            "Use findBy for async elements",
            "Test accessibility"
        ]
    }
},
'detox': {
    content: `
        <div class="content-section">
            <h1>E2E Testing with Detox</h1>
            
            <div class="info-box">
                <p>Detox is a gray-box end-to-end testing framework for React Native apps. It allows you to write and run tests that simulate real user interactions on actual devices or simulators.</p>
            </div>

            <h2>Installation & Setup</h2>
            <pre><code class="language-bash"># Install Detox CLI globally
npm install -g detox-cli

# Install Detox in your project
npm install --save-dev detox

# Additional dependencies for Jest
npm install --save-dev jest-circus

# iOS specific setup
brew tap wix/brew
brew install applesimutils

# Android specific setup
# Ensure you have Android SDK and emulator installed

# Initialize Detox in your project
detox init -r jest</code></pre>

            <h2>Detox Configuration</h2>
            <pre><code class="language-javascript">// .detoxrc.json
{
  "testRunner": "jest",
  "runnerConfig": "e2e/config.json",
  "skipLegacyWorkersInjection": true,
  "apps": {
    "ios": {
      "type": "ios.app",
      "binaryPath": "ios/build/Build/Products/Debug-iphonesimulator/YourApp.app",
      "build": "xcodebuild -workspace ios/YourApp.xcworkspace -scheme YourApp -configuration Debug -sdk iphonesimulator -derivedDataPath ios/build"
    },
    "android": {
      "type": "android.apk",
      "binaryPath": "android/app/build/outputs/apk/debug/app-debug.apk",
      "build": "cd android && ./gradlew assembleDebug assembleAndroidTest -DtestBuildType=debug",
      "reversePorts": [8081]
    }
  },
  "devices": {
    "simulator": {
      "type": "ios.simulator",
      "device": {
        "type": "iPhone 14"
      }
    },
    "emulator": {
      "type": "android.emulator",
      "device": {
        "avdName": "Pixel_5_API_31"
      }
    }
  },
  "configurations": {
    "ios": {
      "device": "simulator",
      "app": "ios"
    },
    "android": {
      "device": "emulator",
      "app": "android"
    }
  }
}

// e2e/config.json
{
  "maxWorkers": 1,
  "testEnvironment": "./environment",
  "testRunner": "jest-circus/runner",
  "testTimeout": 120000,
  "testRegex": "\\\\.e2e\\\\.js$",
  "reporters": ["detox/runners/jest/streamlineReporter"],
  "verbose": true
}

// e2e/environment.js
const {
  DetoxCircusEnvironment,
  SpecReporter,
  WorkerAssignReporter,
} = require('detox/runners/jest-circus');

class CustomDetoxEnvironment extends DetoxCircusEnvironment {
  constructor(config, context) {
    super(config, context);
    
    // Add custom setup here
    this.initTimeout = 300000;
  }

  async setup() {
    await super.setup();
    // Additional setup
  }

  async teardown() {
    await super.teardown();
    // Additional teardown
  }
}

module.exports = CustomDetoxEnvironment;</code></pre>

            <h2>Writing E2E Tests</h2>
            <pre><code class="language-javascript">// e2e/firstTest.e2e.js
describe('App E2E', () => {
  beforeAll(async () => {
    await device.launchApp();
  });

  beforeEach(async () => {
    await device.reloadReactNative();
  });

  it('should show welcome screen', async () => {
    // Check if welcome screen is visible
    await expect(element(by.id('welcome-screen'))).toBeVisible();
    await expect(element(by.text('Welcome to MyApp'))).toBeVisible();
  });

  it('should navigate to login screen', async () => {
    // Tap on login button
    await element(by.id('login-button')).tap();
    
    // Verify navigation
    await expect(element(by.id('login-screen'))).toBeVisible();
    await expect(element(by.text('Sign In'))).toBeVisible();
  });

  it('should login successfully', async () => {
    // Navigate to login
    await element(by.id('login-button')).tap();
    
    // Fill in credentials
    await element(by.id('email-input')).typeText('test@example.com');
    await element(by.id('password-input')).typeText('password123');
    
    // Hide keyboard
    await element(by.id('login-screen')).tap();
    
    // Submit form
    await element(by.id('submit-button')).tap();
    
    // Wait for and verify home screen
    await waitFor(element(by.id('home-screen')))
      .toBeVisible()
      .withTimeout(5000);
    
    await expect(element(by.text('Welcome, Test User'))).toBeVisible();
  });

  it('should handle login errors', async () => {
    await element(by.id('login-button')).tap();
    
    // Submit with empty fields
    await element(by.id('submit-button')).tap();
    
    // Check error messages
    await expect(element(by.text('Email is required'))).toBeVisible();
    await expect(element(by.text('Password is required'))).toBeVisible();
    
    // Try with invalid credentials
    await element(by.id('email-input')).typeText('wrong@email.com');
    await element(by.id('password-input')).typeText('wrongpass');
    await element(by.id('submit-button')).tap();
    
    await waitFor(element(by.text('Invalid credentials')))
      .toBeVisible()
      .withTimeout(3000);
  });
});</code></pre>

            <h2>Advanced Interactions</h2>
            <pre><code class="language-javascript">// e2e/advancedInteractions.e2e.js
describe('Advanced Interactions', () => {
  beforeEach(async () => {
    await device.launchApp({ newInstance: true });
  });

  it('should handle scroll and swipe', async () => {
    // Scroll to bottom of list
    await waitFor(element(by.id('list-item-50')))
      .toBeVisible()
      .whileElement(by.id('scroll-view'))
      .scroll(500, 'down');
    
    // Swipe on item
    await element(by.id('swipeable-item')).swipe('left', 'fast', 0.75);
    await expect(element(by.id('delete-button'))).toBeVisible();
    
    // Swipe to dismiss
    await element(by.id('modal')).swipe('down');
    await expect(element(by.id('modal'))).not.toBeVisible();
  });

  it('should handle long press', async () => {
    // Long press to show context menu
    await element(by.id('long-press-item')).longPress();
    
    // Verify context menu appears
    await expect(element(by.text('Copy'))).toBeVisible();
    await expect(element(by.text('Delete'))).toBeVisible();
    
    // Select option
    await element(by.text('Delete')).tap();
    
    // Confirm deletion
    await element(by.text('Confirm')).tap();
    await expect(element(by.id('long-press-item'))).not.toExist();
  });

  it('should handle multi-tap', async () => {
    // Double tap to like
    await element(by.id('photo')).multiTap(2);
    await expect(element(by.id('like-animation'))).toBeVisible();
    
    // Triple tap for options
    await element(by.id('photo')).multiTap(3);
    await expect(element(by.id('photo-options'))).toBeVisible();
  });

  it('should handle date picker', async () => {
    await element(by.id('date-input')).tap();
    
    // iOS date picker
    if (device.getPlatform() === 'ios') {
      await element(by.type('UIPickerView')).setColumnToValue(0, 'December');
      await element(by.type('UIPickerView')).setColumnToValue(1, '25');
      await element(by.type('UIPickerView')).setColumnToValue(2, '2023');
    } else {
      // Android date picker
      await element(by.text('25')).tap();
      await element(by.text('OK')).tap();
    }
    
    await expect(element(by.id('date-input'))).toHaveText('12/25/2023');
  });
});</code></pre>

            <h2>Testing Different Scenarios</h2>
            <pre><code class="language-javascript">// e2e/scenarios.e2e.js
describe('Real World Scenarios', () => {
  it('should handle offline mode', async () => {
    // Login first
    await element(by.id('login-button')).tap();
    await element(by.id('email-input')).typeText('test@example.com');
    await element(by.id('password-input')).typeText('password123');
    await element(by.id('submit-button')).tap();
    
    // Go offline
    await device.setURLBlacklist(['.*']);
    
    // Try to load data
    await element(by.id('refresh-button')).tap();
    
    // Should show offline message
    await expect(element(by.text('You are offline'))).toBeVisible();
    
    // Should show cached data
    await expect(element(by.id('cached-data'))).toBeVisible();
    
    // Go back online
    await device.clearURLBlacklist();
    
    // Refresh should work
    await element(by.id('refresh-button')).tap();
    await waitFor(element(by.id('fresh-data')))
      .toBeVisible()
      .withTimeout(5000);
  });

  it('should handle deep linking', async () => {
    // Open app with deep link
    await device.launchApp({
      newInstance: true,
      url: 'myapp://product/123',
    });
    
    // Should navigate directly to product
    await expect(element(by.id('product-screen'))).toBeVisible();
    await expect(element(by.text('Product #123'))).toBeVisible();
    
    // Test another deep link
    await device.openURL({ url: 'myapp://profile/settings' });
    
    await expect(element(by.id('settings-screen'))).toBeVisible();
  });

  it('should handle push notifications', async () => {
    // Grant notification permissions
    await device.launchApp({
      permissions: { notifications: 'YES' },
    });
    
    // Send local notification
    await element(by.id('send-notification-button')).tap();
    
    // Wait for notification
    await device.sendUserNotification({
      trigger: {
        type: 'push',
      },
      title: 'Test Notification',
      body: 'This is a test',
      userInfo: {
        deepLink: 'myapp://inbox/123',
      },
    });
    
    // Tap notification
    await element(by.text('Test Notification')).tap();
    
    // Should navigate to inbox
    await expect(element(by.id('inbox-screen'))).toBeVisible();
    await expect(element(by.id('message-123'))).toBeVisible();
  });

  it('should handle permissions', async () => {
    // Launch with specific permissions
    await device.launchApp({
      permissions: {
        camera: 'NO',
        photos: 'YES',
        location: 'always',
      },
    });
    
    // Try to use camera
    await element(by.id('camera-button')).tap();
    
    // Should show permission denied
    await expect(element(by.text('Camera permission denied'))).toBeVisible();
    
    // Use photo library (should work)
    await element(by.id('photo-library-button')).tap();
    await expect(element(by.id('photo-picker'))).toBeVisible();
  });
});</code></pre>

            <h2>Test Helpers & Utilities</h2>
            <pre><code class="language-javascript">// e2e/helpers.js
const login = async (email, password) => {
  await element(by.id('login-button')).tap();
  await element(by.id('email-input')).typeText(email);
  await element(by.id('password-input')).typeText(password);
  await element(by.id('login-screen')).tap(); // Hide keyboard
  await element(by.id('submit-button')).tap();
  
  await waitFor(element(by.id('home-screen')))
    .toBeVisible()
    .withTimeout(5000);
};

const logout = async () => {
  await element(by.id('profile-tab')).tap();
  await element(by.id('logout-button')).tap();
  await element(by.text('Confirm')).tap();
  
  await waitFor(element(by.id('welcome-screen')))
    .toBeVisible()
    .withTimeout(3000);
};

const waitForElementById = async (testID, timeout = 5000) => {
  await waitFor(element(by.id(testID)))
    .toBeVisible()
    .withTimeout(timeout);
};

const scrollToElement = async (elementId, scrollViewId, direction = 'down') => {
  await waitFor(element(by.id(elementId)))
    .toBeVisible()
    .whileElement(by.id(scrollViewId))
    .scroll(500, direction);
};

const typeTextAndDismissKeyboard = async (elementId, text) => {
  await element(by.id(elementId)).typeText(text);
  await element(by.id('root-view')).tap();
};

// Platform specific helpers
const tapBackButton = async () => {
  if (device.getPlatform() === 'ios') {
    await element(by.traits(['button']).and(by.label('Back'))).tap();
  } else {
    await device.pressBack();
  }
};

module.exports = {
  login,
  logout,
  waitForElementById,
  scrollToElement,
  typeTextAndDismissKeyboard,
  tapBackButton,
};</code></pre>

            <h2>Mocking & Test Data</h2>
            <pre><code class="language-javascript">// e2e/init.js
const detox = require('detox');
const config = require('../.detoxrc.json');
const adapter = require('detox/runners/jest/adapter');

jest.setTimeout(120000);
jasmine.getEnv().addReporter(adapter);

beforeAll(async () => {
  await detox.init(config);
  
  // Set up test data on backend
  await setupTestData();
  
  // Configure app for testing
  await device.launchApp({
    launchArgs: {
      detoxPrintBusyIdleResources: 'YES',
      detoxURLBlacklistRegex: '.*\\\\.google\\\\.com.*',
      isE2E: 'true', // Flag for app to use test configuration
    },
  });
});

beforeEach(async () => {
  await adapter.beforeEach();
});

afterAll(async () => {
  await adapter.afterAll();
  await detox.cleanup();
  
  // Clean up test data
  await cleanupTestData();
});

// Test data setup
const setupTestData = async () => {
  // Create test users, products, etc.
  const response = await fetch('https://api.test.com/e2e/setup', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      users: [
        { email: 'test@example.com', password: 'password123' },
        { email: 'test2@example.com', password: 'password456' },
      ],
      products: [
        { id: 123, name: 'Test Product', price: 99.99 },
      ],
    }),
  });
  
  if (!response.ok) {
    throw new Error('Failed to setup test data');
  }
};

const cleanupTestData = async () => {
  await fetch('https://api.test.com/e2e/cleanup', {
    method: 'POST',
  });
};</code></pre>

            <h2>CI/CD Integration</h2>
            <pre><code class="language-yaml"># .github/workflows/e2e-tests.yml
name: E2E Tests

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:
  test-ios:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Install Detox dependencies
        run: |
          brew tap wix/brew
          brew install applesimutils
          
      - name: Build iOS app
        run: |
          cd ios
          pod install
          cd ..
          detox build -c ios
          
      - name: Run E2E tests
        run: |
          detox test -c ios --cleanup --headless
          
      - name: Upload artifacts
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: detox-artifacts-ios
          path: artifacts/

  test-android:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
          
      - name: Setup Android SDK
        uses: android-actions/setup-android@v2
        
      - name: Install dependencies
        run: npm ci
        
      - name: Start emulator
        run: |
          $ANDROID_HOME/emulator/emulator -avd Pixel_5_API_31 -no-window -no-boot-anim &
          adb wait-for-device
          
      - name: Build Android app
        run: detox build -c android
        
      - name: Run E2E tests
        run: detox test -c android --cleanup --headless</code></pre>

            <h2>Debugging E2E Tests</h2>
            <pre><code class="language-javascript">// Debug configuration
// e2e/debug.config.js
module.exports = {
  // Slow down animations for debugging
  launchArgs: {
    detoxPrintBusyIdleResources: 'YES',
    detoxEnableSynchronization: 'NO', // Disable for debugging
  },
  
  // Take screenshots on failure
  artifacts: {
    rootDir: './e2e/artifacts',
    plugins: {
      screenshot: {
        shouldTakeAutomaticSnapshots: true,
        keepOnlyFailedTestsArtifacts: true,
        takeWhen: {
          testStart: false,
          testDone: true,
        },
      },
      video: {
        android: {
          bitRate: 4000000,
        },
        simulator: {
          codec: 'h264',
        },
      },
      log: {
        enabled: true,
      },
      uiHierarchy: 'enabled',
    },
  },
};

// Debug helpers
const debug = async () => {
  // Print UI hierarchy
  await device.generateViewHierarchyXml();
  
  // Take screenshot
  await device.takeScreenshot('debug-screenshot');
  
  // Get element attributes
  const attributes = await element(by.id('my-element')).getAttributes();
  console.log('Element attributes:', attributes);
};

// Wait for debugger
const waitForDebugger = async () => {
  await new Promise(resolve => {
    console.log('Waiting for debugger... Press any key to continue');
    process.stdin.once('data', resolve);
  });
};</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>Detox E2E Testing Best Practices:</h4>
                <ul>
                    <li>Use testIDs consistently across your app</li>
                    <li>Keep tests independent and idempotent</li>
                    <li>Use page object pattern for better maintainability</li>
                    <li>Mock external dependencies and APIs</li>
                    <li>Run tests on both iOS and Android</li>
                    <li>Use beforeEach to reset app state</li>
                    <li>Handle platform differences gracefully</li>
                    <li>Set reasonable timeouts for async operations</li>
                    <li>Take screenshots/videos on test failures</li>
                    <li>Run E2E tests in CI/CD pipeline</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Create E2E tests for a complete user flow:</p>
                <ul>
                    <li>User registration and onboarding</li>
                    <li>Browse products and add to cart</li>
                    <li>Complete checkout process</li>
                    <li>Test error scenarios</li>
                    <li>Test offline functionality</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What type of testing framework is Detox?",
            options: [
                "White-box testing",
                "Black-box testing",
                "Gray-box testing",
                "Unit testing"
            ],
            correct: 2,
            explanation: "Detox is a gray-box testing framework, meaning it has some knowledge of the app's internals while testing from a user perspective."
        },
        {
            question: "Which method waits for an element to appear?",
            options: [
                "expect(element()).toExist()",
                "waitFor(element()).toBeVisible()",
                "element().wait()",
                "delay(element())"
            ],
            correct: 1,
            explanation: "waitFor(element()).toBeVisible() waits for an element to appear with optional timeout configuration."
        },
        {
            question: "How do you handle platform-specific code in Detox tests?",
            options: [
                "Write separate test files",
                "Use device.getPlatform() conditionals",
                "Detox handles it automatically",
                "Platform differences aren't supported"
            ],
            correct: 1,
            explanation: "Use device.getPlatform() to check the platform and write conditional logic for platform-specific interactions."
        }
    ],
    project: {
        title: "Complete E2E Test Suite",
        description: "Build a comprehensive E2E test suite for a social media app using Detox",
        requirements: [
            "Test user registration and login flows",
            "Test posting and interacting with content",
            "Test real-time messaging",
            "Test push notifications",
            "Test offline mode and sync",
            "Test deep linking scenarios",
            "Handle permissions testing",
            "Set up CI/CD integration"
        ],
        hints: [
            "Use page object pattern",
            "Create reusable test helpers",
            "Mock backend responses",
            "Test on both platforms",
            "Record videos on failures"
        ]
    }
},
'performance': {
    content: `
        <div class="content-section">
            <h1>Performance Optimization</h1>
            
            <div class="info-box">
                <p>Learn how to identify and fix performance bottlenecks in React Native apps. Master profiling tools, optimization techniques, and best practices for building fast, responsive mobile applications.</p>
            </div>

            <h2>Performance Monitoring Setup</h2>
            <pre><code class="language-javascript">// Performance monitoring utility
import { InteractionManager } from 'react-native';
import performance from 'react-native-performance';

class PerformanceMonitor {
  constructor() {
    this.metrics = {};
    this.observers = [];
    this.setupPerformanceObserver();
  }

  setupPerformanceObserver() {
    // Monitor JS frame rate
    let frameCount = 0;
    let lastTime = performance.now();
    
    const measureFPS = () => {
      frameCount++;
      const currentTime = performance.now();
      
      if (currentTime >= lastTime + 1000) {
        const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        this.recordMetric('fps', fps);
        
        if (fps < 55) {
          console.warn(\`Low FPS detected: \${fps}\`);
        }
        
        frameCount = 0;
        lastTime = currentTime;
      }
      
      requestAnimationFrame(measureFPS);
    };
    
    measureFPS();
  }

  startMeasure(name) {
    performance.mark(\`\${name}-start\`);
  }

  endMeasure(name) {
    performance.mark(\`\${name}-end\`);
    performance.measure(name, \`\${name}-start\`, \`\${name}-end\`);
    
    const measure = performance.getEntriesByName(name)[0];
    this.recordMetric(name, measure.duration);
    
    return measure.duration;
  }

  recordMetric(name, value) {
    if (!this.metrics[name]) {
      this.metrics[name] = [];
    }
    
    this.metrics[name].push({
      value,
      timestamp: Date.now()
    });
    
    // Keep only last 100 entries
    if (this.metrics[name].length > 100) {
      this.metrics[name].shift();
    }
  }

  getAverageMetric(name) {
    const values = this.metrics[name] || [];
    if (values.length === 0) return 0;
    
    const sum = values.reduce((acc, item) => acc + item.value, 0);
    return sum / values.length;
  }

  generateReport() {
    const report = {};
    
    Object.keys(this.metrics).forEach(key => {
      const values = this.metrics[key].map(m => m.value);
      report[key] = {
        average: this.getAverageMetric(key),
        min: Math.min(...values),
        max: Math.max(...values),
        current: values[values.length - 1]
      };
    });
    
    return report;
  }
}

export const performanceMonitor = new PerformanceMonitor();

// React component performance HOC
export const withPerformanceMonitoring = (Component, componentName) => {
  return React.forwardRef((props, ref) => {
    useEffect(() => {
      performanceMonitor.startMeasure(\`\${componentName}-mount\`);
      
      return () => {
        performanceMonitor.endMeasure(\`\${componentName}-mount\`);
      };
    }, []);
    
    useEffect(() => {
      performanceMonitor.startMeasure(\`\${componentName}-render\`);
      performanceMonitor.endMeasure(\`\${componentName}-render\`);
    });
    
    return <Component ref={ref} {...props} />;
  });
};</code></pre>

            <h2>React Component Optimization</h2>
            <pre><code class="language-javascript">import React, { memo, useMemo, useCallback, useState, useRef } from 'react';
import { FlatList, View, Text } from 'react-native';

// Memoized component
const ExpensiveComponent = memo(({ data, onPress }) => {
  console.log('ExpensiveComponent rendered');
  
  // Expensive calculation memoized
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      computed: heavyComputation(item)
    }));
  }, [data]);
  
  return (
    <View>
      {processedData.map(item => (
        <TouchableOpacity key={item.id} onPress={() => onPress(item.id)}>
          <Text>{item.computed}</Text>
        </TouchableOpacity>
      ))}
    </View>
  );
}, (prevProps, nextProps) => {
  // Custom comparison function
  return (
    prevProps.data === nextProps.data &&
    prevProps.onPress === nextProps.onPress
  );
});

// Optimized list component
const OptimizedList = ({ items }) => {
  const [selectedIds, setSelectedIds] = useState(new Set());
  
  // Memoized callbacks
  const handlePress = useCallback((id) => {
    setSelectedIds(prev => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
  }, []);
  
  const renderItem = useCallback(({ item }) => (
    <ListItem 
      item={item} 
      isSelected={selectedIds.has(item.id)}
      onPress={handlePress}
    />
  ), [selectedIds, handlePress]);
  
  const keyExtractor = useCallback((item) => item.id.toString(), []);
  
  const getItemLayout = useCallback((data, index) => ({
    length: ITEM_HEIGHT,
    offset: ITEM_HEIGHT * index,
    index,
  }), []);
  
  return (
    <FlatList
      data={items}
      renderItem={renderItem}
      keyExtractor={keyExtractor}
      getItemLayout={getItemLayout}
      removeClippedSubviews={true}
      maxToRenderPerBatch={10}
      updateCellsBatchingPeriod={50}
      windowSize={10}
      initialNumToRender={10}
      // Performance optimization props
      onEndReachedThreshold={0.5}
      maintainVisibleContentPosition={{
        minIndexForVisible: 0,
      }}
    />
  );
};

// Prevent unnecessary re-renders
const ListItem = memo(({ item, isSelected, onPress }) => {
  // Use refs for values that don't need re-renders
  const animationRef = useRef(new Animated.Value(0));
  
  return (
    <TouchableOpacity 
      onPress={() => onPress(item.id)}
      activeOpacity={0.7}
    >
      <View style={[styles.item, isSelected && styles.selected]}>
        <Text>{item.title}</Text>
      </View>
    </TouchableOpacity>
  );
}, (prevProps, nextProps) => {
  return (
    prevProps.item.id === nextProps.item.id &&
    prevProps.isSelected === nextProps.isSelected
  );
});</code></pre>

            <h2>Image Optimization</h2>
            <pre><code class="language-javascript">import FastImage from 'react-native-fast-image';
import { Image } from 'react-native';

// Image optimization component
const OptimizedImage = ({ source, style, ...props }) => {
  const [error, setError] = useState(false);
  const [loading, setLoading] = useState(true);
  
  // Calculate optimal image size
  const optimizedSource = useMemo(() => {
    if (typeof source === 'string') {
      // Add size parameters based on container size
      const { width, height } = style || {};
      const params = new URLSearchParams({
        w: Math.ceil(width * PixelRatio.get()),
        h: Math.ceil(height * PixelRatio.get()),
        q: 80, // Quality
        fm: 'webp', // Format
      });
      
      return {
        uri: \`\${source}?\${params.toString()}\`,
        priority: FastImage.priority.normal,
        cache: FastImage.cacheControl.immutable,
      };
    }
    return source;
  }, [source, style]);
  
  if (error) {
    return <Image source={require('./placeholder.png')} style={style} />;
  }
  
  return (
    <>
      {loading && (
        <View style={[style, styles.placeholder]}>
          <ActivityIndicator />
        </View>
      )}
      <FastImage
        source={optimizedSource}
        style={[style, loading && styles.hidden]}
        onLoadEnd={() => setLoading(false)}
        onError={() => setError(true)}
        {...props}
      />
    </>
  );
};

// Image preloading utility
export const preloadImages = async (imageUrls) => {
  const preloadPromises = imageUrls.map(url => 
    FastImage.preload([{
      uri: url,
      priority: FastImage.priority.high,
      cache: FastImage.cacheControl.immutable,
    }])
  );
  
  await Promise.all(preloadPromises);
};

// Lazy load images in list
const LazyImageList = ({ images }) => {
  const viewabilityConfig = useRef({
    itemVisiblePercentThreshold: 50,
    minimumViewTime: 300,
  }).current;
  
  const [visibleItems, setVisibleItems] = useState(new Set());
  
  const onViewableItemsChanged = useCallback(({ viewableItems }) => {
    setVisibleItems(new Set(viewableItems.map(item => item.key)));
  }, []);
  
  const renderImage = useCallback(({ item }) => (
    <View style={styles.imageContainer}>
      {visibleItems.has(item.id) ? (
        <OptimizedImage 
          source={{ uri: item.url }}
          style={styles.image}
        />
      ) : (
        <View style={[styles.image, styles.placeholder]} />
      )}
    </View>
  ), [visibleItems]);
  
  return (
    <FlatList
      data={images}
      renderItem={renderImage}
      keyExtractor={item => item.id}
      viewabilityConfig={viewabilityConfig}
      onViewableItemsChanged={onViewableItemsChanged}
    />
  );
};</code></pre>

            <h2>JavaScript Bundle Optimization</h2>
            <pre><code class="language-javascript">// Metro configuration for bundle optimization
// metro.config.js
const { getDefaultConfig } = require('metro-config');

module.exports = (async () => {
  const {
    resolver: { sourceExts, assetExts },
  } = await getDefaultConfig();
  
  return {
    transformer: {
      babelTransformerPath: require.resolve('react-native-svg-transformer'),
      minifierPath: 'metro-minify-terser',
      minifierConfig: {
        ecma: 8,
        keep_fnames: true,
        module: true,
        mangle: {
          module: true,
          keep_fnames: true,
        },
        compress: {
          drop_console: true,
          drop_debugger: true,
        },
      },
    },
    resolver: {
      assetExts: assetExts.filter((ext) => ext !== 'svg'),
      sourceExts: [...sourceExts, 'svg'],
    },
    serializer: {
      processModuleFilter: (module) => {
        // Remove test files from bundle
        return !module.path.includes('__tests__') &&
               !module.path.includes('.test.') &&
               !module.path.includes('.spec.');
      },
    },
  };
})();

// Code splitting with lazy loading
const LazyComponent = lazy(() => 
  import(/* webpackChunkName: "lazy-component" */ './LazyComponent')
);

const App = () => {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <LazyComponent />
    </Suspense>
  );
};

// Dynamic imports for conditional features
const loadPremiumFeatures = async () => {
  if (user.isPremium) {
    const { PremiumFeatures } = await import('./features/premium');
    return PremiumFeatures;
  }
  return null;
};</code></pre>

            <h2>Memory Management</h2>
            <pre><code class="language-javascript">// Memory leak prevention
class MemoryManager {
  constructor() {
    this.subscriptions = new Set();
    this.timers = new Set();
    this.listeners = new Map();
  }

  addSubscription(subscription) {
    this.subscriptions.add(subscription);
    return subscription;
  }

  addTimer(timer) {
    this.timers.add(timer);
    return timer;
  }

  addEventListener(target, event, handler) {
    if (!this.listeners.has(target)) {
      this.listeners.set(target, new Map());
    }
    
    this.listeners.get(target).set(event, handler);
    target.addEventListener(event, handler);
  }

  cleanup() {
    // Clean up subscriptions
    this.subscriptions.forEach(sub => {
      if (sub && typeof sub.unsubscribe === 'function') {
        sub.unsubscribe();
      } else if (sub && typeof sub.remove === 'function') {
        sub.remove();
      }
    });
    this.subscriptions.clear();

    // Clear timers
    this.timers.forEach(timer => {
      clearTimeout(timer);
      clearInterval(timer);
    });
    this.timers.clear();

    // Remove event listeners
    this.listeners.forEach((events, target) => {
      events.forEach((handler, event) => {
        target.removeEventListener(event, handler);
      });
    });
    this.listeners.clear();
  }
}

// Hook for memory management
export const useMemoryManager = () => {
  const managerRef = useRef(new MemoryManager());

  useEffect(() => {
    return () => {
      managerRef.current.cleanup();
    };
  }, []);

  return managerRef.current;
};

// Component with proper cleanup
const DataComponent = () => {
  const memoryManager = useMemoryManager();
  const [data, setData] = useState(null);

  useEffect(() => {
    // API subscription
    const subscription = memoryManager.addSubscription(
      api.subscribeToUpdates((newData) => {
        setData(newData);
      })
    );

    // Timer
    const timer = memoryManager.addTimer(
      setInterval(() => {
        console.log('Periodic task');
      }, 5000)
    );

    // Event listener
    memoryManager.addEventListener(
      AppState,
      'change',
      handleAppStateChange
    );

    // Cleanup happens automatically
  }, []);

  return <View>{/* Component content */}</View>;
};</code></pre>

            <h2>Native Performance Optimization</h2>
            <pre><code class="language-javascript">// Use native driver for animations
const animateWithNativeDriver = () => {
  const animatedValue = useRef(new Animated.Value(0)).current;

  const startAnimation = () => {
    Animated.timing(animatedValue, {
      toValue: 1,
      duration: 300,
      useNativeDriver: true, // Run on UI thread
    }).start();
  };

  const animatedStyle = {
    transform: [{
      translateY: animatedValue.interpolate({
        inputRange: [0, 1],
        outputRange: [0, -100],
      }),
    }],
    opacity: animatedValue,
  };

  return { animatedStyle, startAnimation };
};

// InteractionManager for heavy operations
const HeavyComponent = () => {
  const [isReady, setIsReady] = useState(false);
  const [processedData, setProcessedData] = useState(null);

  useEffect(() => {
    // Defer heavy computation
    const interaction = InteractionManager.runAfterInteractions(() => {
      const result = performHeavyComputation();
      setProcessedData(result);
      setIsReady(true);
    });

    return () => interaction.cancel();
  }, []);

  if (!isReady) {
    return <LoadingPlaceholder />;
  }

  return <DataDisplay data={processedData} />;
};

// Optimize navigation transitions
const optimizedScreenOptions = {
  cardStyleInterpolator: ({ current, layouts }) => {
    return {
      cardStyle: {
        transform: [
          {
            translateX: current.progress.interpolate({
              inputRange: [0, 1],
              outputRange: [layouts.screen.width, 0],
            }),
          },
        ],
      },
    };
  },
  transitionSpec: {
    open: {
      animation: 'timing',
      config: {
        duration: 200,
        useNativeDriver: true,
      },
    },
    close: {
      animation: 'timing',
      config: {
        duration: 200,
        useNativeDriver: true,
      },
    },
  },
};</code></pre>

            <h2>Profiling & Debugging Performance</h2>
            <pre><code class="language-javascript">// Performance profiler component
const PerformanceProfiler = ({ children, id }) => {
  const onRender = (
    id,
    phase,
    actualDuration,
    baseDuration,
    startTime,
    commitTime,
    interactions
  ) => {
    if (actualDuration > 16) {
      console.warn(\`Slow render detected in \${id}:\`, {
        phase,
        actualDuration,
        baseDuration,
      });
    }

    // Send metrics to analytics
    analytics.track('component_render', {
      componentId: id,
      phase,
      duration: actualDuration,
      timestamp: commitTime,
    });
  };

  return (
    <Profiler id={id} onRender={onRender}>
      {children}
    </Profiler>
  );
};

// Custom hook for performance debugging
const useWhyDidYouRender = (componentName, props) => {
  const previousProps = useRef();

  useEffect(() => {
    if (previousProps.current) {
      const allKeys = Object.keys({ ...previousProps.current, ...props });
      const changedProps = {};

      allKeys.forEach((key) => {
        if (previousProps.current[key] !== props[key]) {
          changedProps[key] = {
            from: previousProps.current[key],
            to: props[key],
          };
        }
      });

      if (Object.keys(changedProps).length) {
        console.log(\`[\${componentName}] Props changed:\`, changedProps);
      }
    }

    previousProps.current = props;
  });
};

// Performance monitoring dashboard
const PerformanceDebugView = () => {
  const [metrics, setMetrics] = useState(performanceMonitor.generateReport());
  const [isVisible, setIsVisible] = useState(__DEV__);

  useEffect(() => {
    if (!__DEV__) return;

    const interval = setInterval(() => {
      setMetrics(performanceMonitor.generateReport());
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  if (!isVisible) return null;

  return (
    <View style={styles.debugOverlay}>
      <Text style={styles.debugTitle}>Performance Metrics</Text>
      {Object.entries(metrics).map(([key, value]) => (
        <Text key={key} style={styles.debugText}>
          {key}: {value.current?.toFixed(2)} (avg: {value.average?.toFixed(2)})
        </Text>
      ))}
      <TouchableOpacity onPress={() => setIsVisible(false)}>
        <Text style={styles.closeButton}>Close</Text>
      </TouchableOpacity>
    </View>
  );
};</code></pre>

            <h2>Build & Release Optimization</h2>
            <pre><code class="language-bash"># Android build optimization
# android/app/build.gradle
android {
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            
            // Split APKs by ABI
            splits {
                abi {
                    enable true
                    reset()
                    include 'armeabi-v7a', 'arm64-v8a'
                    universalApk false
                }
            }
        }
    }
}

# iOS build optimization
# Use these build settings in Xcode
# - Enable bitcode: YES
# - Strip Debug Symbols: YES
# - Optimization Level: -Os
# - Enable Modules: YES

# Generate source maps for production
npx react-native bundle \\
  --platform ios \\
  --dev false \\
  --entry-file index.js \\
  --bundle-output ios/main.jsbundle \\
  --sourcemap-output ios/main.jsbundle.map

# Analyze bundle size
npx react-native-bundle-visualizer

# Use RAM bundles for faster startup
npx react-native bundle \\
  --platform android \\
  --dev false \\
  --entry-file index.js \\
  --bundle-output android/app/src/main/assets/index.android.bundle \\
  --indexed-ram-bundle</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>Performance Optimization Best Practices:</h4>
                <ul>
                    <li>Profile before optimizing - measure, don't guess</li>
                    <li>Use React.memo and useMemo appropriately</li>
                    <li>Optimize images and use lazy loading</li>
                    <li>Minimize bridge communication</li>
                    <li>Use native driver for animations</li>
                    <li>Implement proper list virtualization</li>
                    <li>Remove console logs in production</li>
                    <li>Use Hermes engine for Android</li>
                    <li>Monitor bundle size and split code</li>
                    <li>Clean up timers and listeners properly</li>
                    <li>Optimize render cycles and re-renders</li>
                    <li>Use production builds for testing performance</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Optimize a slow React Native app:</p>
                <ul>
                    <li>Profile and identify bottlenecks</li>
                    <li>Optimize list rendering</li>
                    <li>Implement image lazy loading</li>
                    <li>Reduce bundle size</li>
                    <li>Add performance monitoring</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the target frame rate for smooth animations?",
            options: [
                "30 FPS",
                "45 FPS",
                "60 FPS",
                "120 FPS"
            ],
            correct: 2,
            explanation: "60 FPS (frames per second) is the target for smooth animations, meaning each frame should render in under 16.67ms."
        },
        {
            question: "Which prop enables native driver for animations?",
            options: [
                "nativeDriver: true",
                "useNativeDriver: true",
                "enableNative: true",
                "native: true"
            ],
            correct: 1,
            explanation: "useNativeDriver: true runs animations on the UI thread instead of the JavaScript thread for better performance."
        },
        {
            question: "What's the purpose of getItemLayout in FlatList?",
            options: [
                "Styling items",
                "Filtering data",
                "Skip measurement for better performance",
                "Sorting items"
            ],
            correct: 2,
            explanation: "getItemLayout allows FlatList to skip the measurement phase by providing item dimensions upfront, significantly improving performance."
        }
    ],
    project: {
        title: "Performance-Optimized News Feed",
        description: "Build a high-performance news feed app with complex UI and real-time updates",
        requirements: [
            "Implement virtualized list with 1000+ items",
            "Lazy load images with placeholders",
            "Add pull-to-refresh with optimistic updates",
            "Implement search with debouncing",
            "Add performance monitoring overlay",
            "Optimize bundle size under 5MB",
            "Achieve 60 FPS scrolling",
            "Handle memory efficiently"
        ],
        hints: [
            "Use FlatList with optimization props",
            "Implement image caching strategy",
            "Use React.memo for list items",
            "Monitor with Flipper",
            "Profile with React DevTools"
        ]
    }
},
'app-icons': {
    content: `
        <div class="content-section">
            <h1>App Icons & Splash Screens</h1>
            
            <div class="info-box">
                <p>Learn how to create and configure app icons and splash screens for iOS and Android. Master the requirements, tools, and best practices for creating professional app branding.</p>
            </div>

            <h2>Icon Requirements</h2>
            <pre><code class="language-javascript">// iOS Icon Sizes (Required)
const iOSIconSizes = {
  // iPhone icons
  'Icon-60@2x.png': { size: 120, purpose: 'iPhone App Icon' },
  'Icon-60@3x.png': { size: 180, purpose: 'iPhone App Icon' },
  
  // iPad icons
  'Icon-76.png': { size: 76, purpose: 'iPad App Icon' },
  'Icon-76@2x.png': { size: 152, purpose: 'iPad App Icon' },
  'Icon-83.5@2x.png': { size: 167, purpose: 'iPad Pro App Icon' },
  
  // Universal
  'Icon-1024.png': { size: 1024, purpose: 'App Store Icon' },
  
  // Spotlight & Settings
  'Icon-40.png': { size: 40, purpose: 'Spotlight' },
  'Icon-40@2x.png': { size: 80, purpose: 'Spotlight' },
  'Icon-40@3x.png': { size: 120, purpose: 'Spotlight' },
  'Icon-29.png': { size: 29, purpose: 'Settings' },
  'Icon-29@2x.png': { size: 58, purpose: 'Settings' },
  'Icon-29@3x.png': { size: 87, purpose: 'Settings' },
  
  // Notification
  'Icon-20.png': { size: 20, purpose: 'Notification' },
  'Icon-20@2x.png': { size: 40, purpose: 'Notification' },
  'Icon-20@3x.png': { size: 60, purpose: 'Notification' },
};

// Android Icon Sizes (Required)
const androidIconSizes = {
  'mipmap-mdpi/ic_launcher.png': { size: 48, dpi: 'mdpi' },
  'mipmap-hdpi/ic_launcher.png': { size: 72, dpi: 'hdpi' },
  'mipmap-xhdpi/ic_launcher.png': { size: 96, dpi: 'xhdpi' },
  'mipmap-xxhdpi/ic_launcher.png': { size: 144, dpi: 'xxhdpi' },
  'mipmap-xxxhdpi/ic_launcher.png': { size: 192, dpi: 'xxxhdpi' },
  
  // Round icons
  'mipmap-mdpi/ic_launcher_round.png': { size: 48, dpi: 'mdpi' },
  'mipmap-hdpi/ic_launcher_round.png': { size: 72, dpi: 'hdpi' },
  'mipmap-xhdpi/ic_launcher_round.png': { size: 96, dpi: 'xhdpi' },
  'mipmap-xxhdpi/ic_launcher_round.png': { size: 144, dpi: 'xxhdpi' },
  'mipmap-xxxhdpi/ic_launcher_round.png': { size: 192, dpi: 'xxxhdpi' },
  
  // Adaptive icon components
  'mipmap-mdpi/ic_launcher_foreground.png': { size: 108, dpi: 'mdpi' },
  'mipmap-hdpi/ic_launcher_foreground.png': { size: 162, dpi: 'hdpi' },
  'mipmap-xhdpi/ic_launcher_foreground.png': { size: 216, dpi: 'xhdpi' },
  'mipmap-xxhdpi/ic_launcher_foreground.png': { size: 324, dpi: 'xxhdpi' },
  'mipmap-xxxhdpi/ic_launcher_foreground.png': { size: 432, dpi: 'xxxhdpi' },
  
  // Store listing
  'play_store_512.png': { size: 512, purpose: 'Google Play Store' },
};</code></pre>

            <h2>Icon Generation Tools</h2>
            <pre><code class="language-bash"># Install icon generation tool
npm install -g react-native-make

# Generate icons from a single source image (1024x1024)
react-native set-icon --path ./icon.png

# Alternative: Using app-icon package
npm install -g app-icon

# Generate all icons
app-icon generate -i icon.png -p ios,android

# Using ImageMagick for custom generation
brew install imagemagick

# Generate iOS icons
for size in 20 29 40 58 60 76 80 87 120 152 167 180 1024; do
  convert icon.png -resize $\{size}x$\{size} ios/YourApp/Images.xcassets/AppIcon.appiconset/icon-$\{size}.png
done

# Generate Android icons with proper density
convert icon.png -resize 48x48 android/app/src/main/res/mipmap-mdpi/ic_launcher.png
convert icon.png -resize 72x72 android/app/src/main/res/mipmap-hdpi/ic_launcher.png
convert icon.png -resize 96x96 android/app/src/main/res/mipmap-xhdpi/ic_launcher.png
convert icon.png -resize 144x144 android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
convert icon.png -resize 192x192 android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png</code></pre>

            <h2>iOS Icon Configuration</h2>
            <pre><code class="language-json">// ios/YourApp/Images.xcassets/AppIcon.appiconset/Contents.json
{
  "images": [
    {
      "size": "20x20",
      "idiom": "iphone",
      "filename": "Icon-20@2x.png",
      "scale": "2x"
    },
    {
      "size": "20x20",
      "idiom": "iphone",
      "filename": "Icon-20@3x.png",
      "scale": "3x"
    },
    {
      "size": "29x29",
      "idiom": "iphone",
      "filename": "Icon-29@2x.png",
      "scale": "2x"
    },
    {
      "size": "29x29",
      "idiom": "iphone",
      "filename": "Icon-29@3x.png",
      "scale": "3x"
    },
    {
      "size": "40x40",
      "idiom": "iphone",
      "filename": "Icon-40@2x.png",
      "scale": "2x"
    },
    {
      "size": "40x40",
      "idiom": "iphone",
      "filename": "Icon-40@3x.png",
      "scale": "3x"
    },
    {
      "size": "60x60",
      "idiom": "iphone",
      "filename": "Icon-60@2x.png",
      "scale": "2x"
    },
    {
      "size": "60x60",
      "idiom": "iphone",
      "filename": "Icon-60@3x.png",
      "scale": "3x"
    },
    {
      "size": "1024x1024",
      "idiom": "ios-marketing",
      "filename": "Icon-1024.png",
      "scale": "1x"
    }
  ],
  "info": {
    "version": 1,
    "author": "xcode"
  }
}</code></pre>

            <h2>Android Adaptive Icons</h2>
            <pre><code class="language-xml">&lt;!-- android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml --&gt;
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;background android:drawable="@color/ic_launcher_background"/&gt;
    &lt;foreground android:drawable="@mipmap/ic_launcher_foreground"/&gt;
&lt;/adaptive-icon&gt;

&lt;!-- android/app/src/main/res/values/colors.xml --&gt;
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
    &lt;color name="ic_launcher_background"&gt;#FFFFFF&lt;/color&gt;
&lt;/resources&gt;</code></pre>

            <pre><code class="language-javascript">// Generate adaptive icon layers programmatically
const sharp = require('sharp');

async function generateAdaptiveIcon(inputPath) {
  const input = sharp(inputPath);
  
  // Background layer (108x108 dp with 72x72 dp safe zone)
  await input
    .resize(432, 432)
    .extend({
      top: 54,
      bottom: 54,
      left: 54,
      right: 54,
      background: { r: 255, g: 255, b: 255, alpha: 1 }
    })
    .toFile('ic_launcher_background.png');
  
  // Foreground layer with padding
  await input
    .resize(288, 288) // 66% of 432 for safe zone
    .extend({
      top: 72,
      bottom: 72,
      left: 72,
      right: 72,
      background: { r: 0, g: 0, b: 0, alpha: 0 }
    })
    .toFile('ic_launcher_foreground.png');
}

// Usage
generateAdaptiveIcon('./app-icon.png');</code></pre>

            <h2>Splash Screen Setup</h2>
            <pre><code class="language-bash"># Install splash screen package
npm install react-native-splash-screen

# iOS installation
cd ios && pod install

# Link manually if needed
react-native link react-native-splash-screen</code></pre>

            <h2>iOS Splash Screen Configuration</h2>
            <pre><code class="language-swift">// ios/YourApp/AppDelegate.m
#import "RNSplashScreen.h"

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  // ... other code
  
  [RNSplashScreen show]; // Show splash screen
  
  return YES;
}

@end</code></pre>

            <pre><code class="language-javascript">// Create launch screen in Xcode
// 1. Open ios/YourApp.xcworkspace
// 2. Select LaunchScreen.storyboard
// 3. Design your splash screen

// Splash screen sizes for iOS
const iOSSplashSizes = {
  'Default-568h@2x~iphone.png': { width: 640, height: 1136 }, // iPhone 5
  'Default-667h.png': { width: 750, height: 1334 }, // iPhone 6/7/8
  'Default-736h.png': { width: 1242, height: 2208 }, // iPhone 6/7/8 Plus
  'Default-2436h.png': { width: 1125, height: 2436 }, // iPhone X/XS
  'Default-1792h.png': { width: 828, height: 1792 }, // iPhone XR
  'Default-2688h.png': { width: 1242, height: 2688 }, // iPhone XS Max
  'Default@2x~ipad.png': { width: 1536, height: 2048 }, // iPad
  'Default-Portrait@2x~ipad.png': { width: 1536, height: 2048 }, // iPad Portrait
  'Default-Landscape@2x~ipad.png': { width: 2048, height: 1536 }, // iPad Landscape
};</code></pre>

            <h2>Android Splash Screen Configuration</h2>
            <pre><code class="language-java">// android/app/src/main/java/.../MainActivity.java
import org.devio.rn.splashscreen.SplashScreen;
import android.os.Bundle;

public class MainActivity extends ReactActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        SplashScreen.show(this);  // Show splash screen
        super.onCreate(savedInstanceState);
    }
}</code></pre>

            <pre><code class="language-xml">&lt;!-- android/app/src/main/res/layout/launch_screen.xml --&gt;
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/primary"
    android:gravity="center"&gt;
    
    &lt;ImageView
        android:layout_width="200dp"
        android:layout_height="200dp"
        android:src="@mipmap/splash_icon"
        android:scaleType="centerCrop"/&gt;
        
&lt;/LinearLayout&gt;

&lt;!-- android/app/src/main/res/values/colors.xml --&gt;
&lt;resources&gt;
    &lt;color name="primary"&gt;#FFFFFF&lt;/color&gt;
    &lt;color name="primary_dark"&gt;#000000&lt;/color&gt;
    &lt;color name="status_bar_color"&gt;#FFFFFF&lt;/color&gt;
&lt;/resources&gt;

&lt;!-- android/app/src/main/res/values/styles.xml --&gt;
&lt;resources&gt;
    &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;
        &lt;item name="android:windowBackground"&gt;@drawable/launch_background&lt;/item&gt;
        &lt;item name="android:statusBarColor"&gt;@color/status_bar_color&lt;/item&gt;
    &lt;/style&gt;
&lt;/resources&gt;</code></pre>

            <h2>React Native Implementation</h2>
            <pre><code class="language-javascript">// App.js
import React, { useEffect } from 'react';
import SplashScreen from 'react-native-splash-screen';

const App = () => {
  useEffect(() => {
    // Hide splash screen after app loads
    SplashScreen.hide();
    
    // Or hide after some initialization
    initializeApp().then(() => {
      SplashScreen.hide();
    });
  }, []);

  return <YourApp />;
};

// Custom splash screen component
import { Animated, View, Image, StyleSheet } from 'react-native';

const AnimatedSplashScreen = ({ onAnimationEnd }) => {
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(0.8)).current;

  useEffect(() => {
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 1000,
        useNativeDriver: true,
      }),
      Animated.spring(scaleAnim, {
        toValue: 1,
        friction: 4,
        useNativeDriver: true,
      }),
    ]).start(() => {
      setTimeout(onAnimationEnd, 500);
    });
  }, []);

  return (
    <View style={styles.container}>
      <Animated.Image
        source={require('./assets/logo.png')}
        style={[
          styles.logo,
          {
            opacity: fadeAnim,
            transform: [{ scale: scaleAnim }],
          },
        ]}
      />
    </View>
  );
};</code></pre>

            <h2>Icon Design Best Practices</h2>
            <pre><code class="language-javascript">// Icon validation utility
const validateIcon = (imagePath) => {
  const image = new Image();
  image.src = imagePath;
  
  return new Promise((resolve, reject) => {
    image.onload = () => {
      const issues = [];
      
      // Check dimensions
      if (image.width !== image.height) {
        issues.push('Icon must be square');
      }
      
      if (image.width < 1024) {
        issues.push('Icon should be at least 1024x1024');
      }
      
      // Check transparency (for iOS)
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = image.width;
      canvas.height = image.height;
      ctx.drawImage(image, 0, 0);
      
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const hasTransparency = Array.from(imageData.data)
        .some((value, index) => index % 4 === 3 && value < 255);
      
      if (hasTransparency) {
        issues.push('iOS icons should not have transparency');
      }
      
      resolve({
        valid: issues.length === 0,
        issues,
        dimensions: {
          width: image.width,
          height: image.height
        }
      });
    };
    
    image.onerror = () => reject(new Error('Failed to load image'));
  });
};

// Design guidelines
const iconGuidelines = {
  ios: {
    cornerRadius: '22.5% of icon size',
    padding: '10% safe area',
    background: 'No transparency allowed',
    format: 'PNG',
    colorSpace: 'sRGB',
    layers: 'Flattened',
  },
  android: {
    shape: 'Adaptive with safe zone',
    safeZone: '66% of total size',
    background: 'Can be transparent',
    format: 'PNG',
    layers: 'Separate foreground/background',
  },
  universal: {
    simplicity: 'Avoid text and complex details',
    scalability: 'Test at smallest size',
    uniqueness: 'Stand out on device',
    consistency: 'Match app design language',
  }
};</code></pre>

            <h2>Automated Icon Generation Script</h2>
            <pre><code class="language-javascript">// scripts/generate-assets.js
const sharp = require('sharp');
const fs = require('fs-extra');
const path = require('path');

const generateIcons = async (sourcePath) => {
  const sourceImage = sharp(sourcePath);
  
  // iOS Icons
  const iosPath = './ios/YourApp/Images.xcassets/AppIcon.appiconset';
  await fs.ensureDir(iosPath);
  
  for (const [filename, config of Object.entries(iOSIconSizes)) {
    await sourceImage
      .resize(config.size, config.size)
      .png()
      .toFile(path.join(iosPath, filename));
    
    console.log(\`Generated iOS icon: \${filename}\`);
  }
  
  // Android Icons
  for (const [filepath, config] of Object.entries(androidIconSizes)) {
    const androidPath = \`./android/app/src/main/res/\${filepath}\`;
    await fs.ensureDir(path.dirname(androidPath));
    
    await sourceImage
      .resize(config.size, config.size)
      .png()
      .toFile(androidPath);
    
    console.log(\`Generated Android icon: \${filepath}\`);
  }
  
  // Generate Contents.json for iOS
  await fs.writeJson(
    path.join(iosPath, 'Contents.json'),
    generateContentsJson(),
    { spaces: 2 }
  );
};

// Run generation
generateIcons('./design/app-icon.png')
  .then(() => console.log('Icon generation complete!'))
  .catch(console.error);</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>App Icons & Splash Screen Best Practices:</h4>
                <ul>
                    <li>Start with a 1024x1024 master icon</li>
                    <li>Avoid transparency in iOS icons</li>
                    <li>Test icons on various backgrounds</li>
                    <li>Keep splash screens simple and fast</li>
                    <li>Match splash screen to app's initial screen</li>
                    <li>Use vector graphics when possible</li>
                    <li>Follow platform-specific guidelines</li>
                    <li>Test on all device sizes</li>
                    <li>Optimize file sizes for performance</li>
                    <li>Consider dark mode variants</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Create a complete icon and splash screen set:</p>
                <ul>
                    <li>Design a unique app icon</li>
                    <li>Generate all required sizes</li>
                    <li>Create adaptive icons for Android</li>
                    <li>Design matching splash screen</li>
                    <li>Implement splash screen animation</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the required size for App Store icon?",
            options: [
                "512x512",
                "1024x1024",
                "2048x2048",
                "256x256"
            ],
            correct: 1,
            explanation: "App Store requires a 1024x1024 pixel icon for the store listing."
        },
        {
            question: "What should iOS icons NOT have?",
            options: [
                "Rounded corners",
                "Transparency",
                "Colors",
                "Shadows"
            ],
            correct: 1,
            explanation: "iOS icons should not have transparency; the system applies rounded corners automatically."
        },
        {
            question: "What percentage is the safe zone in Android adaptive icons?",
            options: [
                "50%",
                "66%",
                "75%",
                "80%"
            ],
            correct: 1,
            explanation: "Android adaptive icons have a 66% safe zone where important content should be placed."
        }
    ],
    project: {
        title: "Professional App Branding",
        description: "Create a complete branding package with icons and splash screens for a fitness tracking app",
        requirements: [
            "Design unique app icon following guidelines",
            "Generate all iOS icon sizes",
            "Create Android adaptive icon layers",
            "Design animated splash screen",
            "Implement splash screen in app",
            "Support dark mode variants",
            "Create promotional graphics",
            "Automate asset generation"
        ],
        hints: [
            "Use vector graphics as source",
            "Test on real devices",
            "Consider seasonal icon variants",
            "Keep file sizes optimized",
            "Follow accessibility guidelines"
        ]
    }
},
'signing': {
    content: `
        <div class="content-section">
            <h1>Code Signing</h1>
            
            <div class="info-box">
                <p>Master the complexities of code signing for iOS and Android. Learn about certificates, provisioning profiles, keystores, and the signing process for both development and production builds.</p>
            </div>

            <h2>iOS Code Signing Overview</h2>
            <pre><code class="language-javascript">// iOS Signing Components
const iOSSigningComponents = {
  certificate: {
    types: [
      'iOS Development', // For development builds
      'iOS Distribution', // For App Store and Ad Hoc
      'Apple Development', // Newer universal development cert
      'Apple Distribution', // Newer universal distribution cert
    ],
    validity: '1 year',
    keychain: 'Stored in macOS Keychain',
  },
  
  provisioningProfile: {
    types: [
      'Development', // For development devices
      'Ad Hoc', // For specific devices
      'App Store', // For App Store distribution
      'Enterprise', // For in-house distribution
    ],
    contains: [
      'App ID',
      'Certificate(s)',
      'Device IDs (except App Store)',
      'Entitlements',
    ],
  },
  
  appId: {
    format: 'TeamID.BundleID',
    example: 'ABC123XYZ.com.company.appname',
    wildcard: 'ABC123XYZ.*', // For multiple apps
  },
  
  entitlements: [
    'Push Notifications',
    'In-App Purchase',
    'iCloud',
    'Sign In with Apple',
    'App Groups',
    'Associated Domains',
  ],
};</code></pre>

            <h2>iOS Certificate Setup</h2>
            <pre><code class="language-bash"># Generate Certificate Signing Request (CSR)
# 1. Open Keychain Access on Mac
# 2. Keychain Access > Certificate Assistant > Request a Certificate from a Certificate Authority
# 3. Fill in email and name, select "Saved to disk"

# Or via command line
openssl req -new -key private.key -out CertificateSigningRequest.certSigningRequest

# After creating certificate on Apple Developer Portal
# Download and install by double-clicking .cer file

# List installed certificates
security find-identity -v -p codesigning

# Export certificate for CI/CD
security export -k ~/Library/Keychains/login.keychain-db -P "password" -f pkcs12 -o certificate.p12

# Import certificate on another machine
security import certificate.p12 -P "password" -k ~/Library/Keychains/login.keychain-db -T /usr/bin/codesign</code></pre>

            <h2>iOS Provisioning Profiles</h2>
            <pre><code class="language-javascript">// Fastlane configuration for automatic signing
// fastlane/Fastfile
platform :ios do
  desc "Sync certificates and provisioning profiles"
  lane :sync_signing do
    # Using match for team certificate management
    match(
      type: "development",
      app_identifier: "com.company.appname",
      git_url: "git@github.com:company/certificates.git",
      username: "apple@company.com"
    )
    
    match(
      type: "appstore",
      app_identifier: "com.company.appname",
      git_url: "git@github.com:company/certificates.git",
      username: "apple@company.com"
    )
  end
  
  desc "Update provisioning profiles"
  lane :update_profiles do
    # Fetch latest profiles
    sigh(
      app_identifier: "com.company.appname",
      username: "apple@company.com",
      team_id: "ABC123XYZ",
      provisioning_name: "AppName Development",
      development: true
    )
  end
end

// Manual provisioning profile setup
// 1. Go to Apple Developer Portal
// 2. Create new Provisioning Profile
// 3. Select type (Development/Distribution)
// 4. Select App ID
// 5. Select certificates
// 6. Select devices (for Development/Ad Hoc)
// 7. Download and install</code></pre>

            <h2>iOS Xcode Configuration</h2>
            <pre><code class="language-javascript">// ios/YourApp.xcodeproj/project.pbxproj configuration
// Build Settings for different configurations

const xcodeSigningConfig = {
  Debug: {
    CODE_SIGN_IDENTITY: "Apple Development",
    DEVELOPMENT_TEAM: "ABC123XYZ",
    PROVISIONING_PROFILE_SPECIFIER: "match Development com.company.appname",
    CODE_SIGN_STYLE: "Manual", // or "Automatic"
  },
  
  Release: {
    CODE_SIGN_IDENTITY: "Apple Distribution",
    DEVELOPMENT_TEAM: "ABC123XYZ",
    PROVISIONING_PROFILE_SPECIFIER: "match AppStore com.company.appname",
    CODE_SIGN_STYLE: "Manual",
  },
};

// Automatic signing in Xcode
// 1. Select project in Xcode
// 2. Select target
// 3. Go to "Signing & Capabilities"
// 4. Check "Automatically manage signing"
// 5. Select Team

// Manual signing
// 1. Uncheck "Automatically manage signing"
// 2. Select Provisioning Profile
// 3. Ensure certificate is in keychain</code></pre>

            <h2>Android Keystore Setup</h2>
            <pre><code class="language-bash"># Generate a release keystore
keytool -genkeypair -v -storetype PKCS12 -keystore my-release-key.keystore \
  -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000

# List keystore contents
keytool -list -v -keystore my-release-key.keystore

# Generate upload key for Google Play App Signing
keytool -genkeypair -v -storetype PKCS12 -keystore my-upload-key.keystore \
  -alias my-upload-alias -keyalg RSA -keysize 2048 -validity 10000

# Export certificate for Google Play
keytool -export -rfc -keystore my-upload-key.keystore \
  -alias my-upload-alias -file upload_certificate.pem

# Convert JKS to PKCS12 (if needed)
keytool -importkeystore -srckeystore my-release-key.jks \
  -destkeystore my-release-key.keystore -deststoretype pkcs12</code></pre>

            <h2>Android Gradle Configuration</h2>
            <pre><code class="language-groovy">// android/app/build.gradle
android {
    ...
    signingConfigs {
        debug {
            storeFile file('debug.keystore')
            storePassword 'android'
            keyAlias 'androiddebugkey'
            keyPassword 'android'
        }
        release {
            if (project.hasProperty('MYAPP_UPLOAD_STORE_FILE')) {
                storeFile file(MYAPP_UPLOAD_STORE_FILE)
                storePassword MYAPP_UPLOAD_STORE_PASSWORD
                keyAlias MYAPP_UPLOAD_KEY_ALIAS
                keyPassword MYAPP_UPLOAD_KEY_PASSWORD
            }
        }
    }
    buildTypes {
        debug {
            signingConfig signingConfigs.debug
        }
        release {
            signingConfig signingConfigs.release
            minifyEnabled enableProguardInReleaseBuilds
            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
        }
    }
}

// android/gradle.properties (DO NOT commit to version control)
MYAPP_UPLOAD_STORE_FILE=my-upload-key.keystore
MYAPP_UPLOAD_STORE_PASSWORD=your-store-password
MYAPP_UPLOAD_KEY_ALIAS=my-upload-alias
MYAPP_UPLOAD_KEY_PASSWORD=your-key-password</code></pre>

            <h2>Environment-based Signing</h2>
            <pre><code class="language-javascript">// scripts/setup-signing.js
const fs = require('fs');
const path = require('path');

const setupAndroidSigning = () => {
  const gradleProperties = path.join(__dirname, '../android/gradle.properties');
  
  // Read from environment variables
  const signingConfig = \`
MYAPP_UPLOAD_STORE_FILE=\${process.env.ANDROID_KEYSTORE_PATH}
MYAPP_UPLOAD_STORE_PASSWORD=\${process.env.ANDROID_KEYSTORE_PASSWORD}
MYAPP_UPLOAD_KEY_ALIAS=\${process.env.ANDROID_KEY_ALIAS}
MYAPP_UPLOAD_KEY_PASSWORD=\${process.env.ANDROID_KEY_PASSWORD}
\`;
  
  fs.appendFileSync(gradleProperties, signingConfig);
  console.log('Android signing configured');
};

const setupIOSSigning = () => {
  // Create exportOptions.plist for iOS
  const exportOptions = {
    method: process.env.IOS_EXPORT_METHOD || 'app-store',
    teamID: process.env.IOS_TEAM_ID,
    uploadBitcode: false,
    uploadSymbols: true,
    provisioningProfiles: {
      [process.env.IOS_BUNDLE_ID]: process.env.IOS_PROVISION_PROFILE_NAME
    }
  };
  
  const plistContent = \`<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>method</key>
    <string>\${exportOptions.method}</string>
    <key>teamID</key>
    <string>\${exportOptions.teamID}</string>
    <key>uploadBitcode</key>
    <\${exportOptions.uploadBitcode}/>
    <key>uploadSymbols</key>
    <\${exportOptions.uploadSymbols}/>
    <key>provisioningProfiles</key>
    <dict>
        <key>\${process.env.IOS_BUNDLE_ID}</key>
        <string>\${exportOptions.provisioningProfiles[process.env.IOS_BUNDLE_ID]}</string>
    </dict>
</dict>
</plist>\`;
  
  fs.writeFileSync('ios/exportOptions.plist', plistContent);
  console.log('iOS export options configured');
};

// Run setup
if (process.platform === 'darwin') {
  setupIOSSigning();
}
setupAndroidSigning();</code></pre>

            <h2>CI/CD Signing Setup</h2>
            <pre><code class="language-yaml"># GitHub Actions example
name: Build and Sign

on:
  push:
    branches: [ main ]

jobs:
  build-ios:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Apple Certificate
        env:
          BUILD_CERTIFICATE_BASE64: $\{{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: $\{{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: $\{{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          
          # Import certificate from secrets
          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
          
          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$P12_PASSWORD" \
            -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH
          
      - name: Install Provisioning Profile
        env:
          PROVISIONING_PROFILE_BASE64: $\{{ secrets.PROVISIONING_PROFILE_BASE64 }}
        run: |
          # Decode and install provisioning profile
          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
          echo -n "$PROVISIONING_PROFILE_BASE64" | base64 --decode -o $PP_PATH
          
          mkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles
          cp $PP_PATH ~/Library/MobileDevice/Provisioning\\ Profiles
          
  build-android:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Android Signing
        env:
          KEYSTORE_BASE64: $\{{ secrets.KEYSTORE_BASE64 }}
          KEYSTORE_PASSWORD: $\{{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: $\{{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: $\{{ secrets.KEY_PASSWORD }}
        run: |
          # Decode keystore
          echo "$KEYSTORE_BASE64" | base64 --decode > android/app/my-upload-key.keystore
          
          # Create gradle.properties
          echo "MYAPP_UPLOAD_STORE_FILE=my-upload-key.keystore" >> android/gradle.properties
          echo "MYAPP_UPLOAD_STORE_PASSWORD=$KEYSTORE_PASSWORD" >> android/gradle.properties
          echo "MYAPP_UPLOAD_KEY_ALIAS=$KEY_ALIAS" >> android/gradle.properties
          echo "MYAPP_UPLOAD_KEY_PASSWORD=$KEY_PASSWORD" >> android/gradle.properties</code></pre>

            <h2>Security Best Practices</h2>
            <pre><code class="language-javascript">// Secure keystore management
const secureKeystoreSetup = {
  storage: {
    never: [
      'Version control',
      'Public repositories',
      'Unencrypted locations',
      'Shared drives',
    ],
    always: [
      'Encrypted password manager',
      'Secure CI/CD secrets',
      'Hardware security module (HSM)',
      'Dedicated secure machine',
    ],
  },
  
  passwords: {
    requirements: [
      'Minimum 20 characters',
      'Mix of upper/lower/numbers/symbols',
      'Unique per keystore',
      'Rotate periodically',
    ],
    storage: [
      'Environment variables',
      'CI/CD secret management',
      'Password manager',
      'Never in code',
    ],
  },
  
  backup: {
    what: [
      'Keystore files',
      'Passwords (encrypted)',
      'Certificate exports',
      'Provisioning profiles',
    ],
    where: [
      'Encrypted cloud storage',
      'Physical secure location',
      'Multiple locations',
    ],
  },
};

// Gitignore additions
const gitignoreAdditions = \`
# Signing
*.keystore
*.jks
*.p12
*.mobileprovision
*.cer
gradle.properties
fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots
fastlane/test_output
\`;

// Environment variable template
const envTemplate = \`
# iOS Signing
IOS_CERTIFICATE_PATH=
IOS_CERTIFICATE_PASSWORD=
IOS_PROVISIONING_PROFILE_PATH=
IOS_TEAM_ID=
IOS_BUNDLE_ID=

# Android Signing
ANDROID_KEYSTORE_PATH=
ANDROID_KEYSTORE_PASSWORD=
ANDROID_KEY_ALIAS=
ANDROID_KEY_PASSWORD=
\`;</code></pre>

            <h2>Troubleshooting Common Issues</h2>
            <pre><code class="language-javascript">// Common iOS signing issues
const iOSSigningIssues = {
  'No signing certificate': {
    cause: 'Certificate not in keychain',
    solution: 'Install certificate by double-clicking .cer file',
    verify: 'security find-identity -v -p codesigning',
  },
  
  'Provisioning profile not found': {
    cause: 'Profile not installed or expired',
    solution: 'Download from Apple Developer and install',
    verify: 'ls ~/Library/MobileDevice/Provisioning\\ Profiles/',
  },
  
  'Code signing is required': {
    cause: 'Signing not configured in Xcode',
    solution: 'Configure signing in project settings',
    verify: 'Check CODE_SIGN_IDENTITY in build settings',
  },
  
  'Profile doesn\'t match bundle ID': {
    cause: 'Wrong profile selected',
    solution: 'Create/select profile with correct bundle ID',
    verify: 'Check profile contents with security cms -D -i profile.mobileprovision',
  },
};

// Common Android signing issues
const androidSigningIssues = {
  'Keystore file not found': {
    cause: 'Wrong path in gradle.properties',
    solution: 'Use relative path from app folder',
    verify: 'ls android/app/your-keystore.keystore',
  },
  
  'Wrong keystore password': {
    cause: 'Incorrect password in gradle.properties',
    solution: 'Verify password with keytool -list',
    verify: 'keytool -list -keystore your.keystore',
  },
  
  'Keystore was tampered with': {
    cause: 'Corrupted keystore file',
    solution: 'Restore from backup or regenerate',
    verify: 'keytool -list -v -keystore your.keystore',
  },
  
  'App not installed': {
    cause: 'Different signing certificate',
    solution: 'Uninstall existing app first',
    verify: 'adb uninstall com.yourpackage',
  },
};

// Debug commands
const debugCommands = {
  ios: [
    'security find-identity -v -p codesigning',
    'security cms -D -i path/to/profile.mobileprovision',
    'xcodebuild -showBuildSettings | grep SIGN',
    'codesign -dv --verbose=4 YourApp.app',
  ],
  android: [
    'keytool -list -v -keystore your.keystore',
    './gradlew signingReport',
    'jarsigner -verify -verbose app-release.apk',
    'apksigner verify --print-certs app-release.apk',
  ],
};</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>Code Signing Best Practices:</h4>
                <ul>
                    <li>Never commit signing credentials to version control</li>
                    <li>Use strong, unique passwords for keystores</li>
                    <li>Keep secure backups of all signing materials</li>
                    <li>Use separate keys for debug and release builds</li>
                    <li>Implement automated signing in CI/CD</li>
                    <li>Rotate certificates before expiration</li>
                    <li>Use Google Play App Signing for Android</li>
                    <li>Document your signing process</li>
                    <li>Test signed builds before release</li>
                    <li>Monitor certificate expiration dates</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Set up complete code signing:</p>
                <ul>
                    <li>Generate iOS certificates and profiles</li>
                    <li>Create Android release keystore</li>
                    <li>Configure automatic signing</li>
                    <li>Set up CI/CD signing</li>
                    <li>Create signing documentation</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the validity period for iOS certificates?",
            options: [
                "6 months",
                "1 year",
                "2 years",
                "5 years"
            ],
            correct: 1,
            explanation: "iOS development and distribution certificates are valid for 1 year from creation."
        },
        {
            question: "What format is recommended for Android keystores?",
            options: [
                "JKS",
                "PEM",
                "PKCS12",
                "DER"
            ],
            correct: 2,
            explanation: "PKCS12 is the recommended format for Android keystores as JKS is a proprietary format."
        },
        {
            question: "Where should you store keystore passwords?",
            options: [
                "In build.gradle",
                "In version control",
                "In environment variables",
                "In the keystore file"
            ],
            correct: 2,
            explanation: "Keystore passwords should be stored in environment variables or secure secret management systems, never in code."
        }
    ],
    project: {
        title: "Automated Signing Pipeline",
        description: "Set up a complete automated code signing pipeline for both iOS and Android with CI/CD integration",
        requirements: [
            "Generate all required certificates and keystores",
            "Configure signing for multiple environments",
            "Implement Fastlane for iOS automation",
            "Set up GitHub Actions for automated builds",
            "Create secure storage for credentials",
            "Document the signing process",
            "Implement certificate rotation reminders",
            "Test signed builds on devices"
        ],
        hints: [
            "Use Fastlane match for iOS",
            "Store secrets in GitHub Secrets",
            "Create separate keys for staging",
            "Automate profile updates",
            "Monitor expiration dates"
        ]
    }
},
'play-store': {
    content: `
        <div class="content-section">
            <h1>Google Play Store</h1>
            
            <div class="info-box">
                <p>Learn how to prepare, submit, and manage your React Native app on the Google Play Store. Master the publishing process, store listing optimization, and post-launch management.</p>
            </div>

            <h2>Pre-Publishing Checklist</h2>
            <pre><code class="language-javascript">const playStoreChecklist = {
  appPreparation: {
    technical: [
      '✓ Remove all console.log statements',
      '✓ Enable ProGuard/R8 minification',
      '✓ Set proper version code and version name',
      '✓ Configure app signing',
      '✓ Test release build thoroughly',
      '✓ Check app size (< 150MB for base APK)',
      '✓ Implement app bundles (.aab)',
    ],
    
    content: [
      '✓ App complies with Google Play policies',
      '✓ Content rating questionnaire completed',
      '✓ Privacy policy URL ready',
      '✓ Terms of service (if applicable)',
      '✓ COPPA compliance (if targeting children)',
    ],
    
    optimization: [
      '✓ Target API level meets requirements',
      '✓ 64-bit support included',
      '✓ Adaptive icons implemented',
      '✓ App supports latest Android version',
      '✓ Permissions minimized and justified',
    ],
  },
  
  storeListing: {
    required: [
      '✓ App title (30 characters)',
      '✓ Short description (80 characters)',
      '✓ Full description (4000 characters)',
      '✓ Screenshots (2-8 per device type)',
      '✓ Feature graphic (1024x500)',
      '✓ App icon (512x512)',
      '✓ App category selection',
      '✓ Contact email',
      '✓ Privacy policy URL',
    ],
    
    optional: [
      '✓ Promotional video URL',
      '✓ TV banner (1280x720)',
      '✓ Wear OS screenshots',
      '✓ Promotional text (80 chars)',
    ],
  },
};</code></pre>

            <h2>Building for Google Play</h2>
            <pre><code class="language-bash"># Clean build folders
cd android
./gradlew clean

# Generate App Bundle (recommended)
./gradlew bundleRelease

# Output location
# android/app/build/outputs/bundle/release/app-release.aab

# Generate APK (if needed)
./gradlew assembleRelease

# Output location
# android/app/build/outputs/apk/release/app-release.apk

# Test the release build
npx react-native run-android --variant=release

# Verify app bundle contents
bundletool build-apks --bundle=app-release.aab --output=app-release.apks
bundletool install-apks --apks=app-release.apks</code></pre>

            <h2>App Bundle Configuration</h2>
            <pre><code class="language-groovy">// android/app/build.gradle
android {
    ...
    defaultConfig {
        applicationId "com.yourcompany.yourapp"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0.0"
        
        // Enable multidex for larger apps
        multiDexEnabled true
        
        // Configure supported ABIs
        ndk {
            abiFilters "armeabi-v7a", "arm64-v8a", "x86", "x86_64"
        }
    }
    
    // Bundle configuration
    bundle {
        language {
            enableSplit = true
        }
        density {
            enableSplit = true
        }
        abi {
            enableSplit = true
        }
    }
    
    // Build types
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            
            // Optimize APK size
            ndk {
                debugSymbolLevel 'SYMBOL_TABLE'
            }
        }
    }
}</code></pre>

            <h2>Version Management</h2>
            <pre><code class="language-javascript">// scripts/version-bump.js
const fs = require('fs');
const path = require('path');

const bumpVersion = (type = 'patch') => {
  // Read current version from package.json
  const packagePath = path.join(__dirname, '../package.json');
  const package = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
  
  // Parse version
  const [major, minor, patch] = package.version.split('.').map(Number);
  
  // Bump version
  let newVersion;
  switch (type) {
    case 'major':
      newVersion = \`\${major + 1}.0.0\`;
      break;
    case 'minor':
      newVersion = \`\${major}.\${minor + 1}.0\`;
      break;
    case 'patch':
    default:
      newVersion = \`\${major}.\${minor}.\${patch + 1}\`;
  }
  
  // Update package.json
  package.version = newVersion;
  fs.writeFileSync(packagePath, JSON.stringify(package, null, 2));
  
  // Update Android version
  updateAndroidVersion(newVersion);
  
  // Update iOS version
  updateIOSVersion(newVersion);
  
  console.log(\`Version bumped to \${newVersion}\`);
};

const updateAndroidVersion = (version) => {
  const gradlePath = path.join(__dirname, '../android/app/build.gradle');
  let gradle = fs.readFileSync(gradlePath, 'utf8');
  
  // Calculate version code (major * 10000 + minor * 100 + patch)
  const [major, minor, patch] = version.split('.').map(Number);
  const versionCode = major * 10000 + minor * 100 + patch;
  
  // Update version code and name
  gradle = gradle.replace(/versionCode \d+/, \`versionCode \${versionCode}\`);
  gradle = gradle.replace(/versionName "[^"]*"/, \`versionName "\${version}"\`);
  
  fs.writeFileSync(gradlePath, gradle);
};

// Run version bump
bumpVersion(process.argv[2]);</code></pre>

            <h2>Store Listing Optimization</h2>
            <pre><code class="language-javascript">// Store listing best practices
const storeListingOptimization = {
  title: {
    maxLength: 30,
    tips: [
      'Include main keyword',
      'Make it memorable',
      'Avoid keyword stuffing',
      'Consider localization',
    ],
    example: 'PhotoEdit Pro - Photo Editor',
  },
  
  shortDescription: {
    maxLength: 80,
    tips: [
      'Highlight key features',
      'Include call-to-action',
      'Use relevant keywords',
      'Make it compelling',
    ],
    example: 'Professional photo editing made simple. Edit, filter, and share beautiful photos!',
  },
  
  fullDescription: {
    maxLength: 4000,
    structure: [
      '1. Opening hook (2-3 sentences)',
      '2. Key features (bullet points)',
      '3. Unique selling points',
      '4. User testimonials',
      '5. Call-to-action',
    ],
    formatting: [
      '• Use bullet points for features',
      '• Add ★ for highlights',
      '• Include emoji sparingly',
      '• Break into paragraphs',
      '• Use CAPS for headers',
    ],
  },
  
  keywords: {
    research: [
      'Google Play Console suggestions',
      'Competitor analysis',
      'Google Trends',
      'App Annie/Sensor Tower',
    ],
    placement: [
      'Title (most important)',
      'Short description',
      'Full description (repeat 2-3 times)',
      'Don\'t keyword stuff',
    ],
  },
};

// Screenshot requirements
const screenshotRequirements = {
  phone: {
    minRequired: 2,
    maxAllowed: 8,
    dimensions: {
      min: { width: 320, height: 320 },
      max: { width: 3840, height: 3840 },
      ratio: '16:9 or 9:16 recommended',
    },
  },
  
  tablet7: {
    required: false,
    dimensions: {
      min: { width: 320, height: 320 },
      max: { width: 3840, height: 3840 },
    },
  },
  
  tablet10: {
    required: false,
    dimensions: {
      min: { width: 320, height: 320 },
      max: { width: 3840, height: 3840 },
    },
  },
  
  wearOS: {
    required: false,
    dimensions: {
      square: { width: 384, height: 384 },
      round: { width: 384, height: 384 },
    },
  },
};</code></pre>

            <h2>Google Play Console Setup</h2>
            <pre><code class="language-javascript">// Step-by-step console setup
const playConsoleSetup = {
  1: {
    step: 'Create Developer Account',
    requirements: [
      'Google account',
      'One-time $25 registration fee',
      'Developer profile information',
      'Accept developer agreement',
    ],
  },
  
  2: {
    step: 'Create App',
    fields: {
      appName: 'Internal name (can differ from store)',
      defaultLanguage: 'Primary language',
      appType: 'App or Game',
      free: 'Free or Paid',
    },
  },
  
  3: {
    step: 'Store Listing',
    sections: [
      'Product details',
      'Graphics assets',
      'Categorization',
      'Contact details',
      'Privacy policy',
    ],
  },
  
  4: {
    step: 'Content Rating',
    questionnaire: [
      'Violence',
      'Sexuality',
      'Language',
      'Controlled substances',
      'Target age',
    ],
  },
  
  5: {
    step: 'Pricing & Distribution',
    options: [
      'Countries selection',
      'Device categories',
      'User programs (Designed for Families)',
      'Ads declaration',
      'Content guidelines',
    ],
  },
  
  6: {
    step: 'App Releases',
    tracks: [
      'Internal testing (100 testers)',
      'Closed testing (custom)',
      'Open testing (unlimited)',
      'Production',
    ],
  },
};

// Release management
const releaseProcess = \`
1. Create release in testing track
2. Upload app bundle (.aab)
3. Name your release
4. Add release notes
5. Review and roll out
6. Monitor for issues
7. Gradually increase rollout %
8. Promote to production
\`;</code></pre>

            <h2>Testing Tracks</h2>
            <pre><code class="language-javascript">// Configure testing tracks
const testingStrategy = {
  internal: {
    purpose: 'Initial QA testing',
    testers: 'Up to 100 internal emails',
    duration: '1-2 days',
    focus: [
      'Core functionality',
      'Crash testing',
      'Basic user flows',
    ],
  },
  
  closedAlpha: {
    purpose: 'Feature testing',
    testers: 'Invited users via email/link',
    duration: '1 week',
    focus: [
      'New features',
      'Performance',
      'Device compatibility',
    ],
  },
  
  openBeta: {
    purpose: 'Public testing',
    testers: 'Anyone can join',
    duration: '2-4 weeks',
    focus: [
      'Real-world usage',
      'User feedback',
      'Final bug fixes',
    ],
  },
  
  stagedRollout: {
    purpose: 'Gradual production release',
    stages: [
      '1% - Monitor crashes',
      '5% - Check ratings',
      '10% - Verify metrics',
      '25% - Broader testing',
      '50% - Half users',
      '100% - Full release',
    ],
  },
};

// Managing test users
const addTestUsers = async (track, emails) => {
  // Via Play Console API
  const playDeveloperApi = google.androidpublisher('v3');
  
  await playDeveloperApi.edits.testers.update({
    packageName: 'com.yourapp',
    editId: editId,
    track: track,
    requestBody: {
      testers: {
        googleGroups: ['testers@yourcompany.com'],
        emails: emails,
      },
    },
  });
};</code></pre>

            <h2>Play Console API Integration</h2>
            <pre><code class="language-javascript">// Automate Play Store operations
const { google } = require('googleapis');
const fs = require('fs');

// Setup authentication
const auth = new google.auth.GoogleAuth({
  keyFile: 'path/to/service-account-key.json',
  scopes: ['https://www.googleapis.com/auth/androidpublisher'],
});

const androidPublisher = google.androidpublisher({
  version: 'v3',
  auth: auth,
});

// Upload new release
const uploadRelease = async (aabPath, track = 'internal') => {
  const packageName = 'com.yourcompany.yourapp';
  
  // Create edit
  const { data: edit } = await androidPublisher.edits.insert({
    packageName,
  });
  
  // Upload AAB
  const { data: upload } = await androidPublisher.edits.bundles.upload({
    packageName,
    editId: edit.id,
    media: {
      mimeType: 'application/octet-stream',
      body: fs.createReadStream(aabPath),
    },
  });
  
  // Create release
  const { data: trackUpdate } = await androidPublisher.edits.tracks.update({
    packageName,
    editId: edit.id,
    track,
    requestBody: {
      track,
      releases: [{
        versionCodes: [upload.versionCode.toString()],
        status: 'completed',
        releaseNotes: [{
          language: 'en-US',
          text: 'Bug fixes and performance improvements',
        }],
      }],
    },
  });
  
  // Commit changes
  await androidPublisher.edits.commit({
    packageName,
    editId: edit.id,
  });
  
  console.log(\`Release uploaded to \${track} track\`);
};

// Get app statistics
const getAppStats = async () => {
  const stats = await androidPublisher.reviews.list({
    packageName: 'com.yourcompany.yourapp',
    maxResults: 100,
  });
  
  return stats.data.reviews;
};</code></pre>

            <h2>Post-Launch Management</h2>
            <pre><code class="language-javascript">// Monitor app performance
const monitoringChecklist = {
  daily: [
    'Check crash reports',
    'Monitor ANRs (App Not Responding)',
    'Review new ratings/reviews',
    'Check vitals dashboard',
  ],
  
  weekly: [
    'Analyze user acquisition',
    'Review retention metrics',
    'Check conversion rates',
    'Monitor uninstall reasons',
  ],
  
  monthly: [
    'Update store listing',
    'Analyze competitor apps',
    'Plan feature updates',
    'Review monetization',
  ],
};

// Respond to reviews
const reviewResponseTemplates = {
  positive: {
    5_star: 'Thank you for the amazing review! We\'re thrilled you love [App Name].',
    4_star: 'Thanks for your feedback! We\'re always working to improve.',
  },
  
  negative: {
    bug_report: 'We\'re sorry you experienced this issue. Please email support@company.com so we can help.',
    feature_request: 'Thanks for the suggestion! We\'ll consider this for future updates.',
    general: 'We appreciate your feedback and are working hard to improve your experience.',
  },
  
  guidelines: [
    'Respond within 24-48 hours',
    'Keep responses professional',
    'Address specific concerns',
    'Offer support contact for issues',
    'Thank users for feedback',
  ],
};

// Update strategies
const updateStrategy = {
  regular: {
    frequency: 'Every 2-4 weeks',
    focus: 'Bug fixes, minor improvements',
    testing: 'Internal track first',
  },
  
  feature: {
    frequency: 'Every 1-3 months',
    focus: 'New features, UI updates',
    testing: 'Full testing cycle',
  },
  
  critical: {
    frequency: 'As needed',
    focus: 'Critical bugs, security',
    testing: 'Fast track with monitoring',
  },
};</code></pre>

            <h2>Store Listing A/B Testing</h2>
            <pre><code class="language-javascript">// A/B testing configuration
const abTestingSetup = {
  storeListingExperiments: {
    elements: [
      'App icon',
      'Feature graphic',
      'Screenshots',
      'Short description',
      'Full description',
    ],
    
    setup: {
      1: 'Go to Store presence > Store listing experiments',
      2: 'Create new experiment',
      3: 'Select element to test',
      4: 'Upload variants',
      5: 'Set traffic split (50/50)',
      6: 'Run for 2-4 weeks',
      7: 'Apply winner',
    },
    
    metrics: [
      'Conversion rate',
      'Install rate',
      'Uninstall rate',
    ],
  },
  
  bestPractices: [
    'Test one element at a time',
    'Run tests for statistical significance',
    'Consider seasonal factors',
    'Test across different markets',
    'Document results',
  ],
};</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>Google Play Store Best Practices:</h4>
                <ul>
                    <li>Always use app bundles (.aab) instead of APKs</li>
                    <li>Test thoroughly on multiple devices before release</li>
                    <li>Use staged rollouts for production releases</li>
                    <li>Respond to user reviews promptly</li>
                    <li>Keep app size under 150MB for base APK</li>
                    <li>Update regularly to maintain visibility</li>
                    <li>Monitor Android vitals for performance issues</li>
                    <li>Implement proper crash reporting</li>
                    <li>Follow Material Design guidelines</li>
                    <li>Optimize for different screen sizes</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Publish your app to Google Play Store:</p>
                <ul>
                    <li>Create developer account</li>
                    <li>Prepare store listing assets</li>
                    <li>Build and sign release AAB</li>
                    <li>Set up testing tracks</li>
                    <li>Submit for review</li>
                    <li>Monitor post-launch metrics</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the recommended format for Android app distribution?",
            options: [
                "APK",
                "AAB (App Bundle)",
                "ZIP",
                "IPA"
            ],
            correct: 1,
            explanation: "Android App Bundles (AAB) are the recommended format as they allow Google Play to optimize APKs for each device."
        },
        {
            question: "What's the one-time fee for a Google Play Developer account?",
            options: [
                "$10",
                "$25",
                "$99",
                "$299"
            ],
            correct: 1,
            explanation: "Google charges a one-time $25 registration fee for a developer account."
        },
        {
            question: "How many screenshots are required for Google Play listing?",
            options: [
                "At least 1",
                "At least 2",
                "At least 4",
                "At least 8"
            ],
            correct: 1,
            explanation: "Google Play requires at least 2 screenshots, with a maximum of 8 per device type."
        }
    ],
    project: {
        title: "Google Play Store Launch",
        description: "Prepare and launch a complete app on the Google Play Store with optimized listing",
        requirements: [
            "Create compelling store listing",
            "Design all required graphics",
            "Build optimized app bundle",
            "Set up testing tracks",
            "Configure staged rollout",
            "Implement analytics",
            "Set up crash reporting",
            "Create update strategy"
        ],
        hints: [
            "Use Play Console API for automation",
            "A/B test your store listing",
            "Monitor Android vitals",
            "Respond to user reviews",
            "Plan regular updates"
        ]
    }
},
'app-store': {
    content: `
        <div class="content-section">
            <h1>Apple App Store</h1>
            
            <div class="info-box">
                <p>Master the process of submitting your React Native app to the Apple App Store. Learn about App Store Connect, review guidelines, and optimization strategies for iOS app distribution.</p>
            </div>

            <h2>Pre-Submission Checklist</h2>
            <pre><code class="language-javascript">const appStoreChecklist = {
  prerequisites: {
    accounts: [
      '✓ Apple Developer Account ($99/year)',
      '✓ App Store Connect access',
      '✓ Valid certificates and provisioning profiles',
      '✓ Devices for testing',
    ],
    
    technical: [
      '✓ iOS 11.0+ minimum deployment target',
      '✓ 64-bit support',
      '✓ IPv6 network compatibility',
      '✓ App Transport Security configured',
      '✓ No deprecated APIs',
      '✓ Proper entitlements',
    ],
    
    compliance: [
      '✓ Apple Developer Program License Agreement',
      '✓ App Store Review Guidelines compliance',
      '✓ Export compliance (encryption)',
      '✓ Third-party licenses documented',
      '✓ Privacy policy prepared',
    ],
  },
  
  appPreparation: {
    build: [
      '✓ Archive build created in Xcode',
      '✓ Distribution certificate used',
      '✓ App Store provisioning profile',
      '✓ Bitcode enabled (optional)',
      '✓ Debug symbols included',
    ],
    
    testing: [
      '✓ TestFlight internal testing',
      '✓ External beta testing',
      '✓ All device sizes tested',
      '✓ iOS versions tested',
      '✓ Performance profiled',
    ],
  },
};</code></pre>

            <h2>Building for App Store</h2>
            <pre><code class="language-bash"># Clean build folder
cd ios
rm -rf build/
pod install

# Open Xcode
open YourApp.xcworkspace

# In Xcode:
# 1. Select "Any iOS Device" as build target
# 2. Product > Archive
# 3. Wait for archive to complete
# 4. Organizer window will open

# Command line build (alternative)
xcodebuild -workspace YourApp.xcworkspace \
  -scheme YourApp \
  -sdk iphoneos \
  -configuration Release \
  -archivePath ./build/YourApp.xcarchive \
  archive

# Export IPA
xcodebuild -exportArchive \
  -archivePath ./build/YourApp.xcarchive \
  -exportOptionsPlist ./exportOptions.plist \
  -exportPath ./build/</code></pre>

            <h2>App Store Connect Configuration</h2>
            <pre><code class="language-javascript">// App Information setup
const appStoreConnectSetup = {
  appInformation: {
    name: 'Your App Name', // Max 30 characters
    subtitle: 'Catchy subtitle here', // Max 30 characters
    primaryCategory: 'Productivity',
    secondaryCategory: 'Business', // Optional
    
    bundleId: 'com.company.appname',
    sku: 'COMPANY_APPNAME_001', // Unique identifier
    
    contentRights: {
      thirdPartyContent: false,
      encryption: false, // If true, need export compliance
    },
  },
  
  pricing: {
    model: 'Free' | 'Paid' | 'Freemium',
    basePrice: '$0.00', // If paid
    
    availability: {
      availableIn: 'All countries',
      releaseOption: 'Manual' | 'Automatic',
      preOrder: false,
    },
  },
  
  ageRating: {
    questionnaire: [
      'Violence',
      'Sexual Content',
      'Profanity',
      'Medical/Treatment',
      'Gambling',
      'Horror/Fear',
    ],
    
    ratings: {
      '4+': 'No objectionable content',
      '9+': 'Mild content',
      '12+': 'Moderate content',
      '17+': 'Frequent/Intense content',
    },
  },
};</code></pre>

            <h2>App Store Listing</h2>
            <pre><code class="language-javascript">// Store listing requirements
const storeListingRequirements = {
  metadata: {
    name: { max: 30, required: true },
    subtitle: { max: 30, required: false },
    promotional: { max: 170, required: false },
    description: { max: 4000, required: true },
    keywords: { max: 100, required: true, separator: ',' },
    supportUrl: { required: true },
    marketingUrl: { required: false },
    privacyUrl: { required: true },
  },
  
  screenshots: {
    required: {
      'iPhone 6.5"': { 
        size: '1242x2688', 
        devices: ['iPhone 15 Pro Max', 'iPhone 14 Pro Max'] 
      },
      'iPhone 5.5"': { 
        size: '1242x2208', 
        devices: ['iPhone 8 Plus'] 
      },
    },
    optional: {
      'iPad Pro 12.9"': { size: '2048x2732' },
      'iPad Pro 11"': { size: '1668x2388' },
      'Apple Watch': { size: '368x448' },
      'Apple TV': { size: '1920x1080' },
    },
    limits: {
      min: 1,
      max: 10,
      format: 'JPEG or PNG',
      colorSpace: 'sRGB or P3',
    },
  },
  
  appPreview: {
    optional: true,
    duration: { min: 15, max: 30 }, // seconds
    format: 'M4V, MP4, MOV',
    resolution: 'Same as screenshots',
    audio: 'Optional',
    max: 3,
  },
};

// Keyword optimization
const keywordStrategy = {
  research: {
    tools: [
      'App Store Connect Search Ads',
      'Sensor Tower',
      'AppTweak',
      'Mobile Action',
    ],
    
    sources: [
      'Competitor apps',
      'User search terms',
      'Related searches',
      'Trending keywords',
    ],
  },
  
  optimization: {
    tips: [
      'Use all 100 characters',
      'Separate with commas only',
      'No spaces after commas',
      'Include misspellings',
      'Avoid duplicates with name',
      'Consider localization',
    ],
    
    example: 'photo,editor,filters,edit,pics,camera,effects,collage',
  },
};</code></pre>

            <h2>TestFlight Setup</h2>
            <pre><code class="language-javascript">// TestFlight configuration
const testFlightSetup = {
  internalTesting: {
    testers: 'Up to 100 Apple IDs',
    builds: 'All builds available immediately',
    duration: '90 days per build',
    
    setup: [
      '1. Upload build via Xcode',
      '2. Wait for processing (5-30 min)',
      '3. Add internal testers',
      '4. No review required',
    ],
  },
  
  externalTesting: {
    testers: 'Up to 10,000 email addresses',
    groups: 'Organize by features/demographics',
    duration: '90 days from first download',
    
    setup: [
      '1. Submit for Beta App Review',
      '2. Add test information',
      '3. Create tester groups',
      '4. Send invitations',
    ],
    
    betaReview: {
      required: 'First build and significant changes',
      time: '24-48 hours typically',
      info: {
        description: 'What to test',
        email: 'Beta support contact',
        demoAccount: 'If login required',
      },
    },
  },
};

// Manage TestFlight via API
const { App Store Connect API } = require('app-store-connect-api');

const manageBetaTesters = async () => {
  const api = new API({
    issuerId: 'YOUR_ISSUER_ID',
    privateKeyId: 'YOUR_KEY_ID',
    privateKey: 'YOUR_PRIVATE_KEY',
  });
  
  // Add beta tester
  await api.addBetaTester({
    email: 'tester@example.com',
    firstName: 'Test',
    lastName: 'User',
    groups: ['External Testers'],
  });
  
  // Send invitation
  await api.sendBetaInvitation({
    app: 'YOUR_APP_ID',
    build: 'BUILD_NUMBER',
    groups: ['External Testers'],
  });
};</code></pre>

            <h2>App Review Preparation</h2>
            <pre><code class="language-javascript">// App Review guidelines
const appReviewPrep = {
  commonRejectionReasons: {
    performance: [
      'Crashes or bugs',
      'Incomplete functionality',
      'Placeholder content',
      'Poor performance',
      'Battery drain',
    ],
    
    design: [
      'Does not follow HIG',
      'Misleading metadata',
      'Inappropriate content',
      'Poor user experience',
      'Copycat apps',
    ],
    
    legal: [
      'Privacy policy issues',
      'Inappropriate data collection',
      'Missing permissions usage',
      'Copyright violations',
      'Misleading claims',
    ],
    
    business: [
      'Hidden features',
      'Undocumented purchases',
      'External payment methods',
      'Inappropriate monetization',
    ],
  },
  
  reviewNotes: {
    required: false,
    include: [
      'Special instructions',
      'Demo account credentials',
      'Hidden features explanation',
      'Backend dependencies',
      'Time-sensitive content',
    ],
    
    template: \`
Demo Account:
Username: demo@example.com
Password: DemoPass123

Special Instructions:
- Feature X requires location permission
- Backend may be slow during first load
- Push notifications require opt-in

Contact:
Email: support@company.com
Phone: +1-234-567-8900
    \`,
  },
  
  appealsProcess: {
    ifRejected: [
      '1. Read rejection reason carefully',
      '2. Fix all mentioned issues',
      '3. Resubmit with explanation',
      '4. Or file appeal if disagree',
    ],
    
    appealUrl: 'https://developer.apple.com/contact/app-store/',
  },
};</code></pre>

            <h2>Submission Process</h2>
            <pre><code class="language-bash"># Using Xcode
# 1. Product > Archive
# 2. Distribute App
# 3. App Store Connect
# 4. Upload
# 5. Next through options
# 6. Upload complete

# Using Transporter app
# 1. Export IPA from Xcode
# 2. Open Transporter
# 3. Sign in with Apple ID
# 4. Drag IPA file
# 5. Deliver

# Using command line (xcrun)
xcrun altool --upload-app \
  -f YourApp.ipa \
  -t ios \
  -u "apple@company.com" \
  -p "app-specific-password"

# Using fastlane
fastlane deliver --ipa YourApp.ipa \
  --submit_for_review \
  --automatic_release \
  --force</code></pre>

            <h2>App Store Optimization (ASO)</h2>
            <pre><code class="language-javascript">// ASO strategies
const asoOptimization = {
  visibility: {
    factors: {
      title: '30%',
      keywords: '25%',
      downloads: '20%',
      ratings: '15%',
      updates: '10%',
    },
    
    optimization: [
      'Research high-traffic keywords',
      'A/B test different titles',
      'Localize for key markets',
      'Update regularly',
      'Encourage positive reviews',
    ],
  },
  
  conversion: {
    factors: {
      icon: '35%',
      screenshots: '35%',
      description: '20%',
      preview: '10%',
    },
    
    tips: {
      icon: [
        'Simple and memorable',
        'Test on various backgrounds',
        'Avoid text',
        'Stand out in category',
      ],
      
      screenshots: [
        'Show key features first',
        'Add captions',
        'Tell a story',
        'Show actual UI',
        'Highlight benefits',
      ],
      
      description: [
        'Front-load key features',
        'Use formatting',
        'Include social proof',
        'Clear value proposition',
        'Call to action',
      ],
    },
  },
  
  localization: {
    priority: [
      'English (US)',
      'Chinese Simplified',
      'Japanese',
      'Spanish',
      'German',
      'French',
    ],
    
    elements: [
      'App name',
      'Keywords',
      'Description',
      'Screenshots',
      'Preview videos',
    ],
  },
};</code></pre>

            <h2>Post-Launch Management</h2>
            <pre><code class="language-javascript">// Monitor and improve
const postLaunchTasks = {
  analytics: {
    appStoreConnect: [
      'App Units (downloads)',
      'Sales',
      'Usage metrics',
      'Crashes',
      'Ratings and reviews',
    ],
    
    customAnalytics: [
      'User retention',
      'Feature usage',
      'Conversion funnels',
      'Revenue metrics',
    ],
  },
  
  updates: {
    types: {
      minor: {
        frequency: '2-4 weeks',
        content: 'Bug fixes, small improvements',
        review: 'Usually quick (24h)',
      },
      
      major: {
        frequency: '2-3 months',
        content: 'New features, redesigns',
        review: 'Standard time (24-48h)',
      },
      
      critical: {
        frequency: 'As needed',
        content: 'Critical fixes',
        review: 'Request expedited',
      },
    },
    
    versionNaming: {
      format: 'MAJOR.MINOR.PATCH',
      examples: {
        '2.0.0': 'Major release',
        '2.1.0': 'Feature addition',
        '2.1.1': 'Bug fix',
      },
    },
  },
  
  reviewManagement: {
    monitoring: [
      'Daily review check',
      'Respond within 24h',
      'Track sentiment',
      'Address issues',
    ],
    
    responses: {
      positive: 'Thank you! We appreciate your support.',
      negative: 'We\'re sorry to hear that. Please contact support@...',
      feature: 'Great suggestion! We\'ll consider it for future updates.',
    },
    
    prompting: {
      timing: 'After positive action',
      frequency: 'Once per version',
      method: 'SKStoreReviewController',
    },
  },
};</code></pre>

            <h2>App Store Connect API</h2>
            <pre><code class="language-javascript">// Automate App Store tasks
const jwt = require('jsonwebtoken');
const axios = require('axios');

class AppStoreConnectAPI {
  constructor(issuerId, keyId, privateKey) {
    this.issuerId = issuerId;
    this.keyId = keyId;
    this.privateKey = privateKey;
    this.baseURL = 'https://api.appstoreconnect.apple.com/v1';
  }
  
  generateToken() {
    const payload = {
      iss: this.issuerId,
      exp: Math.floor(Date.now() / 1000) + (20 * 60),
      aud: 'appstoreconnect-v1',
    };
    
    return jwt.sign(payload, this.privateKey, {
      algorithm: 'ES256',
      keyid: this.keyId,
    });
  }
  
  async getApp(bundleId) {
    const token = this.generateToken();
    
    const response = await axios.get(
      \`\${this.baseURL}/apps?filter[bundleId]=\${bundleId}\`,
      {
        headers: {
          Authorization: \`Bearer \${token}\`,
        },
      }
    );
    
    return response.data.data[0];
  }
  
  async createBetaGroup(appId, name) {
    const token = this.generateToken();
    
    const response = await axios.post(
      \`\${this.baseURL}/betaGroups\`,
      {
        data: {
          type: 'betaGroups',
          attributes: { name },
          relationships: {
            app: {
              data: { type: 'apps', id: appId },
            },
          },
        },
      },
      {
        headers: {
          Authorization: \`Bearer \${token}\`,
          'Content-Type': 'application/json',
        },
      }
    );
    
    return response.data.data;
  }
}</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>App Store Best Practices:</h4>
                <ul>
                    <li>Follow Human Interface Guidelines (HIG)</li>
                    <li>Test on all supported devices and iOS versions</li>
                    <li>Provide demo account for review</li>
                    <li>Respond to reviews professionally</li>
                    <li>Keep metadata accurate and updated</li>
                    <li>Use TestFlight for thorough testing</li>
                    <li>Plan for App Review time (24-48 hours)</li>
                    <li>Monitor crash reports and fix quickly</li>
                    <li>Implement proper data privacy practices</li>
                    <li>Consider seasonal timing for releases</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Submit your app to the App Store:</p>
                <ul>
                    <li>Set up App Store Connect</li>
                    <li>Create compelling app listing</li>
                    <li>Prepare screenshots for all devices</li>
                    <li>Configure TestFlight beta</li>
                    <li>Submit for App Review</li>
                    <li>Monitor analytics post-launch</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the annual fee for Apple Developer Program?",
            options: [
                "$25",
                "$99",
                "$199",
                "$299"
            ],
            correct: 1,
            explanation: "The Apple Developer Program costs $99 per year for individuals and organizations."
        },
        {
            question: "How many external TestFlight testers are allowed?",
            options: [
                "100",
                "1,000",
                "10,000",
                "Unlimited"
            ],
            correct: 2,
            explanation: "TestFlight allows up to 10,000 external testers via email invitation."
        },
        {
            question: "What's the maximum app name length in App Store?",
            options: [
                "25 characters",
                "30 characters",
                "50 characters",
                "100 characters"
            ],
            correct: 1,
            explanation: "App Store limits app names to 30 characters maximum."
        }
    ],
    project: {
        title: "App Store Launch Campaign",
        description: "Plan and execute a successful App Store launch with optimization",
        requirements: [
            "Create App Store Connect listing",
            "Design all required screenshots",
            "Write optimized description",
            "Set up TestFlight beta program",
            "Implement analytics tracking",
            "Create review response templates",
            "Plan update schedule",
            "Monitor post-launch metrics"
        ],
        hints: [
            "Use ASO tools for keyword research",
            "A/B test app icons",
            "Localize for top markets",
            "Build email list for launch",
            "Plan PR for launch day"
        ]
    }
},
'codepush': {
    content: `
        <div class="content-section">
            <h1>CodePush Updates</h1>
            
            <div class="info-box">
                <p>Learn how to implement over-the-air updates using Microsoft CodePush. Deploy JavaScript and asset updates instantly without going through app store review processes.</p>
            </div>

            <h2>CodePush Overview</h2>
            <pre><code class="language-javascript">// What CodePush can update
const codePushCapabilities = {
  canUpdate: [
    'JavaScript bundle',
    'Images and assets',
    'Configuration files',
    'Styling changes',
    'Bug fixes',
    'Minor features',
    'A/B testing variants',
  ],
  
  cannotUpdate: [
    'Native code changes',
    'Native dependencies',
    'Binary resources',
    'Permission changes',
    'Platform-specific code',
    'Major architectural changes',
  ],
  
  benefits: [
    'Instant updates',
    'No app store review',
    'Rollback capability',
    'Staged rollouts',
    'A/B testing',
    'Multiple environments',
    'Analytics integration',
  ],
  
  limitations: [
    'Bundle size limits',
    'Native code unchanged',
    'User bandwidth consideration',
    'Battery impact',
  ],
};</code></pre>

            <h2>Installation & Setup</h2>
            <pre><code class="language-bash"># Install CodePush CLI
npm install -g appcenter-cli

# Login to App Center
appcenter login

# Create apps in App Center
appcenter apps create -d MyApp-iOS -o iOS -p React-Native
appcenter apps create -d MyApp-Android -o Android -p React-Native

# Add CodePush deployments
appcenter codepush deployment add -a YourOrg/MyApp-iOS Staging
appcenter codepush deployment add -a YourOrg/MyApp-iOS Production
appcenter codepush deployment add -a YourOrg/MyApp-Android Staging
appcenter codepush deployment add -a YourOrg/MyApp-Android Production

# Get deployment keys
appcenter codepush deployment list -a YourOrg/MyApp-iOS -k
appcenter codepush deployment list -a YourOrg/MyApp-Android -k

# Install React Native CodePush
npm install react-native-code-push

# iOS setup
cd ios && pod install</code></pre>

            <h2>iOS Configuration</h2>
            <pre><code class="language-swift">// ios/YourApp/AppDelegate.m
#import <CodePush/CodePush.h>

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  #ifdef DEBUG
    return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
  #else
    return [CodePush bundleURL];
  #endif
}

// ios/YourApp/Info.plist
<key>CodePushDeploymentKey</key>
<string>YOUR_IOS_DEPLOYMENT_KEY</string>

// For multi-deployment setup
<key>CodePushDeploymentKey</key>
<string>$(CODEPUSH_KEY)</string>

// In Build Settings, add User-Defined settings:
// CODEPUSH_KEY_DEBUG = Staging-Key
// CODEPUSH_KEY_RELEASE = Production-Key</code></pre>

            <h2>Android Configuration</h2>
            <pre><code class="language-java">// android/app/src/main/java/.../MainApplication.java
import com.microsoft.codepush.react.CodePush;

@Override
protected String getJSBundleFile() {
    return CodePush.getJSBundleFile();
}

@Override
protected List<ReactPackage> getPackages() {
    return Arrays.<ReactPackage>asList(
        new MainReactPackage(),
        new CodePush(getResources().getString(R.string.CodePushDeploymentKey), 
                     getApplicationContext(), 
                     BuildConfig.DEBUG)
    );
}

// android/app/src/main/res/values/strings.xml
<string name="CodePushDeploymentKey">YOUR_ANDROID_DEPLOYMENT_KEY</string>

// For build variants (android/app/build.gradle)
buildTypes {
    debug {
        resValue "string", "CodePushDeploymentKey", '"STAGING_KEY"'
    }
    release {
        resValue "string", "CodePushDeploymentKey", '"PRODUCTION_KEY"'
    }
}</code></pre>

            <h2>React Native Implementation</h2>
            <pre><code class="language-javascript">import CodePush from 'react-native-code-push';
import React, { Component, useEffect, useState } from 'react';
import { View, Text, Modal, ProgressBar } from 'react-native';

// Basic CodePush HOC
const App = () => {
  return <YourApp />;
};

// Wrap with CodePush
export default CodePush(App);

// With options
const codePushOptions = {
  checkFrequency: CodePush.CheckFrequency.ON_APP_START,
  installMode: CodePush.InstallMode.IMMEDIATE,
  mandatoryInstallMode: CodePush.InstallMode.IMMEDIATE,
  updateDialog: {
    title: 'Update Available',
    mandatoryUpdateMessage: 'An update is required to continue.',
    mandatoryContinueButtonLabel: 'Update',
    optionalIgnoreButtonLabel: 'Later',
    optionalInstallButtonLabel: 'Update',
    optionalUpdateMessage: 'An update is available. Would you like to install it?',
  },
};

export default CodePush(codePushOptions)(App);

// Custom update experience
const CodePushWrapper = ({ children }) => {
  const [updateProgress, setUpdateProgress] = useState(null);
  const [showUpdateModal, setShowUpdateModal] = useState(false);
  const [updateInfo, setUpdateInfo] = useState(null);

  useEffect(() => {
    checkForUpdate();
  }, []);

  const checkForUpdate = async () => {
    try {
      const update = await CodePush.checkForUpdate();
      
      if (update) {
        setUpdateInfo(update);
        
        if (update.isMandatory) {
          // Force update for mandatory updates
          downloadUpdate();
        } else {
          // Show dialog for optional updates
          setShowUpdateModal(true);
        }
      }
    } catch (error) {
      console.log('CodePush check error:', error);
    }
  };

  const downloadUpdate = () => {
    setShowUpdateModal(false);
    
    CodePush.sync(
      {
        updateDialog: false,
        installMode: CodePush.InstallMode.IMMEDIATE,
        mandatoryInstallMode: CodePush.InstallMode.IMMEDIATE,
      },
      (status) => {
        switch (status) {
          case CodePush.SyncStatus.DOWNLOADING_PACKAGE:
            console.log('Downloading update...');
            break;
          case CodePush.SyncStatus.INSTALLING_UPDATE:
            console.log('Installing update...');
            break;
          case CodePush.SyncStatus.UPDATE_INSTALLED:
            console.log('Update installed!');
            break;
        }
      },
      ({ receivedBytes, totalBytes }) => {
        const progress = (receivedBytes / totalBytes) * 100;
        setUpdateProgress(progress);
      }
    );
  };

  return (
    <>
      {children}
      
      <Modal visible={showUpdateModal} transparent>
        <View style={styles.modalContainer}>
          <View style={styles.modalContent}>
            <Text style={styles.title}>Update Available</Text>
            <Text style={styles.message}>
              Version {updateInfo?.label} is available with new features and improvements.
            </Text>
            <Text style={styles.description}>
              {updateInfo?.description}
            </Text>
            
            <View style={styles.buttons}>
              <TouchableOpacity 
                onPress={() => setShowUpdateModal(false)}
                style={styles.laterButton}
              >
                <Text>Later</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                onPress={downloadUpdate}
                style={styles.updateButton}
              >
                <Text style={styles.updateButtonText}>Update Now</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
      
      {updateProgress !== null && (
        <View style={styles.progressContainer}>
          <Text>Updating... {Math.round(updateProgress)}%</Text>
          <ProgressBar progress={updateProgress / 100} />
        </View>
      )}
    </>
  );
};</code></pre>

            <h2>Deployment Strategies</h2>
            <pre><code class="language-javascript">// Deployment configuration
const deploymentStrategies = {
  immediate: {
    installMode: CodePush.InstallMode.IMMEDIATE,
    use: 'Critical fixes, mandatory updates',
    userExperience: 'App restarts immediately',
  },
  
  onNextRestart: {
    installMode: CodePush.InstallMode.ON_NEXT_RESTART,
    use: 'Non-critical updates',
    userExperience: 'Updates on next app launch',
  },
  
  onNextResume: {
    installMode: CodePush.InstallMode.ON_NEXT_RESUME,
    minimumBackgroundDuration: 5 * 60, // 5 minutes
    use: 'Feature updates',
    userExperience: 'Updates when app returns from background',
  },
  
  onNextSuspend: {
    installMode: CodePush.InstallMode.ON_NEXT_SUSPEND,
    use: 'Large updates',
    userExperience: 'Updates when app goes to background',
  },
};

// Advanced sync options
const advancedSync = () => {
  CodePush.sync(
    {
      deploymentKey: 'YOUR_DEPLOYMENT_KEY',
      installMode: CodePush.InstallMode.ON_NEXT_RESUME,
      mandatoryInstallMode: CodePush.InstallMode.IMMEDIATE,
      minimumBackgroundDuration: 60 * 10, // 10 minutes
      
      updateDialog: {
        appendReleaseDescription: true,
        descriptionPrefix: '\\n\\nChanges:\\n',
      },
      
      rollbackRetryOptions: {
        delayInHours: 24,
        maxRetryAttempts: 1,
      },
    },
    syncStatusCallback,
    downloadProgressCallback,
    handleBinaryVersionMismatchCallback
  );
};

// Multi-deployment setup
const getDeploymentKey = () => {
  if (__DEV__) {
    return 'STAGING_DEPLOYMENT_KEY';
  }
  
  // Production variants
  const buildConfig = getBuildConfiguration();
  
  switch (buildConfig.channel) {
    case 'beta':
      return 'BETA_DEPLOYMENT_KEY';
    case 'production':
      return 'PRODUCTION_DEPLOYMENT_KEY';
    default:
      return 'STAGING_DEPLOYMENT_KEY';
  }
};</code></pre>

            <h2>Release Management</h2>
            <pre><code class="language-bash"># Release update to Staging
appcenter codepush release-react \
  -a YourOrg/MyApp-iOS \
  -d Staging \
  --description "Bug fixes and performance improvements" \
  --mandatory

# Release with specific version targeting
appcenter codepush release-react \
  -a YourOrg/MyApp-Android \
  -d Production \
  --target-binary-version "1.0.0" \
  --description "New features available!" \
  --rollout 25

# Promote from Staging to Production
appcenter codepush deployment promote \
  -a YourOrg/MyApp-iOS \
  -s Staging \
  -d Production \
  --rollout 10 \
  --description "Promoted from staging"

# Rollback a release
appcenter codepush rollback \
  -a YourOrg/MyApp-iOS \
  Production

# View deployment history
appcenter codepush deployment history \
  -a YourOrg/MyApp-iOS \
  Production

# Clear deployment history
appcenter codepush deployment clear \
  -a YourOrg/MyApp-iOS \
  Staging</code></pre>

            <h2>Rollout Strategies</h2>
            <pre><code class="language-javascript">// Gradual rollout configuration
const rolloutStrategy = {
  phases: [
    { percentage: 1, duration: '1 hour', monitor: 'crashes' },
    { percentage: 5, duration: '4 hours', monitor: 'crashes, ratings' },
    { percentage: 10, duration: '12 hours', monitor: 'all metrics' },
    { percentage: 25, duration: '24 hours', monitor: 'all metrics' },
    { percentage: 50, duration: '24 hours', monitor: 'all metrics' },
    { percentage: 100, duration: 'permanent', monitor: 'ongoing' },
  ],
  
  rollbackCriteria: {
    crashRate: '> 2%',
    negativeReviews: '> 10%',
    customMetrics: 'Define thresholds',
  },
};

// A/B testing with CodePush
const setupABTest = async () => {
  const update = await CodePush.getUpdateMetadata();
  
  // Use deployment as variant
  const variant = update?.deploymentKey === 'VARIANT_A_KEY' ? 'A' : 'B';
  
  // Track variant in analytics
  analytics.setUserProperty('codepush_variant', variant);
  
  // Apply variant-specific features
  if (variant === 'A') {
    enableFeatureA();
  } else {
    enableFeatureB();
  }
};

// Monitoring script
const monitorDeployment = async (appName, deployment) => {
  const metrics = await appcenter.codepush.getDeploymentMetrics(
    appName,
    deployment
  );
  
  console.log(\`Active installs: \${metrics.activeInstalls}\`);
  console.log(\`Total installs: \${metrics.totalInstalls}\`);
  console.log(\`Rollbacks: \${metrics.rollbacks}\`);
  console.log(\`Downloads: \${metrics.downloads}\`);
  
  // Alert if issues
  if (metrics.rollbacks > metrics.totalInstalls * 0.02) {
    sendAlert('High rollback rate detected!');
  }
};</code></pre>

            <h2>Security & Best Practices</h2>
            <pre><code class="language-javascript">// Security considerations
const codePushSecurity = {
  signing: {
    // Sign releases for additional security
    command: 'appcenter codepush release-react -a App -d Production --private-key-path ./private.pem',
    
    verification: {
      ios: 'Add public key to iOS bundle',
      android: 'Add public key to Android assets',
    },
  },
  
  encryption: {
    available: false,
    alternative: 'Use encrypted storage for sensitive data',
  },
  
  bestPractices: [
    'Never include sensitive data in updates',
    'Use mandatory updates for security fixes',
    'Monitor rollback rates',
    'Test updates thoroughly in staging',
    'Keep deployment keys secure',
    'Rotate keys periodically',
  ],
};

// Update size optimization
const optimizeUpdateSize = {
  techniques: [
    'Minimize JavaScript bundle',
    'Compress images',
    'Remove unused assets',
    'Use dynamic imports',
    'Exclude development code',
  ],
  
  commands: {
    // Analyze bundle size
    analyze: 'npx react-native-bundle-visualizer',
    
    // Create optimized release
    release: \`appcenter codepush release-react \\
      -a YourApp-iOS \\
      -d Production \\
      --output-dir ./build \\
      --sourcemap-output ./build/index.ios.map \\
      --bundle-name index.ios.bundle \\
      --development false\`,
  },
};

// Error handling
const handleCodePushErrors = {
  downloadFailed: async (error) => {
    console.log('Download failed:', error);
    // Retry with exponential backoff
    await retryWithBackoff(() => CodePush.sync());
  },
  
  installFailed: async (error) => {
    console.log('Install failed:', error);
    // Report to analytics
    analytics.logEvent('codepush_install_failed', { error: error.message });
  },
  
  updateRolledBack: async (update) => {
    console.log('Update rolled back:', update.label);
    // Notify backend
    await api.reportRollback(update);
  },
};</code></pre>

            <h2>CI/CD Integration</h2>
            <pre><code class="language-yaml"># GitHub Actions CodePush workflow
name: CodePush Release

on:
  push:
    branches: [ release/* ]

jobs:
  codepush-ios:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
          
      - name: Install dependencies
        run: |
          npm ci
          cd ios && pod install
          
      - name: Install AppCenter CLI
        run: npm install -g appcenter-cli
        
      - name: Login to AppCenter
        run: |
          appcenter login --token {{ secrets.APPCENTER_TOKEN }}
          
      - name: Release to Staging
        run: |
          appcenter codepush release-react \
            -a {{ secrets.APPCENTER_ORG }}/MyApp-iOS \
            -d Staging \
            --description "{{ github.event.head_commit.message }}" \
            --disable-duplicate-release-error
            
      - name: Run E2E tests on staging
        run: npm run test:e2e:staging
        
      - name: Promote to Production
        if: success()
        run: |
          appcenter codepush promote \
            -a {{ secrets.APPCENTER_ORG }}/MyApp-iOS \
            -s Staging \
            -d Production \
            --rollout 10</code></pre>

            <h2>Monitoring & Analytics</h2>
            <pre><code class="language-javascript">// CodePush analytics integration
import analytics from '@react-native-firebase/analytics';

const trackCodePushEvents = () => {
  CodePush.notifyAppReady();
  
  // Track sync status
  CodePush.getUpdateMetadata().then((update) => {
    if (update) {
      analytics.logEvent('codepush_updated', {
        label: update.label,
        version: update.appVersion,
        mandatory: update.isMandatory,
        size: update.packageSize,
      });
    }
  });
  
  // Track update metrics
  const trackUpdateMetrics = async () => {
    const metrics = await CodePush.getUpdateMetadata(CodePush.UpdateState.LATEST);
    
    analytics.setUserProperty('codepush_version', metrics?.label || 'none');
    analytics.setUserProperty('codepush_deployment', metrics?.deploymentKey || 'none');
  };
};

// Custom metrics reporting
const reportCodePushMetrics = {
  updateAvailable: (update) => {
    analytics.logEvent('codepush_update_available', {
      version: update.label,
      size: update.packageSize,
      mandatory: update.isMandatory,
    });
  },
  
  downloadProgress: (progress) => {
    if (progress === 100) {
      analytics.logEvent('codepush_download_complete');
    }
  },
  
  installSuccess: (update) => {
    analytics.logEvent('codepush_install_success', {
      version: update.label,
      installTime: Date.now(),
    });
  },
  
  rollback: (update) => {
    analytics.logEvent('codepush_rollback', {
      version: update.label,
      reason: 'automatic',
    });
  },
};</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>CodePush Best Practices:</h4>
                <ul>
                    <li>Test updates thoroughly in staging first</li>
                    <li>Use gradual rollouts for production</li>
                    <li>Monitor metrics and rollback if needed</li>
                    <li>Keep update sizes small</li>
                    <li>Don't update native dependencies via CodePush</li>
                    <li>Implement proper error handling</li>
                    <li>Use mandatory updates sparingly</li>
                    <li>Version target appropriately</li>
                    <li>Document what each update contains</li>
                    <li>Have a rollback plan ready</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Implement CodePush in your app:</p>
                <ul>
                    <li>Set up App Center account</li>
                    <li>Configure CodePush for both platforms</li>
                    <li>Implement custom update UI</li>
                    <li>Create staging and production deployments</li>
                    <li>Test update flow end-to-end</li>
                    <li>Set up monitoring</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What can CodePush update?",
            options: [
                "Native code",
                "JavaScript bundle and assets",
                "App permissions",
                "Package name"
            ],
            correct: 1,
            explanation: "CodePush can only update JavaScript code and assets, not native code or app configurations."
        },
        {
            question: "What's the recommended initial rollout percentage?",
            options: [
                "100%",
                "50%",
                "10-25%",
                "1-5%"
            ],
            correct: 3,
            explanation: "Starting with 1-5% rollout allows you to monitor for issues before affecting all users."
        },
        {
            question: "When should you use mandatory updates?",
            options: [
                "For all updates",
                "For critical fixes only",
                "Never",
                "For new features"
            ],
            correct: 1,
            explanation: "Mandatory updates should be reserved for critical fixes that users must have immediately."
        }
    ],
    project: {
        title: "OTA Update System",
        description: "Implement a complete over-the-air update system with CodePush including custom UI and monitoring",
        requirements: [
            "Set up CodePush for iOS and Android",
            "Create custom update UI with progress",
            "Implement staging/production deployments",
            "Add update analytics tracking",
            "Create rollout strategy",
            "Set up CI/CD integration",
            "Implement A/B testing",
            "Monitor update metrics"
        ],
        hints: [
            "Use different deployment keys for environments",
            "Test rollback scenarios",
            "Monitor bundle sizes",
            "Create update documentation",
            "Plan for offline users"
        ]
    }
},
'ci-cd': {
    content: `
        <div class="content-section">
            <h1>CI/CD Pipeline</h1>
            
            <div class="info-box">
                <p>Learn how to set up automated continuous integration and deployment pipelines for React Native apps. Automate building, testing, and releasing to both iOS and Android platforms.</p>
            </div>

            <h2>CI/CD Overview</h2>
            <pre><code class="language-javascript">const cicdPipeline = {
  stages: {
    continuous_integration: [
      'Code commit',
      'Automated tests',
      'Code quality checks',
      'Build verification',
      'Security scanning',
    ],
    
    continuous_delivery: [
      'Build artifacts',
      'Deploy to staging',
      'Automated testing',
      'Manual approval',
      'Deploy to production',
    ],
    
    continuous_deployment: [
      'Automated production deploy',
      'Feature flags',
      'Gradual rollout',
      'Monitoring',
      'Automatic rollback',
    ],
  },
  
  benefits: [
    'Faster release cycles',
    'Consistent builds',
    'Early bug detection',
    'Reduced manual errors',
    'Better collaboration',
    'Automated testing',
    'Quick rollbacks',
  ],
  
  tools: {
    cicd_platforms: ['GitHub Actions', 'Bitrise', 'CircleCI', 'Jenkins', 'GitLab CI'],
    build_tools: ['Fastlane', 'Gradle', 'Xcode', 'Metro'],
    testing: ['Jest', 'Detox', 'Appium'],
    distribution: ['App Center', 'Firebase', 'TestFlight', 'Google Play'],
  },
};</code></pre>

            <h2>GitHub Actions Setup</h2>
            <pre><code class="language-yaml"># .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '16'
  RUBY_VERSION: '3.0'

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run ESLint
        run: npm run lint
        
      - name: Run TypeScript check
        run: npm run type-check
        
      - name: Run tests with coverage
        run: npm run test -- --coverage --maxWorkers=2
        
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
          
  build-android:
    needs: lint-and-test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          
      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          java-version: '11'
          distribution: 'zulu'
          
      - name: Cache Gradle
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*') }}
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build Android Release
        env:
          KEYSTORE_FILE: ${{ secrets.ANDROID_KEYSTORE_FILE }}
          KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
        run: |
          echo "$KEYSTORE_FILE" | base64 --decode > android/app/release.keystore
          cd android
          ./gradlew assembleRelease
          
      - name: Upload APK
        uses: actions/upload-artifact@v3
        with:
          name: app-release.apk
          path: android/app/build/outputs/apk/release/app-release.apk
          
  build-ios:
    needs: lint-and-test
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ env.RUBY_VERSION }}
          bundler-cache: true
          
      - name: Install dependencies
        run: |
          npm ci
          cd ios && pod install
          
      - name: Setup certificates
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          BUILD_PROVISION_PROFILE_BASE64: ${{ secrets.BUILD_PROVISION_PROFILE_BASE64 }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          
          # Import certificate and provisioning profile
          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
          echo -n "$BUILD_PROVISION_PROFILE_BASE64" | base64 --decode -o $PP_PATH
          
          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Import certificate
          security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH
          
          # Apply provisioning profile
          mkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles
          cp $PP_PATH ~/Library/MobileDevice/Provisioning\\ Profiles
          
      - name: Build iOS
        run: |
          cd ios
          xcodebuild -workspace YourApp.xcworkspace \
            -scheme YourApp \
            -configuration Release \
            -sdk iphoneos \
            -derivedDataPath ios/build \
            -archivePath ios/build/YourApp.xcarchive \
            archive
            
      - name: Export IPA
        run: |
          xcodebuild -exportArchive \
            -archivePath ios/build/YourApp.xcarchive \
            -exportPath ios/build \
            -exportOptionsPlist ios/exportOptions.plist
            
      - name: Upload IPA
        uses: actions/upload-artifact@v3
        with:
          name: app-release.ipa
          path: ios/build/YourApp.ipa</code></pre>

            <h2>Fastlane Configuration</h2>
            <pre><code class="language-ruby"># fastlane/Fastfile
default_platform(:ios)

# iOS Lanes
platform :ios do
  desc "Push a new release build to TestFlight"
  lane :release do
    # Ensure clean git status
    ensure_git_status_clean
    
    # Increment build number
    increment_build_number(xcodeproj: "ios/YourApp.xcodeproj")
    
    # Get version number
    version = get_version_number(xcodeproj: "ios/YourApp.xcodeproj")
    
    # Build app
    build_app(
      workspace: "ios/YourApp.xcworkspace",
      scheme: "YourApp",
      export_method: "app-store",
      clean: true,
      output_directory: "./build",
      output_name: "YourApp.ipa"
    )
    
    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: true,
      apple_id: ENV["APPLE_ID"],
      app_identifier: ENV["APP_IDENTIFIER"],
      team_id: ENV["TEAM_ID"]
    )
    
    # Commit version bump
    commit_version_bump(
      message: "Bump build number to #{get_build_number}",
      xcodeproj: "ios/YourApp.xcodeproj"
    )
    
    # Create git tag
    add_git_tag(tag: "ios/v#{version}-#{get_build_number}")
    
    # Push changes
    push_to_git_remote
    
    # Notify team
    slack(
      message: "iOS v#{version} (#{get_build_number}) uploaded to TestFlight!",
      webhook_url: ENV["SLACK_WEBHOOK"]
    )
  end
  
  desc "Submit to App Store"
  lane :submit do
    # Download metadata
    download_metadata
    
    # Submit for review
    deliver(
      submit_for_review: true,
      automatic_release: false,
      force: true,
      metadata_path: "./fastlane/metadata",
      screenshots_path: "./fastlane/screenshots",
      skip_metadata: false,
      skip_screenshots: false,
      precheck_include_in_app_purchases: false
    )
  end
end

# Android Lanes
platform :android do
  desc "Build and deploy to Google Play"
  lane :release do
    # Ensure clean git status
    ensure_git_status_clean
    
    # Increment version code
    android_version_code = increment_version_code(
      gradle_file_path: "android/app/build.gradle"
    )
    
    # Build AAB
    gradle(
      task: "bundle",
      build_type: "Release",
      project_dir: "android/",
      properties: {
        "android.injected.signing.store.file" => ENV["KEYSTORE_FILE"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"],
      }
    )
    
    # Upload to Play Store
    upload_to_play_store(
      track: "internal",
      release_status: "draft",
      aab: "android/app/build/outputs/bundle/release/app-release.aab",
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )
    
    # Commit version bump
    git_commit(
      path: ["android/app/build.gradle"],
      message: "Bump Android version code to #{android_version_code}"
    )
    
    # Create git tag
    add_git_tag(tag: "android/v#{get_version_name}-#{android_version_code}")
    
    # Push changes
    push_to_git_remote
  end
  
  desc "Promote to production"
  lane :promote do
    upload_to_play_store(
      track: "internal",
      track_promote_to: "production",
      rollout: "0.1", # 10% rollout
      skip_upload_apk: true,
      skip_upload_aab: true,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )
  end
end

# Shared Lanes
desc "Run tests"
lane :test do
  # JavaScript tests
  sh("npm test")
  
  # iOS tests
  if is_ci
    run_tests(
      workspace: "ios/YourApp.xcworkspace",
      scheme: "YourApp",
      devices: ["iPhone 14"],
      clean: true
    )
  end
  
  # Android tests
  gradle(
    task: "test",
    build_type: "Debug",
    project_dir: "android/"
  )
end</code></pre>

            <h2>Bitrise Configuration</h2>
            <pre><code class="language-yaml"># bitrise.yml
format_version: '11'
default_step_lib_source: https://github.com/bitrise-io/bitrise-steplib.git

app:
  envs:
  - PROJECT_LOCATION: .
  - MODULE: app
  - VARIANT: Release

workflows:
  primary:
    steps:
    - git-clone@6: {}
    
    - npm@1:
        inputs:
        - command: ci
        
    - npm@1:
        inputs:
        - command: run lint
        
    - npm@1:
        inputs:
        - command: test
        
    - install-missing-android-tools@3:
        inputs:
        - gradlew_path: $PROJECT_LOCATION/android/gradlew
        
    - android-build@1:
        inputs:
        - project_location: $PROJECT_LOCATION/android
        - module: $MODULE
        - variant: $VARIANT
        - build_type: aab
        
    - sign-apk@1:
        inputs:
        - android_app: $BITRISE_AAB_PATH
        
    - google-play-deploy@3:
        inputs:
        - service_account_json_key_path: $GOOGLE_PLAY_KEY
        - track: internal
        - app_path: $BITRISE_SIGNED_AAB_PATH
        
    - cocoapods-install@2:
        inputs:
        - source_root_path: $PROJECT_LOCATION/ios
        
    - xcode-archive@4:
        inputs:
        - project_path: $PROJECT_LOCATION/ios/YourApp.xcworkspace
        - scheme: YourApp
        - export_method: app-store
        
    - deploy-to-itunesconnect-deliver@2:
        inputs:
        - bundle_id: com.yourcompany.yourapp
        - itunescon_user: $APPLE_ID
        - password: $APPLE_PASSWORD
        - app_id: $APP_STORE_APP_ID
        
    - slack@3:
        inputs:
        - webhook_url: $SLACK_WEBHOOK
        - channel: "#releases"
        - message: |
            Build successful!
            - iOS: $BITRISE_IPA_PATH
            - Android: $BITRISE_SIGNED_AAB_PATH</code></pre>

            <h2>Environment Configuration</h2>
            <pre><code class="language-javascript">// Environment setup for CI/CD
const environmentSetup = {
  development: {
    API_URL: 'https://api-dev.example.com',
    ENABLE_LOGS: true,
    CODEPUSH_KEY: 'dev-key',
  },
  
  staging: {
    API_URL: 'https://api-staging.example.com',
    ENABLE_LOGS: true,
    CODEPUSH_KEY: 'staging-key',
  },
  
  production: {
    API_URL: 'https://api.example.com',
    ENABLE_LOGS: false,
    CODEPUSH_KEY: 'prod-key',
  },
};

// react-native-config setup
// .env.production
API_URL=https://api.example.com
ENABLE_LOGS=false
CODEPUSH_KEY_IOS=ios-prod-key
CODEPUSH_KEY_ANDROID=android-prod-key

// Build script with environment
// package.json
{
  "scripts": {
    "build:ios:staging": "ENVFILE=.env.staging react-native run-ios --configuration Release",
    "build:ios:prod": "ENVFILE=.env.production react-native run-ios --configuration Release",
    "build:android:staging": "cd android && ENVFILE=.env.staging ./gradlew assembleRelease",
    "build:android:prod": "cd android && ENVFILE=.env.production ./gradlew assembleRelease"
  }
}

// CI environment variables
const ciEnvironmentVariables = {
  // iOS
  MATCH_PASSWORD: 'Fastlane match repository password',
  FASTLANE_USER: 'Apple ID',
  FASTLANE_PASSWORD: 'App-specific password',
  
  // Android  
  KEYSTORE_FILE: 'Base64 encoded keystore',
  KEYSTORE_PASSWORD: 'Keystore password',
  KEY_ALIAS: 'Key alias',
  KEY_PASSWORD: 'Key password',
  
  // Common
  SENTRY_AUTH_TOKEN: 'For sourcemap upload',
  SLACK_WEBHOOK: 'For notifications',
  GITHUB_TOKEN: 'For PR comments',
};</code></pre>

            <h2>Testing in CI/CD</h2>
            <pre><code class="language-javascript">// Comprehensive testing strategy
const testingStrategy = {
  unit: {
    tool: 'Jest',
    coverage: '80%',
    script: 'npm test -- --coverage',
  },
  
  integration: {
    tool: 'React Native Testing Library',
    focus: 'Component integration',
    script: 'npm run test:integration',
  },
  
  e2e: {
    tool: 'Detox',
    platforms: ['iOS', 'Android'],
    devices: ['iPhone 14', 'Pixel 5'],
    script: 'detox test -c ios.release',
  },
  
  performance: {
    tool: 'Flashlight',
    metrics: ['FPS', 'CPU', 'Memory'],
    thresholds: {
      fps: 55,
      cpu: 60,
      memory: 200,
    },
  },
};

// Detox CI configuration
// .detoxrc.json
{
  "testRunner": "jest",
  "runnerConfig": "e2e/config.json",
  "configurations": {
    "ios.release": {
      "device": "simulator",
      "app": "ios.release",
      "testBinaryPath": "ios/build/Build/Products/Release-iphonesimulator/YourApp.app"
    },
    "android.release": {
      "device": "emulator",
      "app": "android.release",
      "testBinaryPath": "android/app/build/outputs/apk/release/app-release.apk"
    }
  },
  "apps": {
    "ios.release": {
      "type": "ios.app",
      "binaryPath": "ios/build/Build/Products/Release-iphonesimulator/YourApp.app",
      "build": "xcodebuild -workspace ios/YourApp.xcworkspace -scheme YourApp -configuration Release -sdk iphonesimulator -derivedDataPath ios/build"
    },
    "android.release": {
      "type": "android.apk",
      "binaryPath": "android/app/build/outputs/apk/release/app-release.apk",
      "build": "cd android && ./gradlew assembleRelease assembleAndroidTest -DtestBuildType=release"
    }
  }
}</code></pre>

            <h2>Release Automation</h2>
            <pre><code class="language-javascript">// Automated release process
const releaseAutomation = {
  versioning: {
    strategy: 'Semantic Versioning',
    format: 'MAJOR.MINOR.PATCH',
    
    triggers: {
      patch: 'fix: commit message',
      minor: 'feat: commit message',
      major: 'BREAKING CHANGE in commit',
    },
    
    tools: ['standard-version', 'semantic-release'],
  },
  
  changelog: {
    generation: 'Automated from commits',
    format: 'Conventional Commits',
    
    sections: [
      'Breaking Changes',
      'Features',
      'Bug Fixes',
      'Performance',
      'Documentation',
    ],
  },
  
  deployment: {
    stages: [
      { name: 'Dev', trigger: 'Push to develop' },
      { name: 'Staging', trigger: 'Push to staging' },
      { name: 'Production', trigger: 'Tag creation' },
    ],
  },
};

// Release script
// scripts/release.js
const { execSync } = require('child_process');
const semver = require('semver');

const createRelease = async (type = 'patch') => {
  // Get current version
  const currentVersion = require('../package.json').version;
  const newVersion = semver.inc(currentVersion, type);
  
  // Update version
  execSync(\`npm version \${newVersion} --no-git-tag-version\`);
  
  // Update iOS
  execSync(\`cd ios && agvtool new-marketing-version \${newVersion}\`);
  execSync(\`cd ios && agvtool next-version -all\`);
  
  // Update Android
  const gradlePath = './android/app/build.gradle';
  const gradle = fs.readFileSync(gradlePath, 'utf8');
  const versionCode = parseInt(gradle.match(/versionCode (\d+)/)[1]) + 1;
  const newGradle = gradle
    .replace(/versionName "[^"]*"/, \`versionName "\${newVersion}"\`)
    .replace(/versionCode \d+/, \`versionCode \${versionCode}\`);
  fs.writeFileSync(gradlePath, newGradle);
  
  // Generate changelog
  execSync('conventional-changelog -p angular -i CHANGELOG.md -s');
  
  // Commit changes
  execSync('git add .');
  execSync(\`git commit -m "chore(release): v\${newVersion}"\`);
  
  // Create tag
  execSync(\`git tag -a v\${newVersion} -m "Release v\${newVersion}"\`);
  
  console.log(\`Released v\${newVersion}\`);
};</code></pre>

            <h2>Monitoring & Notifications</h2>
            <pre><code class="language-javascript">// Build monitoring setup
const buildMonitoring = {
  notifications: {
    slack: {
      webhook: process.env.SLACK_WEBHOOK,
      channels: {
        builds: '#ci-builds',
        releases: '#releases',
        failures: '#ci-failures',
      },
      
      templates: {
        success: \`✅ Build #\${buildNumber} succeeded
          Branch: \${branch}
          Duration: \${duration}
          Artifacts: iOS | Android\`,
          
        failure: \`❌ Build #\${buildNumber} failed
          Branch: \${branch}
          Error: \${error}
          Logs: \${logsUrl}\`,
      },
    },
    
    email: {
      recipients: ['team@company.com'],
      triggers: ['failure', 'release'],
    },
  },
  
  metrics: {
    track: [
      'Build duration',
      'Success rate',
      'Test coverage',
      'Bundle size',
      'Dependencies',
    ],
    
    dashboards: [
      'GitHub Insights',
      'Bitrise Analytics',
      'Custom Grafana',
    ],
  },
};

// GitHub Actions status badge
// README.md
[![CI/CD](https://github.com/org/repo/workflows/CI%2FCD/badge.svg)](https://github.com/org/repo/actions)
[![codecov](https://codecov.io/gh/org/repo/branch/main/graph/badge.svg)](https://codecov.io/gh/org/repo)

// Custom build reporter
const reportBuildMetrics = async (build) => {
  const metrics = {
    buildId: build.id,
    branch: build.branch,
    duration: build.duration,
    status: build.status,
    bundleSize: {
      ios: getFileSize('./build/YourApp.ipa'),
      android: getFileSize('./build/app-release.aab'),
    },
    testResults: {
      passed: build.tests.passed,
      failed: build.tests.failed,
      coverage: build.tests.coverage,
    },
  };
  
  // Send to analytics
  await analytics.track('build_completed', metrics);
  
  // Update dashboard
  await updateDashboard(metrics);
};</code></pre>

            <h2>Security in CI/CD</h2>
            <pre><code class="language-javascript">// Security best practices
const cicdSecurity = {
  secrets: {
    storage: [
      'Use CI/CD platform secrets',
      'Encrypt sensitive files',
      'Rotate credentials regularly',
      'Use least privilege principle',
    ],
    
    scanning: {
      dependencies: 'npm audit, yarn audit',
      code: 'ESLint security plugin',
      secrets: 'git-secrets, truffleHog',
      containers: 'Trivy, Clair',
    },
  },
  
  signing: {
    ios: {
      certificates: 'Store in CI secrets',
      provisioning: 'Use match or manually manage',
      keychain: 'Create temporary in CI',
    },
    
    android: {
      keystore: 'Base64 encode in secrets',
      googlePlay: 'Use upload key',
      appSigning: 'Enable Play App Signing',
    },
  },
  
  compliance: {
    checks: [
      'License compliance',
      'Vulnerability scanning',
      'OWASP dependency check',
      'Code quality gates',
    ],
  },
};

// Security scanning workflow
- name: Security Scan
  run: |
    # Dependency vulnerabilities
    npm audit --production
    
    # Secret scanning
    pip install truffleHog
    truffleHog --regex --entropy=False .
    
    # SAST scanning
    docker run --rm -v "$PWD":/src \
      returntocorp/semgrep \
      --config=auto --json -o semgrep.json</code></pre>

            <h2>Best Practices</h2>
            <div class="best-practices">
                <h4>CI/CD Best Practices:</h4>
                <ul>
                    <li>Keep builds fast - parallelize where possible</li>
                    <li>Cache dependencies aggressively</li>
                    <li>Run tests in parallel</li>
                    <li>Use build matrices for multiple configurations</li>
                    <li>Implement proper secret management</li>
                    <li>Version everything including CI configs</li>
                    <li>Monitor build times and optimize</li>
                    <li>Set up branch protection rules</li>
                    <li>Automate as much as possible</li>
                    <li>Have rollback procedures ready</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Try It Yourself:</h4>
                <p>Set up a complete CI/CD pipeline:</p>
                <ul>
                    <li>Choose a CI/CD platform</li>
                    <li>Configure automated testing</li>
                    <li>Set up build automation</li>
                    <li>Implement code signing</li>
                    <li>Configure deployment stages</li>
                    <li>Add monitoring and notifications</li>
                    <li>Create rollback procedures</li>
                </ul>
            </div>
        </div>
    `,
    quiz: [
        {
            question: "What's the main benefit of CI/CD?",
            options: [
                "Cheaper hosting",
                "Faster and more reliable releases",
                "Less code to write",
                "Smaller app size"
            ],
            correct: 1,
            explanation: "CI/CD enables faster, more reliable releases by automating testing, building, and deployment processes."
        },
        {
            question: "Where should you store signing certificates in CI/CD?",
            options: [
                "In the repository",
                "In CI/CD secrets",
                "In code comments",
                "On public servers"
            ],
            correct: 1,
            explanation: "Signing certificates should be stored securely in CI/CD platform secrets, never in the repository."
        },
        {
            question: "What's the recommended test coverage threshold?",
            options: [
                "50%",
                "70%",
                "80%+",
                "100%"
            ],
            correct: 2,
            explanation: "80% or higher test coverage is generally recommended, though 100% is often impractical."
        }
    ],
    project: {
        title: "Enterprise CI/CD Pipeline",
        description: "Build a production-ready CI/CD pipeline with automated testing, building, and deployment for both platforms",
        requirements: [
            "Set up GitHub Actions or similar",
            "Configure automated testing suite",
            "Implement code quality checks",
            "Set up iOS and Android builds",
            "Configure code signing automation",
            "Create deployment pipelines",
            "Add security scanning",
            "Implement monitoring and alerts"
        ],
        hints: [
            "Use caching for dependencies",
            "Parallelize test execution",
            "Create reusable workflows",
            "Monitor build times",
            "Document the pipeline"
        ]
    }
},
// Add more topics...
    };

    // Global state
    let currentTopic = 'intro';
    let completedTopics = new Set();

    // Initialize the app
    document.addEventListener('DOMContentLoaded', () => {
      loadSavedProgress();
      renderSidebar();
      renderContent(currentTopic);
      updateProgress();
      initializeServiceWorker();
      checkOfflineStatus();

      // Hide loading screen
      setTimeout(() => {
        document.getElementById('loadingScreen').classList.add('hidden');
      }, 1000);
    });

    // Render sidebar navigation
    function renderSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebar.innerHTML = '';

      courseData.sections.forEach(section => {
        const sectionGroup = document.createElement('div');
        sectionGroup.className = 'section-group';

        const sectionTitle = document.createElement('div');
        sectionTitle.className = 'section-title';
        sectionTitle.innerHTML = `<i class="${section.icon}"></i> ${section.title} <i class="fas fa-chevron-down"></i>`;
        sectionTitle.onclick = () => toggleSection(sectionTitle);

        const topicList = document.createElement('div');
        topicList.className = 'topic-list';

        section.topics.forEach(topic => {
          const topicItem = document.createElement('div');
          topicItem.className = 'topic-item';
          if (topic.id === currentTopic) topicItem.classList.add('active');
          if (completedTopics.has(topic.id)) topicItem.classList.add('completed');
          topicItem.textContent = topic.title;
          topicItem.onclick = () => {
            currentTopic = topic.id;
            renderContent(topic.id);
            renderSidebar();
            closeSidebar();
          };
          topicList.appendChild(topicItem);
        });

        sectionGroup.appendChild(sectionTitle);
        sectionGroup.appendChild(topicList);
        sidebar.appendChild(sectionGroup);
      });
    }

    // Render content area
    function renderContent(topicId) {
      console.log(`Rendering content for topic: ${topicId}`);
      const content = document.getElementById('content');
      console.log(`Content element: ${courseContent}`);
      const topicContent = courseContent[topicId];
      console.log(topicContent);
      if (topicContent) {
        content.innerHTML = topicContent.content;

        // Add complete button
        const completeBtn = document.createElement('button');
        completeBtn.className = 'code-btn';
        completeBtn.style.cssText = 'margin-top: 2rem; padding: 1rem 2rem; font-size: 1rem; background: var(--success);';
        completeBtn.innerHTML = completedTopics.has(topicId)
          ? '<i class="fas fa-check"></i> Completed'
          : '<i class="fas fa-check-circle"></i> Mark as Complete';
        completeBtn.onclick = () => toggleComplete(topicId);
        content.appendChild(completeBtn);

        // Re-highlight code blocks
        Prism.highlightAll();
      } else {
        // Generate content for topics without custom content
        content.innerHTML = `
                    <h1>${topicId.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</h1>
                    <p>This section is coming soon! We're working hard to bring you the best React Native learning experience.</p>
                    <div class="tip-box">
                        <h4><i class="fas fa-construction"></i> Under Construction</h4>
                        <p>Check back soon for detailed content, examples, and exercises for this topic.</p>
                    </div>
                `;
      }
    }

    // Toggle section collapse
    function toggleSection(sectionTitle) {
      sectionTitle.classList.toggle('collapsed');
      sectionTitle.nextElementSibling.classList.toggle('collapsed');
    }

    // Toggle topic completion
    function toggleComplete(topicId) {
      if (completedTopics.has(topicId)) {
        completedTopics.delete(topicId);
      } else {
        completedTopics.add(topicId);

        // Check if all topics completed
        const totalTopics = courseData.sections.reduce((acc, section) => acc + section.topics.length, 0);
        if (completedTopics.size === totalTopics) {
          celebrate();
        }
      }
      saveProgress();
      updateProgress();
      renderSidebar();
      renderContent(currentTopic);
    }

    // Update progress bar
    function updateProgress() {
      const totalTopics = courseData.sections.reduce((acc, section) => acc + section.topics.length, 0);
      const completedCount = completedTopics.size;
      const percentage = Math.round((completedCount / totalTopics) * 100);

      document.getElementById('progressBar').style.width = `${percentage}%`;
      document.getElementById('progressText').textContent = `${percentage}% Complete`;
    }

    // Save progress to localStorage
    function saveProgress() {
      localStorage.setItem('completedTopics', JSON.stringify([...completedTopics]));
      localStorage.setItem('currentTopic', currentTopic);
    }

    // Load saved progress
    function loadSavedProgress() {
      const saved = localStorage.getItem('completedTopics');
      if (saved) {
        completedTopics = new Set(JSON.parse(saved));
      }

      const savedTopic = localStorage.getItem('currentTopic');
      if (savedTopic) {
        currentTopic = savedTopic;
      }
    }

    // Sidebar toggle for mobile
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('open');
    }

    function closeSidebar() {
      if (window.innerWidth <= 1024) {
        document.getElementById('sidebar').classList.remove('open');
      }
    }

    // Dark mode toggle
    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
      const icon = document.getElementById('darkModeIcon');
      icon.className = document.body.classList.contains('dark-mode') ? 'fas fa-sun' : 'fas fa-moon';
      localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
    }

    // Load dark mode preference
    if (localStorage.getItem('darkMode') === 'true') {
      document.body.classList.add('dark-mode');
      document.getElementById('darkModeIcon').className = 'fas fa-sun';
    }

    // Copy code functionality
    function copyCode(btn) {
      const codeBlock = btn.closest('.code-container').querySelector('code');
      const text = codeBlock.textContent;

      navigator.clipboard.writeText(text).then(() => {
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        setTimeout(() => {
          btn.textContent = 'Copy';
          btn.classList.remove('copied');
        }, 2000);
      });
    }

    // Playground functionality
    function switchPlaygroundTab(btn, tab) {
      const playground = btn.closest('.playground');
      const tabs = playground.querySelectorAll('.playground-tab');
      const contents = playground.querySelectorAll('[id^="playground-"]');

      tabs.forEach(t => t.classList.remove('active'));
      btn.classList.add('active');

      contents.forEach(content => {
        if (content.id.includes(tab)) {
          content.style.display = 'block';
        } else {
          content.style.display = 'none';
        }
      });
    }

    function runInPlayground(btn) {
      // This would integrate with an actual React Native playground
      alert('Playground integration coming soon! For now, copy the code and try it in your local environment.');
    }

    function refreshPreview() {
      // Refresh the preview content
      const preview = document.querySelector('.playground-preview');
      preview.style.opacity = '0';
      setTimeout(() => {
        preview.style.opacity = '1';
      }, 300);
    }

    // Quiz functionality
    function checkAnswer(option, isCorrect) {
      const options = option.parentElement.querySelectorAll('.quiz-option');
      options.forEach(opt => {
        opt.classList.remove('selected', 'correct', 'incorrect');
        opt.style.pointerEvents = 'none';
      });

      option.classList.add('selected', isCorrect);

      const feedback = option.closest('.quiz-container').querySelector('.quiz-feedback');
      feedback.className = `quiz-feedback show ${isCorrect}`;
      feedback.innerHTML = isCorrect
        ? '<i class="fas fa-check-circle"></i> Correct! Great job!'
        : '<i class="fas fa-times-circle"></i> Not quite. The correct answer is highlighted above.';

      // Highlight correct answer if wrong
      if (!isCorrect) {
        options.forEach(opt => {
          if (opt.getAttribute('onclick').includes('correct')) {
            opt.classList.add('correct');
          }
        });
      }
    }

    // AI Help functionality
    function toggleAIHelp() {
      const modal = document.getElementById('aiHelpModal');
      modal.classList.toggle('show');
      if (modal.classList.contains('show')) {
        loadAIHelpSuggestions();
      }
    }

    function loadAIHelpSuggestions() {
      const suggestions = document.getElementById('aiHelpSuggestions');
      const commonIssues = [
        { title: 'Metro bundler not starting', solution: 'Try running `npx react-native start --reset-cache`' },
        { title: 'Build failed on iOS', solution: 'Clean build folder in Xcode and run `cd ios && pod install`' },
        { title: 'Android emulator not found', solution: 'Make sure Android SDK is in PATH and emulator is running' },
        { title: 'State not updating', solution: 'Remember state updates are asynchronous. Use functional updates for dependent state.' },
        { title: 'Styling issues', solution: 'React Native uses Flexbox by default. Check flex properties and directions.' },
      ];

      suggestions.innerHTML = commonIssues.map(issue => `
                <div class="ai-help-item" onclick="showAISolution('${issue.title}', '${issue.solution}')">
                    <strong>${issue.title}</strong>
                    <p style="margin: 5px 0 0; font-size: 14px; color: #666;">${issue.solution}</p>
                </div>
            `).join('');
    }

    function showAISolution(title, solution) {
      alert(`${title}\n\nSolution: ${solution}`);
    }

    // Search functionality for AI help
    document.getElementById('aiHelpSearch')?.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase();
      const items = document.querySelectorAll('.ai-help-item');

      items.forEach(item => {
        const text = item.textContent.toLowerCase();
        item.style.display = text.includes(query) ? 'block' : 'none';
      });
    });

    // Celebration animation
    function celebrate() {
      const celebration = document.createElement('div');
      celebration.className = 'celebration';
      document.body.appendChild(celebration);

      // Create confetti
      for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.animationDelay = Math.random() * 3 + 's';
        confetti.style.backgroundColor = ['#007AFF', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'][Math.floor(Math.random() * 5)];
        celebration.appendChild(confetti);
      }

      setTimeout(() => {
        celebration.remove();
        alert('🎉 Congratulations! You\'ve completed the entire React Native course! You\'re now ready to build amazing mobile apps!');
      }, 3000);
    }

    // Service Worker for offline support
    function initializeServiceWorker() {
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js').catch(err => {
          console.log('Service Worker registration failed:', err);
        });
      }
    }

    // Check offline status
    function checkOfflineStatus() {
      const indicator = document.getElementById('offlineIndicator');

      function updateStatus() {
        if (!navigator.onLine) {
          indicator.classList.add('show');
        } else {
          indicator.classList.remove('show');
        }
      }

      window.addEventListener('online', updateStatus);
      window.addEventListener('offline', updateStatus);
      updateStatus();
    }

    // Handle keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Ctrl/Cmd + K for search
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        toggleAIHelp();
      }

      // Escape to close modals
      if (e.key === 'Escape') {
        document.getElementById('aiHelpModal').classList.remove('show');
        document.getElementById('sidebar').classList.remove('open');
      }
    });
  </script>
</body>

</html>
